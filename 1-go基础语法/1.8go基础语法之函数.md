# 函数基础

## 函数定义

**函数是什么？**

​	**函数是组织好的，可复用的，具有特定功能的代码块；**

**go中，支持函数、匿名函数、闭包；**



**函数定义格式：**

```go
func 函数名(参数)(返回值){
	函数体		
}
```

其中：

- 函数名：字母、数字、下划线组成，不能以数字开头，（同一个包内，函数名不能重复）
- 参数：参数与参数变量、参数变量的类型组成，多个参数由,分隔
- 返回值：返回值变量、和其变量类型组成，也可以只写返回值的类型，多个返回值需要用（）包裹，用`,`分隔
- 函数体：实现特定功能的代码块

demo1：2个简单函数示例：

- 求和函数
- 打印字符串函数

```go
package main

import "fmt"

// 求2个整数之和的函数

func sumInt(x int, y int) (res int) {
	res = x + y
	return
}

// 没有参数，和返回值的函数

func justPrint() {
	fmt.Printf("just print")
}

func main() {
	a := sumInt(2, 5)
	fmt.Println(a)
	justPrint()
}

ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
7
just print
```



## 函数的调用

```go
func main() {
	a := sumInt(2, 5)
	fmt.Println(a)
	justPrint()
}

// 根据函数名即可调用，依据函数格式，传参或者不传参；
// 有返回值的函数，也可不接收其返回值
```



## 参数

### 参数简写

当多个传参的类型一致时，可以在最后只写一次它们的类型，如下sumInt2所示：

```go
// 求2个整数之和的函数

func sumInt(x int, y int) int {
	var res = x + y
	return res
}

// 参数的数据类型简写
func sumInt2(x, y int) int {
	var res = x + y
	return res
}
```



### 可变参数

可变长的传参，本质是一个切片，打印其类型，可以发现，

```go
package main

import "fmt"



// 可变长传参数

func sumInt3(x int, y ...int) int { // 格式：参数名...参数类型，用省略号表示
	sum := x
	fmt.Printf("type of y:%T\n", y)
	for _, v := range y {
		sum += v
	}

	return sum
}

// 没有参数，和返回值的函数

func justPrint() {
	fmt.Printf("just print")
}

func main() {
	r1 := sumInt3(100, 10)
	r2 := sumInt3(100, 10, 20)
	r3 := sumInt3(100, 10, 20, 30)

	fmt.Println(r1, r2, r3)
}

ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
type of y:[]int
type of y:[]int
type of y:[]int
110 130 160
```



## 返回值

### 多个返回值

```go
package main

import "fmt"


// 多返回值，当一个函数具有多个返回值时，必须用()将其返回值的类型都包裹起来

func f1(x, y int)(int, int)  {
	sum := x + y
	sub := x - y 
	return sum, sub
}



// 返回值命名

// 返回值补充


func main()  {
	fmt.Println(f1(10, 8))
}
ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
18 2
```



### 返回值命名

```go
package main

import "fmt"

// 返回值命名
// 在定义返回值的第二个扩号，定义了返回值的变量名：sum和sub，相当于已经先声明了变量名
// 因此在函数体中，可以直接使用，因此使用的是= 直接赋值，而不是:= 声明并赋值
// return时，也无需指定返回哪个值，（因为就是返回sum和sub

func f2(x, y int)(sum, sub int)  {
	sum = x + y
	sub = x - y
	return
}

// 返回值补充


func main()  {
	fmt.Println(f1(10, 8))
	fmt.Println(f2(8, 6))
}
ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
18 2
14 2
```



### 返回值补充

不对？

```go
// 返回值补充,当返回值是一个空的切片时，可以直接返回一个nil，nil可以作为空的切片返回，而无需[]int{}

func f3(x string) []int {
	if x == "" {
		return nil
	}
}

func main() {
	fmt.Println(f1(10, 8))
	fmt.Println(f2(8, 6))
	fmt.Println(f3(""))
}
ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
# command-line-arguments
.\main.go:27:1: missing return at end of function
```



# 函数进阶

## 变量作用域

### 全局变量

```go
package main

import "fmt"


// 全局变量

var n1 int = 10

func main()  {
	fmt.Println(n1)
}

ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
10

```



### 局部变量

```go
package main

import "fmt"


// 全局变量

var n1 int = 10

func f1(x int) int {
	sum := x + 1
	fmt.Println(x)
	return sum
}

func main()  {
	fmt.Println(n1)
	fmt.Println(x)
}
// 编译报错，x未定义，因为x只在 f1函数内生效

ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
# command-line-arguments
.\main.go:18:14: undefined: x
```



### 局部变量优先

```
// 全局变量、局部变量，同名时，局部变量优先

package main

import "fmt"


// 全局变量

var n1 int = 10

func f1(x int) int {
	sum := x + 1
	fmt.Println(x)
	return sum
}

func main()  {
	var n1 int = 100
	fmt.Println(n1)
	
}
ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
100
```



### if、for、语句块中的局部变量

```

func main()  {
	var n1 int = 100
	fmt.Println(n1)

	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}

	fmt.Println(i) // i只在for语句块中有效，for，switch同理
	
}
$ go run main.go
# command-line-arguments
.\main.go:24:14: undefined: i
```



## 函数类型与变量

### 定义函数类型

**不仅仅可以定义一般数据类型的变量，还可以定义类型为函数的变量：**

eg：

```go
package main

import "fmt"


type cal func(int, int) int  // 定义了一个变量类型，其类型是接收2个int，返回一个int的函数类型，凡事满足该格式的函数定义，都是属于该类型，如下的add 和 sub

func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}


var c cal = add // 定义了一个变量c，其类型是一个函数类型，
 // c 和 add都符合上面的函数类型定义，因此 add 和sub 都是 可以赋值给c

//赋值后， c 和 add一样，具有了add函数的功能

func main()  {
	fmt.Println(c(10, 100))
	fmt.Println(add( 100, 100))
}
$ go run main.go 
110
200
```



### 函数类型变量

```go
package main

import "fmt"


type cal func(int, int) int  // 定义了一个变量类型，其类型是接收2个int，返回一个int的函数类型，凡事满足该格式的函数定义，都是属于该类型，如下的add 和 sub

func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}





func main()  {
	c := add // add 和sub都属于上述定义的cal函数类型，将其分别赋值给c和d后，c，d也成为了该类型的变量；
	d := sub

	fmt.Println(c(10, 100))
	fmt.Printf("type of c :%T\n", c)
	fmt.Println(d(100, 10))
	fmt.Printf("type of d :%T\n",  d) // 打印其类型，函数类型
	
}
$ go run main.go 
110
type of c :func(int, int) int
90
type of d :func(int, int) int
```



## 高阶函数

**高阶函数中：函数可以作为参数，也可以作为返回值；**

### 函数作为参数

```go
package main

import "fmt"

// 高阶函数：函数作为参数
func add(x, y int) int {
	return x + y
}

func cal(x, y int, op func(int, int) int) int   { // 传参为2个整型，一个函数型，（该函数类型为接收2个int，返回一个int），整体该函数返回一个int整型
	return op(x, y) // 返回的int整型为，传递的函数对x和y处理后的结果，
	
}
func main()  {
	res := cal(10, 20, add) // 传递10，20 2个整型，一个函数名，add，该add函数符合cal传参的要求，
	fmt.Println(res)
}

$ go run main.go 
30

```



### 函数作为返回值

```go
package main

import (
	"errors"
	"fmt"
)

// 高阶函数：函数作为返回值

func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func do(s string) (func(int, int) int, error) {
	switch s {
	case "+":
		return add, nil
	case "-":
		return sub, nil
	default:
		err := errors.New("无法识别的操作符")
		return nil, err
	}

}

func main() {
	fmt.Println(do("+"))
	fmt.Println(do("-"))
	fmt.Println(do("*"))
}
ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master)
$ go run main.go
0x49e750 <nil>
0x49e770 <nil>        
<nil> 无法识别的操作符
```



## 匿名函数与闭包

### 匿名函数

在函数内部定义的函数，**不可以加名字，即匿名函数，**匿名函数可以有传参和返回值，但是不可以通过名字调用，**所以匿名函数1：保存到变量，通过变量名调用，2：定义为立即执行函数，定义后通过()直接传参使用**

e.g.

```go
package main

import "fmt"

// 匿名函数

func main() {

	// 将匿名函数保存到变量

	add := func(x, y int) {
		fmt.Println(x + y)
	}
	add(10, 20)

	// 自执行函数，添加完匿名函数直接执行，适合只运行一次的代码块

	func(x, y int) {
		fmt.Println(x - y)
	}(20, 10)

}
latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master)
$ go run main.go
30
10
```

匿名函数，多用于回调函数，和闭包

### 闭包
**闭包定义**

- 闭包，首先是一个函数
- 闭包，还包含其外部作用域的变量
- 闭包就是：函数，和该函数对其外部作用域变量的引用，2者的集合

**符合闭包定义的示例**

```go
package main

import "fmt"

func add(x int) func(int) int{

	return func(y int) int {
		x += y
		return x
	}
}

func main(){
	res := add(10)
	// res 是add函数的返回值，返回值是一个函数类型，该函数接收一个int，返回一个int
	// 向res传一个20，y=20，返回的x=x+20，而x=10，是add中一开始传递的10，所以最终结果是30


	// 闭包是一个函数
	// 闭包且包含其函数外部作用域的变量
	// 所以，闭包就是：函数+函数外部作用域的变量的引用

	
	fmt.Println(res(20))
}

```



![image-20210113160341680](https://gitee.com/boogie96/pic-go-bed/raw/master/img/image-20210113160341680.png)

demo1

下例的f是adder函数的返回值，是函数类型，此时f就是一个闭包，包含其函数定义和其外部作用域的变量x，闭包：

```
	var x int // 没赋值，默认是0

	return func(y int) int {
		x += y
		return x
	} // return不算
```



```go
package main

import "fmt"

func adder() func(int) int {
	var x int // 没赋值，默认是0

	return func(y int) int {
		x += y
		return x
	}
}

func main() {

	f := adder()
	// 注意x是f函数的外部作用域的变量，每调用一次f函数，对x的修改是会累积的
	fmt.Println(f(10)) // 10
	fmt.Println(f(20)) // 30
	fmt.Println(f(30))    // 60

	// 又新调用了一次adder，此时x重新等于0
	f1 := adder()
	fmt.Println(f1(30)) // 30
	fmt.Println(f1(50)) // 80
}

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master)
$ go run main.go
10
30
60
30
80
```




e.g.

```go
package main

import "fmt"

func f1(f func()) {

	fmt.Println("this is f1")
	f()
}

func f2(x, y int) {
	fmt.Println("this is f2")
	fmt.Println(x + y)
}

// 要求：f1(f2) 将f2传递到f1中
// 因f2的函数类型，不符号f1能接收的类型
// 需要用闭包包装一下

// 包装思路：
// f2 不能直接传递到f1中，那先构造一个能接收f2类型传参的函数f3，
// 现在，f2能“套进”f3里了，f3再返回一个符合f1传参要求的函数类型
// 1，调用f3获得返回值 2，f3的返回值传递给f1，该返回值是符号f1传参要求的 没有传参，没有返回值的函数，改函数中调用了传递给f3的f2函数，从而实现了传递f2到f1中
// 总结：就是包装，f3中通过定义个匿名函数，将接收进来的f2包装一下，然后返回改匿名函数（该匿名函数符号f1的传参要求
// 如下是f3的包装示例

func f3(f func(int, int), x, y int) func() {

	tmp := func() {
		f(x, y)
	}
	return tmp
	// 另一个写法 直接return
	// return func () {
	// 	f(x, y)
	// }

}


func main() {
	res := f3(f2, 100, 200) // 此时 res是f3的返回值，是无传参，无返回值的函数类型，就是套在f2函数的壳子，但因为满足f1的传参要求，可以传递给f1

	f1(res)
}

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master)
$ go run main.go
this is f1
this is f2
300
```



## defer语句

### defer执行时机

### defer经典案例

### defer面试题

# 内置函数介绍

## panic/recover

# 练习



