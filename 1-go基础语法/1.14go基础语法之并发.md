# 并发与并行

**Golang语言层面即支持并发**

**并发：同一个时间段内执行多个任务（“单核心情况下“，在同一个时间段，在多个任务之间切换，从宏观一段时间上来看，就像是这些任务在同时进行；但是！同一个时间点，只能执行一个任务**

**并行：同一个时刻执行多个任务（需要有多个处理“核心”，每个处理核心都处理任务，可以在同一个时刻/时间点，同时进行**

Golang的并发通过goroutine实现，goroutine类似线程，属于用户态的线程，根据需要，可以创建成千上万个goroutine进行并发工作，goroutine是由go语言的运行时runtime调度完成，而线程是由操作系统调度完成

go提供了channel在多个goroutine间进行通信，goroutine和channel是go秉承的CSP（communication sequential process）并发模式的重要实现基础

# goroutine

java/c++中，我们需要实现并发的时候，通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需自己去调度线程执行任务并维护上下文切换，比较耗费心智，而**golang提供了一种机制：程序员只需要定义很多个任务，让go的运行时去帮助程序员把这些任务分配到cpu上实现并发执行，即go的goroutine。**

goroutine的概念类似于线程，但goroutine是由go的运行时runtime调度和管理的，go程序会智能地把goroutine中任务合理分配给每个cpu。

**go在语言层面，内置了调度和上下文切换**

go编程中，你不需要去自己写进程、线程、协程，当需要让某个任务并发执行的时候，只需要把任务包装成一个函数，加个go关键字，开启一个goroutine去执行这个函数就行了。

## 使用goroutine

go语言中，使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine

一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数

## 启动单个goroutine

启动goroutine，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字

e.g.

下例中，hello（）函数和下方的打印是串行，

```go
package main

import "fmt"

func hello() {
	fmt.Println("this is hello func")
}

func main() {
	hello()
	fmt.Println("this is main func")
}


latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/18goroutine (master)
$ go run main.go
this is hello func
this is main func
```

**利用goroutine启动函数**

在调用hello()函数前，加一个go就可以了，但是输出中只输出了一句this is main func 没有输出hello函数中的内容，**原因是启动一个goroutine会耗费一点时间，但此时代码会继续向下执行，打印下方的内容，之后main函数就会退出，main含数一退出，其内部启动的所有goroutine都会被停掉，**

```go
package main

import "fmt"

func hello() {
	fmt.Println("this is hello func")
}

func main() {
	go hello()
	fmt.Println("this is main func")
}
$ go run main.go
this is main func
```

**解决方法：打印后sleep个几秒，给goroutine内部的函数有充足的时间执行**

可以看到，先打印了main，才打印了hello，（因为启动goroutine去执行hello需要一定时间

```go
package main

import (
	"fmt"
	"time"
)

func hello() {
	fmt.Println("this is hello func")
}

func main() {
	go hello()
	fmt.Println("this is main func")
	time.Sleep(time.Second)
}
$  go run main.go
this is main func
this is hello func
```



## 启动多个goroutine

发现，每次执行结果不一样，因为多个goroutine并发执行，每次的调度顺序都一定完全一样，所以打印10个数字的顺序几乎每次不同

```go
package main

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func hello(a int) {
	// 注册一个操作，函数退出前，记得关闭goroutine，wg.Add加了几个，往往就需要关闭几个
	defer wg.Done()
	fmt.Println(a)
}

func main() {

	for i := 0; i < 10; i++ {
		// 每循环一次启动一个goroutine
		// 启动goroutine前，先注册，利用wg.Add()方法
		wg.Add(1)
		go hello(i)

	}

	// 等待所有goroutine结束，每wg.Done()一次，就会把wg.Add()减1，直到减到0，此时代表所有goroutine都完成工作，若下方还有代码，才可以继续执行
	wg.Wait()
    fmt.Println("10 goroutine done!")
}

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/18goroutine (master)
$  go run main.go
9
5
7
4
0
1
2
3
6
8
10 goroutine done!
latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/18goroutine (master)
$  go run main.go
9
0
3
1
2
4
6
7
8
5
10 goroutine done!
```



# goroutine与线程

## 可增长的栈

os的线程即操作系统的线程，一般都有固定的栈内存（通常是2MB，**而一个goroutine线程在其生命周期开始时，其栈大小通常只有2KB，**而且其栈大小可以根据需要动态的调整，其最大栈大小可以达到1GB，（因此go中一次型创建10万左右的goroutine也是可以的



## goroutine调度

goroutine是go运行时管理的用户态的线程，其本质还是要靠os的线程来实际运行，一个os线程对应多个用户态的goroutine，goroutine之间的调度切换，是在用户态完成，不需要用户态和内核态之间切换，（因此较为轻量）

**GPM就是实现goroutine调度的系统：**

- G就是值goroutine，里面存放了goroutine本身的信息，还有所在绑定P的信息
- P管理着一组goroutine，P里面会存储当前goroutine的上下文信息（函数指针、堆栈地址、地址边界）P会对自己管理的goroutine进行调度（比如将占用cpu时间长的goroutine暂停，运行后续的goroutine）当自己队列消费完了就去全局队列取，如果全局队列消费完了就是其他P的队列里抢任务
- M（machine）是go运行时对操作系统内核线程的虚拟，M和内核线程一般是一一对应的关系，**一个goroutine最终要放到M上执行的**

**P和M一般也是一一对应**，关系是：P管理着一组G，挂到一个M上，这组G都由这个M实际来负责运行，（即由这个M对应的cpu核心来执行？）当某个G阻塞到了M上，P就会新建一个M，并其组内其他G迁移到新的M上，而等到阻塞的G完成或者认为完成不了把它退出时，回收旧的M

P的个数是通过`runtime.GOMAXPROCS`设定，最大是256，go1.5版本后默认是物理线程数，并发量大的时候可以适当增加一些P和M，但加太多就得不偿失，因为底层就这么多cpu核心，加多了还不是得让cpu核心做上下文切换，反而拖慢了

单从线程调度来讲，go相比其他语言的优势是在于os线程是有内核调度，而go的goroutine是由go运行时调度，**调度器采用m:n调度，即把m的goroutine调度到n个os线程上，**全部在用户态，上下文切换的成本小，**不涉及内核态用户态的频繁切换，内存池由用户态维护，几乎是平均的把若干goroutine调度到多个cpu核心，充分利用了多核cpu硬件优势

**如下图示：**

（不一定对，先这么理解

![image-20210131093815623](https://gitee.com/boogie96/pic-go-bed/raw/master/img/image-20210131093815623.png)

[拓展阅读](https://www.cnblogs.com/sunsky303/p/9705727.html)



## GOMAXPROCS

go运行时可以通过GOMAXPROCS参数设定启用多少个os线程来运行go代码，默认值是机器的cpu核心数，例如一个8核心服务器，默认就是启用8个os线程，（m：n中的n是8）

通过runtime.GOMAXPROCE()函数可以设置当前程序并发时占用了cpu核心数

go1.5之前，默认用单核心，go1.5之后，默认使用全部的逻辑核心数

例1：2个goroutine只用一个核心

可以看到，先执行完b的goroutine之后，再执行的a的goroutine，（虽然一个核心，但也应该交叉调度运行，但因为10比较小，几乎不用调度，先执行一个，再执行后一个，实验中，10加到10000时，即便是单核心，也会交叉运行输出）

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

func a() {
	for i := 0; i < 10; i++ {
		fmt.Printf("this is func a %d\n", i)
	}

}

func b() {
	for i := 0; i < 10; i++ {
		fmt.Printf("this is func b %d\n", i)
	}

}

func main() {
	runtime.GOMAXPROCS(1)
	go a()
	go b()
	time.Sleep(time.Second * 2)

}

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/18goroutine (master)
$ go run main.go
this is func b 0
this is func b 1
this is func b 2
this is func b 3
this is func b 4
this is func b 5
this is func b 6
this is func b 7
this is func b 8
this is func b 9
this is func a 0
this is func a 1
this is func a 2
this is func a 3
this is func a 4
this is func a 5
this is func a 6
this is func a 7
this is func a 8
this is func a 9
```



例2: 2个goroutine用2个核心

可以看到，虽然10比较小，但是仍然是交叉输出，因为有2个核，可以同时跑a和b的goroutine

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

func a() {
	for i := 0; i < 10; i++ {
		fmt.Printf("this is func a %d\n", i)
	}

}

func b() {
	for i := 0; i < 10; i++ {
		fmt.Printf("this is func b %d\n", i)
	}

}

func main() {
	runtime.GOMAXPROCS(2)
	go a()
	go b()
	time.Sleep(time.Second * 2)

}

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/18goroutine (master)
$ go run main.go
this is func b 0
this is func b 1
this is func b 2
this is func a 0
this is func a 1
this is func a 2
this is func a 3
this is func a 4
this is func a 5
this is func a 6
this is func a 7
this is func a 8
this is func a 9
this is func b 3
this is func b 4
this is func b 5
this is func b 6
this is func b 7
this is func b 8
this is func b 9
```

**操作系统线程和goroutine的关系**

- goroutine和os线程是m：n的关系
- go程序可以同时刻，使用多个os线程，即多个cpu核心
- 一个os线程，对应多个用户态的goroutine

# channel

单纯的将函数并发执行并无意义，函数与函数之间，还需要进行通信，即数据交换，**go中利用channel实现并发函数之间的通信**

实现进程间通信的方法可以通过共享内存实现，**但是共享内存去通信，多个进程同时访问同一块内存的时候，会出现竞争，这时需要加锁，这就造成了性能上的低下，**

**而go中，提倡通过通信而共享内存，而不是通过共享内存实现通信：通过CSP（communicating sequential process)并发模型实现，通过channel，实现一个goroutine向另一个goroutine发送数据，channel就像是一个管道或者传递带，你在这头发，我在那头取**

channel遵从先进先出的规则，里面可以存储各种类型的数据

## channel类型

**channel的类型决定了它能传输什么样的数据**

channel是一种类型，一种引用类型，声明格式：

```go
var 变量名 chan 元素类型

// 例子
var ch1 chan int
var ch2 chan string
var ch3 chan []int

// 上面3个通道变量，分别用于传输 int string []int类型的数据
```





## 创建channel

channel是引用类型，所以其空值是nil

```go
package main

import "fmt"

func main() {
	var ch1 chan int
	fmt.Println(ch1) // 是nil
}

$ go run main.go
<nil>
```

只声明不行，还得用make初始化后才能使用

```go
// 语法： make(chan 通道内存放的数据类型 , [通道的缓冲区大小,可选])
	ch2 := make(chan int, 10)
	ch3 := make(chan string)
	ch4 := make(chan bool, 9)
```



## channel操作

**channel具有发送、接收、关闭三种操作，发送接收都用`<-`**表示

**先定义一个通道**

```go
ch := make(chan int)
```



**发送**

```go
ch <- 10 // 发送一个10
```

**接收**

```go
x := <- ch // 从ch中接收一个值，并赋值给x
<- ch // 从ch中接收一个值，并丢弃，即忽略
```

**关闭**

关闭通道就是相当于把通道的入口关闭了，但是出口没关

```go
close(ch) // 调用内置的close方法，关闭即可
```

**和文件操作不同的是，文件打开后必须关闭，而通道则不是必须关闭，其可以被垃圾回收机制回收**

**已经关闭通道的特点**

1. 入口关闭了，再向该通道内传值会引发panic
2. 出口没关闭，可以从该通道内继续接收值，直到通道内数据被取完，即通道变空
3. 从一个关闭的通道，且已经取完了数据的通道，继续接收值，不会panic，只是会收到对应类型的零值
4. 已经关闭的通道，再关闭一次，会引发panic

## 无缓冲的通道

**无缓冲的通道，又称为阻塞的通道**

例子：编译能通过，但是运行会爆出死锁

```go
package main

func main() {
	ch1 := make(chan int)

	ch1 <- 10
}

$ ./19channel.exe
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        D:/myCode/Go/src/learngo/basic_grammar/19channel/main.go:6 +0x57
```

上例的原因是：没有缓冲区的通道，发送值的时候，必须有一方在通道另一边接着，不然发送方就一直等，直到卡死，爆出死锁（好比小区没有快递柜，快递员送快递时，必须等你到了，把快递交到你手上）

解决上例子的问题：

```go
// 启用一个goroutine来从通道收值
package main

import (
	"fmt"
	"time"
)

func recv(c chan int) {
	ret := <-c
	fmt.Printf("接收成功：%d\n", ret)
}
func main() {
	ch1 := make(chan int)
	// 先启动一个goroutine，准备从ch1通道接收值，此时goroutine会等待一会，直到下面一行，向ch1中发送一个值，此时2个goroutine都可以正常通过执行
	go recv(ch1)
	ch1 <- 10
    // 要等一会，不然会来不及打印，接收成功这句，就退出了
	time.Sleep(time.Second)
	// fmt.Println("发送成功")
}

```

**使用无缓冲的通道进行通信，会使得通道2端的发送goroutine和接收goroutine同步化，因此无缓冲通道又被称为同步通道**



## 有缓冲的通道

有缓冲的通道，就是初始化时，给通道申请至少一个单位的空间，

有缓冲的通道也会阻塞，即通道中空间放满了数据，还没被取走，此时再放值就会阻塞

```go
package main

import "fmt"

func main() {
	ch1 := make(chan int, 1)
	ch1 <- 10
	fmt.Println(len(ch1))
	ret := <-ch1
	fmt.Println(ret)
	fmt.Println(len(ch1))
	fmt.Println(cap(ch1))
}
$ go run main.go
1
10
0
1
```

len可以获取通道内元素的数量，cap可以获取通道的总容量

## for range从通道循环取值

for range 从通道遍历值的时候，当遍历的通道关闭，就会自动退出for range

```go
package main

import "fmt"

func main() {
	// 声明2个无缓冲的通道
	ch1 := make(chan int)
	ch2 := make(chan int)

	// 开一个goroutine 一个匿名函数，作为立即执行函数，向ch1中放入1到10的值
	go func() {
		for i := 0; i <= 10; i++ {
			ch1 <- i
		}
		close(ch1)
	}()

	// 开一个goroutine 一个匿名函数，作为立即执行函数，从ch1中取出值，计算平方后，放入ch2
	go func() {
		for i := 0; i <= 10; i++ {
			ret, ok := <-ch1 // 当ch1关闭，再取值，返回的ok就是false
			if !ok {
				break
			}
			ch2 <- ret * ret
		}
		close(ch2)

	}()
	// 主函数的goroutine，从ch2中遍历取出值，并打印
    // 因为ch1和ch2都是无缓存的通道，close(ch2)能执行的条件就是，10个数的平方，都被放到ch2中，并随即被主goroutine打印出来，
    // 即无缓冲通道使得，这三个goroutine是同步的，ch1放一个，取出一个计算平方放到ch2，随即被打印，然后开始下一次循环
	for x := range ch2 {
		fmt.Println(x)
	}
}

```



## 单向通道

在函数中，经常需要将一个通道，作为传参，在多个功能函数内部使用，**为了安全考虑，可以定义将一个通道传递到一个函数中时，限制该函数内部可以对该通道执行的操作，**可以将通道定义为单向通道，即函数内部只能对这个通道进行只发或只收操作

改造上面的例子

```go
package main

import "fmt"

func send(ch chan<- int) {
	for i := 0; i < 10; i++ {
		ch <- i
	}
	close(ch)

}
func squarer(chSend chan<- int, chRecv <-chan int) {
	// 从chRecv取值，计算平方后，放入chSend

	for tmp := range chRecv {
		chSend <- tmp * tmp
	}
	close(chSend)
}

func print(ch <-chan int) {
	for x := range ch {
		fmt.Println(x)
	}
}
func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	go send(ch1)
	go squarer(ch2, ch1)
	print(ch2)
}
$ ./19channel.exe
0
1
4
9
16
25
36
49
64
81
```

- <-chan 只能从里读数据
- chan<- 只能向里写数据

函数传参的时候，双向通道可以改成单向通道，反之不可以

## 通道总结

![image-20210131140213685](https://gitee.com/boogie96/pic-go-bed/raw/master/img/image-20210131140213685.png)

**关闭一个已经关闭的通道会panic**

# worker pool(goroutine池)

工作中，常常利用worker  pool模式，即goroutine池，来限制goroutine的数量，防止goroutine的暴涨或泄漏

e.g.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// worker pool
var wg sync.WaitGroup

func worker(id int, ch1 <-chan int, ch2 chan<- int) {
	defer wg.Done()
	for j := range ch1 {
		fmt.Printf("worker:%d, do job:%d\n", id, j)
		// time.Sleep(time.Second)，这句放在前面，会导致放入ch2的数据不是1-5这个顺序，放到下面就是
		ch2 <- j * 2
        time.Sleep(time.Second)
	}
}

func main() {
	jobs := make(chan int, 10)
	results := make(chan int, 10)
	// 启动3个goroutine
	for i := 1; i <= 3; i++ {
		wg.Add(1)
		go worker(i, jobs, results)
	}

	// 向任务队列中，放入5个任务
	for i := 1; i <= 5; i++ {
		jobs <- i
	}
	close(jobs)

	wg.Wait()
	// for x := range results {
	// 	fmt.Println(x)
	// }
	for i := 1; i <= 5; i++ {
		res := <-results
		fmt.Println(res)
	}

}
// 运行结果：3个worker即3个goroutine分5个任务，本次运行中1和3各自执行了2个任务，2执行了1个任务
$ go run main.go
worker:3, do job:1
worker:1, do job:2
worker:2, do job:3
worker:1, do job:4
worker:3, do job:5
4
2
6
10
8
$ go run main.go
worker:3, do job:1
worker:1, do job:2
worker:2, do job:3
worker:3, do job:4
worker:2, do job:5
2
4
6
8
10
```



# select多路复用

当通道中没有值的时候，从通道中接收值会一直阻塞，直到通道中再次有值，对于同时从多个通道接收值的情况，可以采用如下循环：通过判断ok的值，确定是否继续接收

```go
for {
    v , ok := <- ch1
    	...
    v , ok := <- ch2
}
```

**但上述方式，性能较差，因此go提供了select关键字，可以同时响应多个通道的操作，收或发都可以**

**select类似于switch操作，有一系列case分支和一个默认分支：每个case分支都有对应一个通道的操作，收或发，当某个case分支的通道的收或发的操作满足时，就会执行该case下的语句，当多个case同时满足时，就随机选择一个case执行**

语法：

```go
select {
case <-ch1:
	...
case ch2<- data:
	...
case data := <-ch2:
	...
default
	默认操作
}    
```



e.g.

```go
package main

import (
	"fmt"
)

func main() {

	ch1 := make(chan int, 1)

	for i := 0; i < 10; i++ {
		select {
		case x := <-ch1:
			fmt.Println(x)
		case ch1 <- i:

		}
	}
}
$ go run main.go
0
2
4
6
8
```

select语句可以挺高代码的可读性

- 可以处理一个或多个channel的发送或接收操作
- 多个case同时满足，会随机选择一个
- 没有case的select{}会一直等待，可用于阻塞main函数



# 并发安全和锁

多个goroutine执行同一个函数，而函数中又涉及到了一个函数外部的变量，此时由于goroutine是并发执行，当多个goroutine操作同一个变量时，就一般会发生**数据竞争**，造成结果的不确定性

下例中，

```go
package main

import (
	"fmt"
	"sync"
)

var x int64
var wg sync.WaitGroup

func add() {
	defer wg.Done()
	for i := 0; i < 50000; i++ {
		x = x + 1
	}
	// 正常情况下，这个函数只有一个goroutine在执行时，x最后应该是50000
}
func main() {
	// wg.Add(1)
	wg.Add(2)
	go add()
	go add()
	wg.Wait()

	fmt.Println(x)
}

$ go run main.go
71142

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/19channel (master)
$ go run main.go
51122

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/19channel (master)
$ go run main.go
52482

latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/19channel (master)
$ go run main.go
52701

```



## 互斥锁

## 读写互斥锁

## sync.WaitGroup

## sync.Once

## sync.Once

## sync.Map

# 原子操作

## atomic包

## 示例

# 练习题


1. 使用goroutine和channel实现一个计算int64随机数各位数和的程序。
	1. 开启一个goroutine循环生成int64类型的随机数，发送到jobChan
	2. 开启24个goroutine从jobChan中取出随机数计算各位数的和，将结果发送到resultChan
	3. 主goroutine从resultChan取出结果并打印到终端输出
2. 为了保证业务代码的执行性能将之前写的日志库改写为异步记录日志方式。


