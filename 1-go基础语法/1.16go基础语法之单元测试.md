# go test工具

golang中的测试依赖go test命令，编写测试代码和编写普通的go代码是类似的，

go test命令是一个按照一定约定和组织测试代码的驱动程序，在包目录内部，所有以`_test.go`为后缀的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。

在`*_test.go`文件中，有三种类型的函数，单元测试函数、基准测试函数、和示例函数

| 类型     | 格式                  | 作用                           |
| -------- | --------------------- | ------------------------------ |
| 测试函数 | 函数名前缀为Test      | 测试程序的逻辑行为是否符合预期 |
| 基准函数 | 函数名前缀为Benchmark | 测试函数的性能                 |
| 示例函数 | 函数名前缀为Example   | 为文档提供示例                 |

**go test命令，会遍历所有的*_test.go文件中，符号上述命令规则的函数，然后生成一个临时的main包用于调用所有的测试函数，然后构建运行、报告测试结果、最后清理测试中生成的临时文件**



# 测试函数

## 测试函数的格式

每个测试函数必须导入`testing`包，测试函数的基本格式如下：

```go
func TestName(t *testing.T) {
	//...
}
```

测试函数的名字必须以Test开头，后缀名必须以大写字母开头，举例：

```go
func TestAdd(t *testing.T) { ...}
func TestSum(t *testing.T) { ...}
func TestLog(t *testing.T) { ...}
```

其中参数`t`用于报告测试失败和附加的日志信息，`testing.T`拥有的方法如下：

```go
func (c *T) Error(args ...interface{})
func (c *T) Erroff(format string, args ...interface{})
func (c *T) Fail()
func (c *T) FailNow()
func (c *T) Failed() bool
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})
func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})
func (c *T) Name() string
func (t *T) Parallel()
func (t *T) Run(name string, f func(t *T)) bool
func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
```



## 测试函数示例

一个完整的软件程序是由很多小的单元组件构造的，**单元组件可以是函数、结构体、方法等**，只有确保这些小的单元组件都正常运行，组成的完整软件程序，才有可能正常运行，因此拆分出来一个个小的组件，测试它们的功能，确保它们的功能符合预期，这就是单元测试

1、定义一个split包，包中包含一个split.go文件，其中实现了一个split函数，代码如下：

```go
package split

// split/split.go文件

import "strings"

// 函数功能：接收一个字符串s ，一个字符串sep，将s按照sep为分隔符，分割为一个个子字符串，并以字符串切片的形式返回
// 示例： abcbdebh，应该切成a c de h
func Split(s, sep string) (result []string) {
	// 求出sep在s中第一次出现的下标，
	i := strings.Index(s, sep)

	for i > -1 {
		result = append(result, s[:i])
		s = s[i+1:]
		i = strings.Index(s, sep)
	}
	// 最后一部分不包含分隔符sep的追加到result切片中,然后返回
	result = append(result, s)
	return
}

```

2、在同目录下创建一个split_test.go文件，并定义一个测试函数如下

```go
package split

import (
	"reflect"
	"testing"
)

// 函数定义为标准格式，Test后加上要测试的函数名，并首字母大写即可
func TestSplit(t *testing.T) {
	got := Split("a:b:c", ":")      // 实际运行函数 并把运行的结果赋值给got
	want := []string{"a", "b", "c"} // 预期的函数运行结果

	if !reflect.DeepEqual(want, got) { // 切片不能直接比较，借助反射包中提供的方法比较2个字符串切片
		t.Errorf("expected: %v, but got :%v\n", want, got)
		// 如果测试失败，则打印上面的提示
	}
}
```

3、在split包的目录下，执行`go test`命令，输出结果如下

```
ten@DESKTOP-7ICOPRG MINGW64 /c/myworkstation/mygocode/src/learngo/basic_grammar/23unit_test/split (master)

$ ls -l
total 2
-rw-r--r-- 1 ten 197121 621  2月  3 17:00 split.go
-rw-r--r-- 1 ten 197121 580  2月  3 17:06 split_test.go

$ go test
PASS
ok      learngo/basic_grammar/23unit_test/split 0.163s
```

4、在split_test.go文件中再添加一个测试用例函数，如下

```go
// 测试分隔符为字符串而不是单个字符的测试函数
func TestSplitMultixString(t *testing.T) {
	got := Split("abcd", "bc")
	want := []string{"a", "d"}
	if !reflect.DeepEqual(want, got) {
		t.Errorf("expected: %v, got: %v \n", want, got)
	}
}
```

5、再次执行`go test`命令，输出如下，可以看到测试用例失败，使用`go test -v`查看详细的测试函数执行信息

```
$ go test
--- FAIL: TestSplitMultixString (0.00s)
    split_test.go:24: expected: [a d], got: [a cd]
FAIL
exit status 1
FAIL    learngo/basic_grammar/23unit_test/split 0.064s
```

6、跟据上面输出可以看到添加的测试用例函数，没有通过用例，原因为实现的split函数没有考虑到分隔符为多个字母的情况，改进split函数如下：

```go

```

7、再执行测试`go test`，可以发现2个测试用例都通过了，测试结果如下：

```go

```

8、`go test -v -run="一个正则表达式"，可以利用正则匹配特定的测试函数进行测试，而不是执行全部的测试函数

ps，修改代码后，应该执行全部的测试函数，确保都能通过，避免修改代码后引入新的问题

## 测试组

## 子测试

## 测试覆盖率

# 基准测试

## 基准测试函数格式

##　基准测试函数示例

## 性能比较函数

## 重置时间

## 并行测试

# Setup和TearDown

## TestMain

## 子测试的Setup和Teardown

# 示例函数

## 示例函数的格式

## 示例函数示例

# 练习题



