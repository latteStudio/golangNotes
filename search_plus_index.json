{"./":{"url":"./","title":"Introduction","keywords":"","body":"本书用于记录golang的学习笔记 latteplus            updated 2021-02-15 10:40:45 "},"0-go开发环境准备/0.1go开发环境搭建.html":{"url":"0-go开发环境准备/0.1go开发环境搭建.html","title":"0.1go开发环境搭建","keywords":"","body":"1. windows平台go开发环境搭建1.1. 安装go1.14.13版本1.2. GOROOT与GOPATH1.3. 设置GOPROXY1.4. 查看go 环境变量2. go开发IDE2.1. 安装vscode2.2. 安装中文扩展2.3. 安装go扩展3. 第一个go程序3.1. go的项目结构3.1.1. 个人项目结构3.1.2. 公司/组织项目结构3.2. 文本编辑器写helloworld3.3. vscode中写helloworld3.3.1. 切换vscode的默认终端3.4. go install作用3.5. 跨平台编译4. vscode再配置4.1. 配置GOPROXY4.2. 安装go开发工具包4.3. 配置vscode自动保存4.4. 配置vscode代码片段快捷键1. windows平台go开发环境搭建 1.1. 安装go1.14.13版本 下载go安装包：windows平台；https://golang.google.cn/dl/ 下一步安装即可； 选择一个安装路径； 安装过程中会自动添加GOPATH环境变量（但后面要删除并自定义） 查看go版本 1.2. GOROOT与GOPATH GOROOT： go的安装路径，如上面安装到的d:\\workstation\\mysoftware\\go\\就是GOROOT 类似于JAVA_HOME GOROOT下的bin目录要加到环境变量，方便在任何路径执行其下命令； GOPATH：（go1.11版本后，不强制要求gopath了，利用go module，可以将go源代码放在任何位置） 是将来存放写的go源代码的位置，需要自定义， 并在其下面创建3个子目录：pkg bin src，其中src是存放源代码的目录 创建GOPATH目录，以及3个子目录 bin是自己代码编译后的二进制文件； pkg是编译后的归档文件； src是源码文件； 配置GOPATH到全局系统变量中； 将2个bin目录，配置到全局的系统变量PATH中；一个是go开发包的bin目录，包括一些编译工具等；一个是自己将来编译后的二进制程序，都需要配置到PATH中，方便执行命令时找到相应程序； 1.3. 设置GOPROXY 默认的GOPROXY地址：GOPROXY=https://proxy.golang.org,direct ，国内的地址可以更换为goproxy.cn，goproxy.io C:\\Users\\ten>go env -w GOPROXY=https://goproxy.cn,direct 1.4. 查看go 环境变量 C:\\Users\\ten>go env 输入go env即可 set GO111MODULE= set GOARCH=amd64 set GOBIN= set GOCACHE=C:\\Users\\ten\\AppData\\Local\\go-build set GOENV=C:\\Users\\ten\\AppData\\Roaming\\go\\env set GOEXE=.exe set GOFLAGS= set GOHOSTARCH=amd64 set GOHOSTOS=windows set GOINSECURE= set GONOPROXY= set GONOSUMDB= set GOOS=windows set GOPATH=D:\\workstation\\mycode\\gocode set GOPRIVATE= set GOPROXY=https://goproxy.cn,direct set GOROOT=D:\\workstation\\mysoftware\\go set GOSUMDB=sum.golang.org set GOTMPDIR= set GOTOOLDIR=D:\\workstation\\mysoftware\\go\\pkg\\tool\\windows_amd64 set GCCGO=gccgo set AR=ar set CC=gcc set CXX=g++ set CGO_ENABLED=1 set GOMOD= set CGO_CFLAGS=-g -O2 set CGO_CPPFLAGS= set CGO_CXXFLAGS=-g -O2 set CGO_FFLAGS=-g -O2 set CGO_LDFLAGS=-g -O2 set PKG_CONFIG=pkg-config set GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\ten\\AppData\\Local\\Temp\\go-build519974818=/tmp/go-build -gno-record-gcc-switches 2. go开发IDE ​ vscode加go插件，或jetbrains的Goland，这里采用vscode加相应插件； 2.1. 安装vscode https://code.visualstudio.com/Download 找到对应操作系统的安装包，这里是windows平台的，下一步安装法直接安装即可； 2.2. 安装中文扩展 2.3. 安装go扩展 ​ 在扩展中，所在Chinese和go，安装扩展，然后重启vscode即可； 3. 第一个go程序 3.1. go的项目结构 ​ go语言开发时： 源代码保存在$GOPATH/src目录下； go build编译、go install编译加移动、go get命令后； go get下载的第三方源码包放在$GOPATH/src目录下； 产生的二进制可执行文件在$GOPATH/bin目录下； 生成的中间文件在$GOPATH/pkg目录下； 使用vcs如git管理项目时，只需要将$GOPATH/src目录下的源代码添加到git中管理即可；bin和pkg目录下不需要； 3.1.1. 个人项目结构 大体的项目结构： 在src目录下，分项目，项目下分模块存放源代码； 较为流行的项目结构： ​ go通过引用包，组织代码文件，通常使用公司或个人的顶级域名做代码包的前缀，防止冲突；没有个人域名可以用github.com用户名充当包前缀 示例： ​ wang和li在github上有studygo的项目，那么其包路径分别是： import \"github.com/wang/studygo\" import \"github.com/li/studygo\" 下载github上的包 go get github.com/jmoiron/sqlx 下载的包会到GOPATH路径下的src的路径， 具体为：src/github.com/jmoiron/sqlx 3.1.2. 公司/组织项目结构 3.2. 文本编辑器写helloworld 进入到GOPATH路径的src目录下； 新建一个hello目录； 在hello目录新建一个main.go; package main import \"fmt\" func main(){ fmt.Println(\"hello world\") } 在路径框中，输入cmd，然后回车，即在该路径下打开cmd窗口； go build编译刚刚的main.go程序，默认生成与文件夹同名的exe文件； -o选项指定编译后的exe文件名； 在非当前目录编译：（其他路径执行go build + 源码目录名，go会自动在GOPATH的src目录下，找到对应的源码目录名执行编译，编译后的exe文件在当前执行命令的路径） 如下例子：会去src目录下找到hello目录，然后编译，生成的exe文件在当前d盘路径下； 3.3. vscode中写helloworld 3.3.1. 切换vscode的默认终端 如图：打开一个终端，并在长方框选择cmd，然后重启vscode即可； 3.4. go install作用 ​ go install分为2步： 先编译为可执行文件； 然后将可执行文件移动到GOPATH的bin目录下； 因GOPATH下的bin在环境变量中，此后，可在任意路径下执行编译后的可执行文件； 3.5. 跨平台编译 ​ 默认情况下：go build编译后的可执行文件都是当前开发机的操作系统可执行的文件，一般需要在windows平台开发，编译出在linux服务器上执行的可执行文件； 指定目标操作系统和处理器架构； D:\\workstation\\mycode\\gocode\\src\\hello>set CGO_ENABLED=0 禁用cgo，使用了cgo的代码，不支持跨平台编译； D:\\workstation\\mycode\\gocode\\src\\hello>SET GOOS=linux D:\\workstation\\mycode\\gocode\\src\\hello>SET GOARCH=amd64 编译即可 D:\\workstation\\mycode\\gocode\\src\\hello>go build 执行测试，成功；将编译后的二进制文件上传到linux系统中，加入执行权限； 跨平台编译示例： mac下编译linux或windows的64位可执行程序； CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build linux下编译mac或windows的64位可执行程序； CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENALBED=0 GOOS=windows GOARCH=amd64 go build windows下编译mac的64位可执行程序； SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build 4. vscode再配置 4.1. 配置GOPROXY ​ 在vscode的cmd的终端中，输入一下命令，设置GOPROXY go env -w GOPROXY=https://goproxy.cn,direct 4.2. 安装go开发工具包 1、windows系统按ctrl shift p，弹出窗口，并在其中搜索：go:install/update tools一项； （注意，如果搜索不到，看下go扩展是不是没装； 2、点击之后，在弹出的如下列表中，选中全部，点击确定，开始安装工具包； 3、安装成功的提示： 4.3. 配置vscode自动保存 文件-》首选项-》设置，选中afterdelay 4.4. 配置vscode代码片段快捷键 windows系统按ctrl shift p，弹出创建输入snippets 然后在弹出的列表中，选择go点击，弹出的go.json配置文件，按需将需要的快捷键定义其中，保存即可； 2个快捷键配置示例： { // Place your snippets for go here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \"Print to console\": { // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // } \"println\":{ \"prefix\": \"pln\", \"body\":\"fmt.Println($0)\", \"description\": \"println\" }, \"printf\":{ \"prefix\": \"plf\", \"body\": \"fmt.Printf(\\\"$0\\\")\", \"description\": \"printf\" } } 测试补全快捷键： 新建一个main.go文件，pln和plf会自动补全为完全的语句； latteplus            updated 2021-02-15 10:40:45 "},"0-go开发环境准备/0.2go依赖管理与go-module使用.html":{"url":"0-go开发环境准备/0.2go依赖管理与go-module使用.html","title":"0.2go依赖管理与go-module使用","keywords":"","body":"1. go依赖管理1.1. 为什么需要依赖管理1.2. godep1.2.1. 安装1.2.2. 基础命令1.2.3. godep使用1.2.4. vender机制1.2.5. godep开发流程1.3. go_module1.3.1. go111module1.3.2. goproxy1.3.3. go mod命令1.3.4. go.mod1.3.5. go get1.3.6. 整理依赖1.3.7. go mod edit1.4. 在项目中使用go module1.4.1. 既有项目1.4.2. 新项目2. go module导入本地包2.1. 同一个项目下2.2. 不同项目下2.3. main.go文件；引入了fmt和mypackage包，然后在main函数中输出；2.4. go.mod文件；由于mypackage在本地，没有发布到远程的代码仓库，且不在moduledemo2的子目录，因此采用require指令引用，replace指令指明路径；3. 参考链接1. go依赖管理 1.1. 为什么需要依赖管理 ​ 最初：go依赖的第三库都在GOPATH的目录下，会导致同一个库只能保存一个版本的代码，如果不同项目依赖同一个第三库的不同版本，如何解决？ 1.2. godep ​ go从1.5版本开始引入vener模式，如项目目录下有vender目录，那么go会优先使用vender内的包进行编译测试； ​ godep是通过vender模式实现的go语言的第三方依赖管理工具，类似的有社区维护的包管理工具dep； 1.2.1. 安装 ​ 在命令行中安装godep工具； 1.2.2. 基础命令 C:\\Users\\ten>godep Godep is a tool for managing Go package dependencies. Usage: godep command [arguments] The commands are: save list and copy dependencies into Godeps go run the go tool with saved dependencies get download and install packages with specified dependencies path print GOPATH for dependency code restore check out listed dependency versions in GOPATH update update selected packages or the go version diff shows the diff between current and previously saved set of dependencies version show version info Use \"godep help [command]\" for more information about a command. 1.2.3. godep使用 cmd切换其他盘符的命令：加个/d C:\\ISOs>cd /d D:\\workstation\\mycode\\gocode\\src\\hello2 在项目源码目录执行dodep save； D:\\workstation\\mycode\\gocode\\src\\hello2>godep save D:\\workstation\\mycode\\gocode\\src\\hello2> 之后，会在项目目录下生成Godeps和vender目录； Godeps目录下有Godeps.json文件，记录了项目依赖的包信息；vender下是项目依赖包的源码文件； 1.2.4. vender机制 ​ go1.5后开始支持，控制了go编译时依赖包搜索路径的优先级； ​ 例如：查看某项目依赖包时，会先在项目根目录下的vender查看，没有就去就$GOPATH/src目录下找； 1.2.5. godep开发流程 保证程序正常编译； 执行godep save保存当前项目的所有第三方依赖的版本信息和源码； 提交Godeps目录和vender目录到代码库； 更新依赖包版本时，修改Godeps.json中对应项即可； 1.3. go_module ​ go1.11后推出的版本管理工具，1.13版本会成为默认管理工具； 1.3.1. go111module 启用go module先设置环境变量GO111MODULE，其有三个值： off：禁用go module，编译时从GOPATH和vender下找包； on；启用go module，编译时忽略GOPATH和vender，只根据go.mod下载依赖； auto-默认值：当项目在$GOPATH/src外且项目根目录有go.mod文件时，开始go module模块支持； 设置GO111MODULE=on后，即可使用go module管理依赖，不必非要在GOPATH中创建项目，使用go module管理依赖后，会再项目根目录生成go.mod和go.sum文件； 1.3.2. goproxy unix: export GOPROXY=https://goproxy.cn windows: go env -w GOPROXY=https://goproxy.cn,direct 1.3.3. go mod命令 D:\\workstation\\mycode\\gocode\\src\\hello2>go mod Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just 'go mod'. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using 'go get'. See 'go help modules' for an overview of module functionality. Usage: go mod [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \"go help mod \" for more information about a command. 1.3.4. go.mod go.mod文件记录了项目依赖的所有依赖信息，结构如下： module github.com/Q1mi/studygo/blogger go 1.12 require ( github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586 github.com/gin-gonic/gin v1.4.0 github.com/go-sql-driver/mysql v1.4.1 github.com/jmoiron/sqlx v1.2.0 github.com/satori/go.uuid v1.2.0 google.golang.org/appengine v1.6.1 // indirect ) module定义包名； require定义依赖包和其版本； indirect表示间接引用； 依赖包的版本表示法： 支持版本号：go get foo@v1.2.3 支持git分支或tag：go get foo@master 支持git提交哈希：go get foo@e3702bed2 gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 gopkg.in/vmihailenco/msgpack.v2 v2.9.1 gopkg.in/yaml.v2 replace: golang.org/x下的包无法访问，因此可以用go.mod中的replace替换为github上对应的库； replace ( golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac => github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac golang.org/x/net v0.0.0-20180821023952-922f4815f713 => github.com/golang/net v0.0.0-20180826012351-8a410e7b638d golang.org/x/text v0.3.0 => github.com/golang/text v0.3.0 ) 1.3.5. go get go get命令用来下载依赖包，可指定版本； go get -u会升级最新的次要版本或修定版本（x.y.z，z是修订版本号，y是次要版本号） go get -u=patch会升级到最新修订版 go get package@version会升级到指定版本 go mod download下载所有依赖 1.3.6. 整理依赖 代码中删除依赖代码后，相关依赖库不会在go.mod中自动移除，使用go mod tidy命令可更新go.mod中依赖关系； 1.3.7. go mod edit 格式化go.mod文件 go mod edit -fmt 添加依赖项： go mod edit -require=golang.org/x/text 移除依赖项： go mod edit -droprequire=golang.org/x/text 移除一个依赖 1.4. 在项目中使用go module 1.4.1. 既有项目 对一个已经存在的项目启用go module 项目目录下执行go mod init，生成go.mod文件 执行go get，查找当前项目依赖，并生成一个go.sum记录每个依赖库的版本和哈希值 1.4.2. 新项目 创建一个新创建项目并启用go module go mod init “项目名”，在当前项目目录下生成go.mod文件 手动编辑go.mod中的require依赖，或执行go get自动发现，解决依赖； 2. go module导入本地包 go module是go1.11后官方推出的版本管理工具，go1.13后成为默认的依赖管理工具； 2.1. 同一个项目下 目录结构如下：在GOPATH目录的src目录下新建一个moduledemo目录； moduledemo ├── go.mod ├── main.go └── mypackage └── mypackage.go vscode新建一个项目文件夹；在src目录下 准备mypackage/mypackage.go 定义了一个new方法，其功能就是输出一行mypackage.New； package mypackage import \"fmt\" func New(){ fmt.Println(\"mypackage.New\") } 初始化go.mod文件 D:\\workstation\\mycode\\gocode\\src\\moduledemo>go mod init go: creating new go.mod: module moduledemo 编辑main.go import了fmt和module/mypackage包，并在main中调用了2个方法； package main import ( \"fmt\" \"moduledemo/mypackage\" ) func main(){ mypackage.New() fmt.Println(\"main\") } 编译当前项目 D:\\workstation\\mycode\\gocode\\src\\moduledemo>go build 运行测试：成功编译，并执行； D:\\workstation\\mycode\\gocode\\src\\moduledemo>moduledemo.exe mypackage.New main 2.2. 不同项目下 目录结构如下：2个项目下，都有go mod init初始化一个go.mod文件 ├── moduledemo2 │ ├── go.mod │ └── main.go └── mypackage ├── go.mod └── mypackage.go 在GOPATH的src目录分别创建2个项目目录 moduledemo2的文件内容 ``` 2.3. main.go文件；引入了fmt和mypackage包，然后在main函数中输出； package main import ( \"fmt\" \"mypackage\" ) func main() { mypackage.New() fmt.Println(\"main\") } 2.4. go.mod文件；由于mypackage在本地，没有发布到远程的代码仓库，且不在moduledemo2的子目录，因此采用require指令引用，replace指令指明路径； module moduledemo2 go 1.14 require \"mypackage\" v0.0.0 replace \"mypackage\" => \"../mypackage\" 4. mypackage的文件内容 package.go内容；定义了一个方法New()，可以输出一句话 package mypackage import \"fmt\" func New(){ fmt.Println(\"mypackage.New\") } go.mod文件 module mypackage go 1.14 5. 在moduledemo2下编译 D:\\workstation\\mycode\\gocode\\src\\moduledemo2>go build D:\\workstation\\mycode\\gocode\\src\\moduledemo2>moduledemo2.exe mypackage.New main **不同项目的示例2：** 1. 2个项目的目录结构 ├── p1 │ ├── go.mod │ └── main.go └── p2 ├── go.mod └── p2.go ![image-20201225150609672](https://gitee.com/boogie96/img/raw/master/img/image-20201225150609672.png) 2. 定义p2项目 1. 定义p2的go.mod module github.com/ice-latte/p2 // 定义这个模块的名字，以github.com做顶级域名，可上传到github；引用名字就是该“github.com/ice-latte/p2” go 1.14 ``` 定义p2的方法 package p2 // p2定义了一个方法输出一行文本，可被其他项目引用 import \"fmt\" func New(){ fmt.Println(\"this is p2 new func\") } 定义p1项目 定义p1的go.mod，引用了p2这个module module p1 // 定义这个模块的名字叫p1，也可以github.com/用户名做前缀，然后上传到github go 1.14 require \"github.com/ice-latte/p2\" v0.0.0 // 定义依赖模块，模块名是github.com/ice-latte/p2，版本v0.0.0 replace \"github.com/ice-latte/p2\" => \"../p2\" // 因p2模块并未上传到github上，还在本地，需要用replace执向其在本地的路径； 定义p1的主函数，main方法中输出2个语句 package main import ( // 引用了2个模块 \"fmt\" \"github.com/ice-latte/p2\" // 该模块指向了本地的p2项目； ) func main(){ p2.New() // 调用了p2的new方法， fmt.Println(\"this is p1 main\") // 调用了fmt的Println方法 } 3. 参考链接 官方文档关于go module基本使用 中文翻译版 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.10go基础语法之结构体.html":{"url":"1-go基础语法/1.10go基础语法之结构体.html","title":"1.10go基础语法之结构体","keywords":"","body":"1. 类型别名和自定义类型1.1. 自定义类型1.2. 类型别名1.3. 类型定义和类型别名的区别2. 结构体2.1. 结构体定义2.2. 结构体实例化2.2.1. 基本实例化2.2.2. 匿名结构体2.2.3. 指针类型结构体2.2.4. 取结构体地址的方式进行实例化2.3. 结构体初始化2.3.1. 键值对初始化2.3.2. 值列表初始化2.4. 结构体内存布局2.4.1. 空结构体2.5. 面试题2.6. 构造函数2.7. 方法和接收者2.7.1. 指针类型接收者2.7.2. 值类型接收者2.7.3. 使用指针类型接收者的时机2.8. 任意类型添加方法2.9. 结构体的匿名字段2.10. 嵌套结构体2.10.1. 嵌套匿名字段2.10.2. 嵌套结构体的字段名冲突2.11. 结构体“继承”2.12. 结构体字段的可见性2.13. 结构体与Json序列化2.14. 结构体标签tag2.15. 结构体与方法（补充3. 练习题3.1. 思路分析3.2. 解法3.3. 运行效果3.4. 可以改进的地方1. 类型别名和自定义类型 golang中，没有“类”的概念，也不支持类的继承等面向对象的概念；go中通过结构体的内嵌再配合接口，实现比面向对象具有更高扩展性和灵活性 1.1. 自定义类型 go中有内置的基本数据类型，string、int、float、bool等，用户也可以通过type关键字定义用户自己需要的类型，一般是基于基本数据类型的组合 e.g. type myInt int // 定义了自定义类型，myInt，它和int的特性一模一样 1.2. 类型别名 go1.9添加的新功能，只是给同一种数据类型，起了不同的名字，本质还是同一种数据类型， rune和byte就是go内置的类型别名，目的是为了给要存储的数据类型一个更形象的名字 和自定义类型不同的是，需要加等号= type byte = uint8 type rune = int32 1.3. 类型定义和类型别名的区别 如下输出说明，自定义类型编译后，真的会有该类型如main.netInt，而类型别名编译后不存在，其类型为该类型的本名如int package main import \"fmt\" type aliasInt = int type newInt int // 类型别名和自定义类型的区别 func main() { var a aliasInt var b newInt fmt.Printf(\"type of a:%T\\n\", a) fmt.Printf(\"type of b :%T\\n\", b) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go type of a:int type of b :main.newInt 2. 结构体 go语言中，通过struct结构体来表示现实世界中的对象，结构体通过封装多个基本数据类型来表示一个对象 2.1. 结构体定义 结构体本质就是一组数据的聚会型数据 package main import \"fmt\" /* // 语法 type 类型名 struct { 字段名 类型 字段名 类型 ... } 类型名，自定义结构体的名字，需要一个包内部，唯一 字段名，结构体内部的字段名，该结构体内部，唯一 类型，字段的类型，可以是基本数据类型，也可以嵌套其他的结构体 */ // 使用type和struct关键字定义结构体 type person struct { name string city string age int8 } // 同样类型的字段，可以写到一行 type person struct { name, city string age int8 } 2.2. 结构体实例化 2.2.1. 基本实例化 package main import \"fmt\" // 基本实例化 type person struct { name string city string age int8 } func main() { var p1 person p1.name = \"wang\" p1.city = \"shanghai\" p1.age = 18 fmt.Printf(\"p1=%v\\n\", p1) fmt.Printf(\"p1=%#v\\n\", p1) // #v输出了其类型,main包里的person类型 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go p1={wang shanghai 18} p1=main.person{name:\"wang\", city:\"shanghai\", age:18} 通过结构体实例.字段名，操作其中某个字段的数据 2.2.2. 匿名结构体 package main import \"fmt\" // 匿名结构体 // 定义临时数据结构时，可以使用匿名结构体 func main() { var user struct { name string age int } user.name = \"wang\" user.age = 18 fmt.Printf(\"%T\\n\", user) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go struct { name string; age int } 打印出类型时，没有其名字，为匿名 2.2.3. 指针类型结构体 利用new函数，传入结构体类型，可以获得该结构体类型的指针，即结构体指针变量： package main import \"fmt\" type person struct { name string age int8 shuai bool } func main() { var p1 = new(person) // p1 是一个指针变量，且是person这个结构体的指针变量，存储的地址指向的是一个可以存放person这种结构体数据的内存地址 fmt.Printf(\"type of p1 : %T\\n\", p1) fmt.Printf(\"%#v\\n\", p1) fmt.Println(p1) // p1指向的内存地址，默认是该类型的“零”值，即其组成的各个基本数据类型的“零值\" // golang中，可以通过结构体的指针操作，其中各个字段的数据，go的语法糖 p1.name = \"wang\" p1.age = 18 p1.shuai = true fmt.Println(p1) fmt.Println(*p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go type of p1 : *main.person &main.person{name:\"\", age:0, shuai:false} &{ 0 false}空字符串 0 和false &{wang 18 true} {wang 18 true} 2.2.4. 取结构体地址的方式进行实例化 使用&对结构体进行取地址操作，相当于对该结构体类型，进行了一次new实例化操作； package main import \"fmt\" type person struct { name string age int8 shuai bool } func main() { p1 := &person{} fmt.Printf(\"type of p1: %T\\n\", p1) fmt.Println(p1) p1.name = \"wang\" (*p1).age = 24 p1.shuai = true fmt.Println(p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go type of p1: *main.person &{ 0 false} &{wang 24 true} (*p1).age 和p1.age 是等效的，后者为语法糖 2.3. 结构体初始化 没有初始化的结构体，其值，为各个字段默认的零值的组合 package main import \"fmt\" type person struct { name string age int8 shuai bool } func main() { var p1 person fmt.Printf(\"%p\\n\", &p1) // 已经分配内存了？因为能打印出内存地址 fmt.Println(&p1) fmt.Println(p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 0xc0000044a0 &{ 0 false} { 0 false} 2.3.1. 键值对初始化 示例： 注意：键值对的每一行都有逗号，注意冒号不要丢 package main import \"fmt\" type person struct { name string age int8 shuai bool } func main() { // 对结构体变量p1，进行键值对初始化， p1 := person{ name: \"wang\", age: 18, shuai: true, } fmt.Printf(\"%#v\\n\", p1) // 对结构体变量的指针，进行键值对初始化， p2 := &person{ name: \"haha\", age: 19, shuai: true, } fmt.Printf(\"%#v\\n\", p2) // 只初始化部分字段，其他字段为该类型的零值 p3 := person{ name: \"xixi\", } fmt.Printf(\"%#v\\n\", p3) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go main.person{name:\"wang\", age:18, shuai:true} &main.person{name:\"haha\", age:19, shuai:true} main.person{name:\"xixi\", age:0, shuai:false} 2.3.2. 值列表初始化 和键值对不同的是，值列表初始化，只写值，不写字段，有几个要求： 所有填入值，要和定义结构体是顺序对应； 所有字段必须都有一个值，不能漏； 不可以和键值对，形式混用； 2.4. 结构体内存布局 结构体的各个字段在内存中是连续存储的 package main import \"fmt\" // 结构体内存布局，测试 type myStruct struct { a int8 b int8 c int8 d int8 } func main() { s1 := myStruct{ 1, 2, 3, 4, } // 注意逗号要加 fmt.Printf(\"%p\\n\", &(s1.a)) fmt.Printf(\"%p\\n\", &s1.b) fmt.Printf(\"%p\\n\", &s1.c) fmt.Printf(\"%p\\n\", &s1.d) // 取地址时，加括号，不加都行 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 0xc0000140b0 0xc0000140b1 0xc0000140b2 0xc0000140b3 // 可以看到，内存地址依次加1，即8个bit，一个字节，即一个int8的大小，而定义的四个字段都是int8，证明了结构体内存是连续的。 结构体内存对齐博客 2.4.1. 空结构体 空结构体不占用内存 package main import ( \"fmt\" \"unsafe\" ) // 空结构体 func main() { var v struct{} fmt.Println(unsafe.Sizeof(v)) // 0 // 打印其大小，应该是0 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 0 2.5. 面试题 下面代码的输出结果是什么 package main import ( \"fmt\" ) type student struct { name string age int } func main() { m := make(map[string]*student) stus := []student{ {name: \"小王子\", age: 18}, {name: \"娜扎\", age: 23}, {name: \"大王八\", age: 9000}, } // 切片，切片里的每个元素都是一个map for _, stu := range stus { m[stu.name] = &stu }// 遍历切片，构造了一个name为key，对应元素的内存地址为value的map for k, v := range m { fmt.Println(k, \"=>\", v.name) fmt.Println(k, \"=>\", (*v).name) }// 遍历map，取出其k和v.name 都是name，元素的名字字段，v.name 等价于*v.name，是语法糖 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 大王八 => 大王八 大王八 => 大王八 小王子 => 大王八 小王子 => 大王八 娜扎 => 大王八 娜扎 => 大王八 2.6. 构造函数 go本身没有构造函数，但借助结构体，用户可以自定义构造函数给结构体，结构体字段较为复杂，字段较多时，调用构造函数返回的如果是值类型，则内存的拷贝开销较大，因此可以采用返回结构体的指针，如下： package main import ( \"fmt\" ) type person struct { name string city string age int } func newPerson(name, city string, age int) *person { return &person{ name: name, city: city, age: age, } } // 是person结构体的构造函数，调用它，得到一个实例化后结构体的指针，（可以值传递，也可以指针传递，需要修改同一份数据，或结构体字段较多时，一般采用指针传递） func main() { aPerson := newPerson(\"wang\", \"shanghai\", 18) fmt.Printf(\"type of aPerson: %T\\n\", aPerson) // 得到的aPerson其类型是：结构体指针， fmt.Printf(\"%#v\\n\", aPerson) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go type of aPerson: *main.person &main.person{name:\"wang\", city:\"shanghai\", age:18} 2.7. 方法和接收者 go中的方法method，表示的是某类对应所具备的功能，类似于java中类的方法，其定义格式为函数（但是是作用在特定数据类型上的函数，）即只有特定的数据类型的实例，可以使用该函数，该数据类型称为接收者，该函数称为该接收者的方法 定义格式： func (接收者变量 接收者类型) 方法名/函数名(传参列表) (返回值列表) { 函数体 } 其中： 接收者变量一般为接收者类型的首字母小写，如定义person类型的方法，接收者变量就定义为为p；（类比其他语言中的this，或self 方法名后面的定义和普通函数的定义格式一致； 接收者类型可以是：某数据类型的值，也可以是其指针，如person或*person 示例： package main import ( \"fmt\" ) type person struct { name string age int } func newPerson(name string, age int) *person { return &person{ name: name, age: age, } } // 给person类型，定义一个构造函数，返回的是该数据类型的一个数据实例的内存地址，即指针 func (p person) Dream() { fmt.Printf(\"%s has a dream\\n\", p.name) } // 定义person类型的一个方法Dream()，任何person数据类型的实例，都可以调用该方法，其他类型的数据则不可以调用该方法 func main() { p1 := newPerson(\"wang\", 18) p1.Dream() // 实例化一个person为p1，然后调用其方法Dream() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go wang has a dream 方法和函数区别，方法属于特定的数据类型，而函数不属于特定数据类型 2.7.1. 指针类型接收者 采用指针类型的接收者，调用方法时，传递的是数据的指针，即内存地址，这边方法中对数据做的修改在退出方法时仍然有效； package main import ( \"fmt\" ) type person struct { name string age int } func newPerson(name string, age int) *person { return &person{ name: name, age: age, } } // 给person类型，定义一个构造函数，返回的是该数据类型的一个数据实例的内存地址，即指针 // 指针类型接收者，的方法 func (p *person) setAge(age int) { p.age = age } func main() { p1 := newPerson(\"wang\", 18) fmt.Println(p1.age) p1.setAge(24) fmt.Println(p1.age) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 18 24 2.7.2. 值类型接收者 值类型的接收者，在调用方法时，传递的是数据的一份拷贝，所以方法调用执行过程中，所有的修改在退出方法后都不存在， package main import ( \"fmt\" ) type person struct { name string age int } func newPerson(name string, age int) *person { return &person{ name: name, age: age, } } // 给person类型，定义一个构造函数，返回的是该数据类型的一个数据实例的内存地址，即指针 // 值类型接收者，的方法 func (p person) setAge(age int) { p.age = age } func main() { p1 := newPerson(\"wang\", 18) fmt.Println(p1.age) p1.setAge(24) fmt.Println(p1.age) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 18 18 2.7.3. 使用指针类型接收者的时机 结构体的字段较多，占用内存较大时，传递值内存拷贝较大时； 需要修改同一份数据，而不是数据的拷贝时； 保证一致性，如果一个数据类型定义了多个方法，有一个方法采用了指针类型传递，其他方法也应该用指针类型； 2.8. 任意类型添加方法 不仅仅是结构体，任何数据类型都可以根据需要定义一个方法，如下个int类型定义一个方法 非本地类型不可以定义方法，即不可以给其他包的数据类型定义方法 package main import ( \"fmt\" ) type myInt int // 自定义一个类型，实际是int，然后给其添加一个方法 func (m myInt) sayWhatAmI() { fmt.Println(\"i am int\") } func main() { var myInt1 myInt myInt1.sayWhatAmI() fmt.Printf(\"%T\\n\", myInt1) myInt1 = 100 fmt.Printf(\"%#v\\n\", myInt1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go i am int main.myInt 100 2.9. 结构体的匿名字段 结构体定义时，一般是字段名+ 字段类型，但也可以省略字段名，即成了结构体的匿名字段 示例： package main import ( \"fmt\" ) type person struct { string int // 匿名字段不是真的没有字段，而是go将其字段类型当成了字段的名字，因此同一个结构体中，不能有2个相同类型的匿名字段！！！ /* 实际为： string string int int */ } func main() { p1 := person{ \"wang\", 18, } fmt.Println(p1) fmt.Printf(\"%v\\t %v\\n\", p1.string, p1.int) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go {wang 18} wang 18 2.10. 嵌套结构体 结构体中可以嵌套其他的结构体： 示例代码： package main import ( \"fmt\" ) type address struct { province string city string } type person struct { name string age int add address // 嵌套用了address结构体 } func main() { p1 := person{ name: \"wang\", age: 18, add: address{ province: \"上海\", city: \"上海\", }, } fmt.Printf(\"%#v\\n\", p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go main.person{name:\"wang\", age:18, add:main.address{province:\"上海\", city:\"上海\"}} 2.10.1. 嵌套匿名字段 嵌套结构体时，可以将嵌套的结构体定义为匿名字段 package main import ( \"fmt\" ) type address struct { province string city string } type person struct { name string age int address // 嵌套用了address结构体 ，且用了匿名字段 } func main() { var p1 person p1.name = \"wang\" p1.age = 18 p1.address.province = \"山东\" // 匿名字段用类型名，补充上字段名 p1.city = \"青岛\" // 匿名字段的可以省略，省略了address fmt.Printf(\"%#v\\n\", p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go main.person{name:\"wang\", age:18, address:main.address{province:\"山东\", city:\"青岛\"}} 2.10.2. 嵌套结构体的字段名冲突 嵌套多个结构体时，多个结构体内部可能会有相同的字段，具有字段名，冲突的可以，这时：需要指明嵌套的哪个结构体的哪个字段，避免歧义冲突 package main import ( \"fmt\" ) type address struct { province string city string createtime string } type email struct { account string createtime string } type person struct { name string age int address // 嵌套用了address结构体 ，且用了匿名字段 email // address和email中有相同的字段，createtime } func main() { var p1 person p1.name = \"wang\" p1.age = 18 p1.province = \"山东\" p1.city = \"青岛\" p1.address.createtime = \"2021\" p1.account = \"123\" p1.email.createtime = \"2022\" fmt.Printf(\"%#v\\n\", p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go main.person{name:\"wang\", age:18, address:main.address{province:\"山东\", city:\"青岛\", createtime:\"2021\"}, email:main.email{account:\"123\", createtime:\"2022\"}} 2.11. 结构体“继承” 和其他面向对象语言一样，go的结构体也可以继承，类型a从嵌套了类型b，那么a不仅仅可以使用自己的方法，也可以使用给b定义的方法，即实现“继承” package main import ( \"fmt\" ) type animal struct { name string } func (a *animal) move() { fmt.Printf(\"%s 会动\\n\", a.name) } type dog struct { feet int *animal // 采用了结构体的匿名字段 进行嵌套，且类型是结构体指针类型 // 嵌套之后，dog的实例就可以调用给animal定义的方法 } func (d *dog) wang() { fmt.Printf(\"%s 会汪汪汪\\n\", d.name) } func main() { d1 := &dog{ // 要取地址，因为方法的接收者类型为结构体指针； feet: 4, animal: &animal{ name: \"大黄\", }, } d1.move() d1.wang() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 大黄 会动 大黄 会汪汪汪 2.12. 结构体字段的可见性 所谓结构体字段的可见性： 结构体字段的字段名若是小写首字母，仅仅在当前结构体所在的包中可见，（即可被同一个包中的代码块引用）私有 若是大写首字母，则不属于同一个包的代码块也可以引用该结构体，即可见；公开； 2.13. 结构体与Json序列化 json：javascript object notation是一种轻量级数据交换格式：用于程序之间交换数据，其基本组成形式为键值对； 格式描述： ​ json就是一个个键值对和它们的嵌套组成，键名用双引号\"\"包裹，之后跟冒号:，最后跟值，值若是字符串还要有双引号包裹，每个键值对后都跟一个逗号，除了最后一个键值对。 示例：利用json包，进行结构体和json字符串之间相互转换 package main import ( \"encoding/json\" \"fmt\" ) type Student struct { Id int Gender string Name string } type Class struct { Title string Students []*Student } func main() { c := &Class{ Title: \"101\", Students: make([]*Student, 0, 200), } // 实例化一个Class的结构体，并获得其结构体指针，赋值给c for i := 0; i 2.14. 结构体标签tag 标签tag是结构体的元信息，运行时可以通过反射机制读取，tag在结构体的后方定义，由一对反引号包裹，具体格式如下： `key1:\"value1\" key2: \"value2\"` tag由一个或多个键值对组成，外面由反引号包裹，键后跟冒号:，然后跟双引号包裹的值，多个键值对用空格分割 给结构体的字段添加tag示例： package main import ( \"encoding/json\" \"fmt\" ) type Student struct { Id int `json:\"jsonid\"` // 该tag表示，利用json包转换该结构体数据到json字符串格式时，Id字段表示成jsonid字段，（默认是用相同的Id字段，同理可以添加tag注明该结构体数据存储到mysql数据库中的表示字段） Gender string // 默认采用相同字段Gender作为json化后的键 name string // name n小写，则对于外部的包encodeing中的json方法不可以，所以转换时，该字段就无法被转换 } func main() { s1 := Student{ Id: 1, Gender: \"male\", name: \"zhangsan\", } data, err := json.Marshal(s1) if err != nil { fmt.Println(\"json marshal failed\") return } fmt.Printf(\"json 后: %s\\n\", data) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go json 后: {\"jsonid\":1,\"Gender\":\"male\"} 2.15. 结构体与方法（补充 slice和map这两种数据类型，包含了指向底层数据结构体的执行，因此复制它们时会有些问题 示例代码： 下面例子说明：传递的[]string切片，利用person的方法，赋值给了结构体的dreams字段，但是赋值后又修改了切片，之后再打印发现结构体的dreams字段也随之更改； package main import ( \"fmt\" ) type person struct { name string age int dreams []string } func (p *person) setDreams(dreams []string) { p.dreams = dreams } func main() { p1 := &person{ name: \"wang\", age: 18, } // 实例化一个p1，为person类型的结构体指针 alldreams := []string{\"吃饭\", \"睡觉\"} p1.setDreams(alldreams) fmt.Println(p1) alldreams[0] = \"打豆豆\" fmt.Println(p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go &{wang 18 [吃饭 睡觉]} &{wang 18 [打豆豆 睡觉]} 如何更改：在person的setDream方法中，复制一份传参，然后再赋值给p1的dreams字段，之后alldreams的修改，就不会影响p1的dreams字段了 package main import ( \"fmt\" ) type person struct { name string age int dreams []string } func (p *person) setDreams(dreams []string) { p.dreams = make([]string, len(dreams)) copy(p.dreams, dreams) // 先利用make给p.dreams申请和传参一样大小的切片 // 再利用copy函数，将传参的数据拷贝一份到p.dreams // 之后，alldreams数据的修改也不会影响到p1的数据 } func main() { p1 := &person{ name: \"wang\", age: 18, } // 实例化一个p1，为person类型的结构体指针 alldreams := []string{\"吃饭\", \"睡觉\"} p1.setDreams(alldreams) fmt.Println(p1) alldreams[0] = \"打豆豆\" fmt.Println(p1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go &{wang 18 [吃饭 睡觉]} &{wang 18 [吃饭 睡觉]} 注意点： ​ slice和map作为传参时，是不是值传递，是不是传递的数据的拷贝 3. 练习题 1、使用面向对象的思维方式编写一个学生信息管理系统 学生有id，姓名，年龄，分数等信息 程序提供展示学生列表，添加学生，编辑学生信息，删除学生等功能 3.1. 思路分析 构造一个结构体，stuMgr，（类比于java中的类，它就代表学生管理系统 其包含一个字段，该字段类型是一个map，map的key时学生学号，map的value是学生的struct结构体 嵌套的表示学生信息的结构体有四个字段表示学生的4种信息，（类比与java中的类的属性 其有四个方法代表该程序的4个功能，（类比java中的类的方法 编写main函数，（程序的入口 实例化一个stuMgr；（其allStudents字段，是一个map，要申请一定大小内存用于学生信息存放 打印提示信息：提供5个选项给用户选择，分别进入系统的4个功能； 要是个循环，方便用户多次操作，第5个选项退出功能，os.Exit退出系统； 进入每个功能就对应调用stuMgr的相应方法，每个方法中实现了对应的功能，（增删改查； 学生信息应存放到一个全局变量中（就是上面stuMgr中的allStudents这个map中），使得多个方法操作的是一份数据； 3.2. 解法 package main import ( \"fmt\" \"os\" ) type stuMgr struct { allStudents map[int64]stu } // 定义stuMgr结构体，并包含了一个map，该map键为学生id，值为嵌套的学生的信息结构体 type stu struct { ID int64 Name string } // 定义结构体，包含学生的2个属性信息 func (s *stuMgr) add() { var id int64 var name string fmt.Println(\"请输入要输入的学生id\") fmt.Scanln(&id) fmt.Println(\"请输入要输入的学生姓名\") fmt.Scanln(&name) s.allStudents[id] = stu{ id, name, } } // 结构体的增方法，从标准输入获取用户输入的学生信息，然后组成一个stu结构体实例，并作为值，id作为键添加到map中， func (s *stuMgr) del() { var id int64 fmt.Println(\"请输入您要删除的学生id\") fmt.Scanln(&id) delete(s.allStudents, id) fmt.Printf(\"%d 号学生已经成功删除\", id) } // 结构体的删方法，获取用户输入的id，然后在map中找到对应的键，用delete函数删除该键对应的数据，即该学生的结构体信息，并提示删除成功 // 优化，应先判断要删除的id，存在不 func (s *stuMgr) edit() { var id int64 var name string fmt.Println(\"请输入要修改的学生id\") fmt.Scanln(&id) // 先判断要修改的id是否已经存在，不存在，则提示用户重新输入 _, ok := s.allStudents[id] if !ok { fmt.Println(\"您要修改的id不存在，请重新输入\") return } fmt.Println(\"请输入要修改后的学生姓名\") fmt.Scanln(&name) // 若存在，则新初始化一个stu的结构体临时变量，然后赋值给s.allStudents这个map中对于key的结构体中，就实现了修改原该id学生信息的效果 tmpStudent := stu{ ID: id, Name: name, } s.allStudents[id] = tmpStudent } // 结构体的改方法，获取用户输入的id，先判断是否存在，不存在就提示重新输入，存在就再获取用户输入的修改后学生信息，然后实例化一个临时的学生信息结构体变量，并赋值到原来map中对应的key上，实现修改效果 func (s *stuMgr) show() { for _, stu := range s.allStudents { fmt.Println(stu.ID) fmt.Println(stu.Name) } } // 遍历存储学生信息的map，然后对于每个存储学生信息的结构体进行逐个打印其字段，就打出了所有学生的所有字段信息 // 定义结构体的4个方法，接收者是该结构体的指针类型，4个方法分别实现了增删改查 func printMenu() { fmt.Println(` 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 `) } // 打印首页菜单函数 // 程序主入口 func main() { s1 := &stuMgr{ allStudents: make(map[int64]stu, 100), } // 实例化一个stuMgr的实例，并对其中的map，申请一定内存，用来存放学生信息 // 应该，stuMgr中嵌套student的结构体，然后应初始化一个map，预留申请一定内存，稍后，增删改查四个函数修改该全局变量； var choice int for { printMenu() fmt.Scanln(&choice) // 获取用户输入，并进入到对应的子功能 switch choice { case 1: fmt.Println(\"您选择了添加学生\") s1.add() case 2: fmt.Println(\"您选择了删除学生\") s1.del() case 3: fmt.Println(\"您选择了修改学生信息\") s1.edit() case 4: fmt.Println(\"您选择了查看现有学生信息\") s1.show() case 5: fmt.Println(\"您选择了退出系统\") os.Exit(0) default: fmt.Println(\"请输入1-5之间的数字\") } } } 3.3. 运行效果 latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ go run main.go 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 1 您选择了添加学生 请输入要输入的学生id 100 请输入要输入的学生姓名 wang 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 1 您选择了添加学生 请输入要输入的学生id 200 请输入要输入的学生姓名 li 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 1 您选择了添加学生 请输入要输入的学生id 300 请输入要输入的学生姓名 xian 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 4 您选择了查看现有学生信息 200 li 300 xian 100 wang 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 3 您选择了修改学生信息 请输入要修改的学生id 400 您要修改的id不存在，请重新输入 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 3 您选择了修改学生信息 请输入要修改的学生id 300 请输入要修改后的学生姓名 hahaha 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 4 您选择了查看现有学生信息 100 wang 200 li 300 hahaha 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 2 您选择了删除学生 请输入您要删除的学生id 100 100 号学生已经成功删除 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 4 您选择了查看现有学生信息 200 li 300 hahaha 欢迎进入学生管理系统! ------------------ 请输入您的选择功能：（输入值为1-5之间的数字） 1、添加学生信息 2、删除学生信息 3、修改学生信息 4、查看现有学生信息 5、退出系统 5 您选择了退出系统 latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/10struct (master) $ 3.4. 可以改进的地方 增删改查，四个子功能，应该都有一个循环，用户可以一直操作这个子功能，直到选择退出该功能，回到首页 查看学习信息时，应该先判断是否存在至少一个用户，当没有学生时，应提示用户先添加学生 添加学生信息，应先根据用户输入的id判断，该id是否已经录入，防止重复id 删除和修改学生信息时，也应先根据用户输入id判断，该id是否存在，否则将无法删除或修改 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.11go基础语法之包.html":{"url":"1-go基础语法/1.11go基础语法之包.html","title":"1.11go基础语法之包","keywords":"","body":"1. 包介绍2. 定义包3. 包的可见性4. 包的导入4.1. 单行导入4.2. 多行导入5. 自定义包名6. 匿名导入包7. init()初始化函数7.1. init()函数介绍7.2. init()函数执行顺序8. 练习题1. 包介绍 go开发项目时，go源码的复用是建立在包的基础之上； 包package是多个go源码的集合，一种代码复用方案，go提供了很多内置包，如fmt、os、io，自己开发的包表现为$GOPATH/src目录下的一个目录， go内置的包所在目录：其中d盘下mysoftware的go是本机go环境的安装目录， 2. 定义包 自定义包时：可以在$GOPATH/src目录下创建一个目录，一般该目录名，就是你要定义的包名，目录下是一个个.go文件，存放go源码，该目录下每个.go文件的第一行，都要添加一行如下内容： package 包名/一般也是所在目录名 // 声明其属于这个包 ps： 一个目录下直接包含的文件，只能归属一个package，同一个package的文件，不能在多个目录下 包名可以和文件夹目录，不同，但包名不能包含-符号 包名为main的包，应用程序入口，该包编译后得到可以执行的文件，不包含main包的文件编译，不会得到可执行文件 3. 包的可见性 自己写的包中的标识符（变量、常量、函数、类型等）若想被其他包的代码访问，则需要将其首字母大写！之后其他包的代码就可以访问引用自己写的包中的标识符； ps： 可以注意到go内置的很多标识符、函数、类型等，都是首字母大写； e.g. package pkg2 // 定义自己属于pkg2包 import \"fmt\" var a = 100 // a对外不可以，仅仅本包内代码可访问 const Mode = 1 // Mode对外可以见 type person struct { name string } // 外部包不可见 func Add(x , y int) int { return x + y } // Add函数外部包可见 func age () { // age对外不可见 var Age = 19 // 函数内部局部变量，首字母大写对外也不可见 fmt.Println(Age } 结构体中的字段名和接口中的方法，首字母大写，对外部包，也可访问 type Student struct { Name string // 可见 age int // 不可见 } type Payer interface { init() // 不可见 Pay() // 不见 } 4. 包的导入 包的默认搜索路径：有2个： $GOROOT下的src：go的内置官方包 $GOPATH下的src：第三方包，或自己写的包 导入包的语法： import \"包的路径\" 包的路径要用双引号； 第三方包的搜索路径应该是$GOPATH/src，相对路径从这开始算起，（也可以使用绝对路径 import语句，要放在.go文件开头 go不允许循环导入包 导入内置包，和第三方包的示例： 4.1. 单行导入 import \"包1\" import “包2\" 4.2. 多行导入 import ( \"包1\" \"包2\" ) 5. 自定义包名 导入包时，可以给导入的包定义别名，适用于：包名过长，或者导入的包名字冲突的情况： 语法： import 别名 ”包的路径“ 定义别名示例： package main import ( \"fmt\" m \"github.com/Q1mi/studygo/pkg_test\" ) func main() { fmt.Println(m.Add(100, 200)) fmt.Println(m.Mode) } 6. 匿名导入包 如果只想导入包，而不使用包内部的数据，可以使用匿名导入包，格式： import _ \"包的路径\" 匿名导入的包，和其他方式导入的包，都会编译进可执行文件中 7. init()初始化函数 7.1. init()函数介绍 go中：执行导入包语句会自动触发包内部的init（）函数的调用，init（）函数没有参数，没有返回值，在程序运行时被自动调用，不可主动调用 init（）函数的执行时机： 全局声明 init（） main（） init（）函数执行顺序示例代码： 从打印结果可以看出，先执行全局的变量声明-》执行init（）函数-》执行main函数 package main import \"fmt\" var x int = 100 const pi = 3.14 func init() { fmt.Println(x) } func main() { fmt.Println(\"hello\") } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/12package (master) $ go run main.go 100 hello 7.2. init()函数执行顺序 go，会从main包开始，检查其导入的所有包，若导入的包，又导入了其他的包，go编译器会构建一个树状的包引用关系，根据引用顺序决定编译顺序，然后依次编译这些包 即被最后导入的包，会最先初始化，然后执行其init（）函数，最后执行的是main包的init（）函数 图示： 8. 练习题 编写calc包实现加减乘除4个函数，在main包中导入使用，并使用四个函数，进行四则运算； 0、main包和calc包的组织结构如下：（learngo是在$GOPATH/src目录下 1、编写calc包 package calc func Sum(x, y int) int { return x + y } func Sub(x, y int) int { return x - y } func Cheng(x, y int) int { return x * y } func Chu(x, y int) int { return x / y } // 定义四个方法，要首字母大写 2、编写main包的main.go package main import ( \"fmt\" c \"learngo/basic_grammar/calc\" // 导入calc包，然后定义别名c ) func main() { fmt.Println(c.Sum(100, 10)) fmt.Println(c.Sub(100, 10)) fmt.Println(c.Cheng(100, 10)) fmt.Println(c.Chu(100, 10)) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/12package (master) $ go run main.go 110 90 1000 10 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.12go基础语法之接口.html":{"url":"1-go基础语法/1.12go基础语法之接口.html","title":"1.12go基础语法之接口","keywords":"","body":"1. 接口1.1. 接口类型1.2. 为什么使用接口1.3. 接口的定义1.4. 实现接口的条件1.5. 接口类型变量1.6. 值接收者和指针接收者实现接口的区别1.6.1. 值接收者实现接口1.6.2. 指针接收者实现接口1.6.3. 总结1.6.4. 面试题1.7. 类型与接口的关系1.7.1. 一个类型实现多个接口1.7.2. 多个类型实现同一个接口1.7.3. 嵌套其他类型实现接口的一部分方法1.8. 接口嵌套1.9. 空接口1.9.1. 空接口的定义1.9.2. 空接口的应用1.10. 类型断言1.10.1. 接口值1.10.2. 类型断言2. 练习题2.1. 需求分析2.2. 思路分析2.3. 代码实现2.3.1. mylogger.go2.3.2. console.go2.3.3. file.go2.4. 结果测试2.4.1. 测试main.go文件2.4.2. console输出日志测试2.4.3. file输出日志测试1. 接口 接口interface定义了一个对象的行为规范，只定义了规范，并不实现，由具体的对象实现规范的细节； 1.1. 接口类型 在golang中，接口是一种类型，一种抽象的类型； interface是一组method方法的集合，接口所做的就是定义一组规则，只定义约束对象所具备的功能，而不约束对象的属性， 例如：只要一台机器具有洗衣服和甩干的功能，就称为洗衣机，而不用关系它的属性数据，如大小、形状、容量等 接口是一种类型！ 接口是一种类型！ 接口是一种类型！ 1.2. 为什么使用接口 没有接口时的示例代码： 2个结构体对象，cat和dog都有相同的方法say，没有接口的情况下，每多一种结构体对象，都要为其定义一个相同方法，（造成了代码的冗余 package main import \"fmt\" type cat struct { } type dog struct { } func (c cat) say() string { return \"喵喵喵\" } func (d dog) say() string { return \"汪汪汪\" } func main() { c1 := cat{} d1 := dog{} fmt.Println(\"猫：\", c1.say()) fmt.Println(\"狗: \", d1.say()) } 类似的例子： 支付宝、微信、银联可以抽象为“支付方式”接口处理 三角形、四边形可以抽象为“图形”接口处理其计算周长和面积的方法 接口是一种抽象的类型，看到某个接口类型的值时，不知道它具体是什么，只能知道通过它的方法能实现什么功能 1.3. 接口的定义 go提倡面向接口编程！ 接口由若干个方法组成，接口定义格式： type 接口类型名 interface { 方法名1(参数列表1) 返回值列表1 方法名2（参数列表2） 返回值列表2 ... } 其中： 接口类型名，使用type关键字定义的接口名，一般会在单词后加er后缀，突出其功能 方法名，当接口类型名首字母大写，且方法名首字母大写，此时该方法可以被其他package的代码访问 参数列表，返回值列表，和函数的类似 接口定义示例： type writer interface { Write([]byte) error } 1.4. 实现接口的条件 一个对象只要实现了接口中的所有方法，那么就说该对象实现了该接口，接口：就是一个需要实现的方法的列表 1、定义一个sayer接口 // 定义sayer接口 // 该接口有一个say方法需要实现 type sayer interface { say() } 2、定义cat和dog两个结构体 type dog struct { } type cat struct { } // 定义cat和dog 2个结构体 3、给cat和dog定义实现sayer接口中定义的say方法，（那么cat和dog就实现了sayer接口了） func (d dog) say() { fmt.Println(\"汪汪汪\") } func (c cat) say() { fmt.Println(\"喵喵喵\") } // 分别给cat 和 dog实现了方法say（），此时cat和dog就实现了接口sayer 1.5. 接口类型变量 接口类型变量的作用： 定义了接口之后，声明该接口类型的变量，该变量可以接收，所有实现了该接口的数据类型的实例， 如下例： cat和dog 2个结构体都实现了接口sayer，定义一个sayer接口变量s1，那么s1就可以接收cat和dog所有实例化的对象，如例子中的c1和d1，并可以调用它们的方法say，且方法名相同，实现的功能却有一定的差异， 同理，代码需要实现多种支付功能时，定义一个payer接口，里面需要一个方法pay，在调用时，可以通过一个payer变量的pay方法，通过接收不同对象的实例，实现不同的支付逻辑， package main import \"fmt\" // 定义sayer接口 // 该接口有一个say方法需要实现 type sayer interface { say() } type dog struct { } type cat struct { } // 定义cat和dog 2个结构体 func (d dog) say() { fmt.Println(\"汪汪汪\") } func (c cat) say() { fmt.Println(\"喵喵喵\") } // 分别给cat 和 dog实现了方法say（），此时cat和dog就实现了接口sayer func main() { var s1 sayer c1 := cat{} d1 := dog{} s1 = c1 s1.say() s1 = d1 s1.say() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 喵喵喵 汪汪汪 1.6. 值接收者和指针接收者实现接口的区别 接口中定义需要实现的方法列表 给某个类型定义方法，去实现某接口时，定义方法的接收者有2种选择 值接收 值的指针类型接收 2者的区别见下方例子比较 1.6.1. 值接收者实现接口 package main import \"fmt\" // 定义sayer接口 // 该接口有一个say方法需要实现 type sayer interface { say() } type dog struct { } func (d dog) say() { fmt.Println(\"汪汪汪\") } func main() { var x sayer d1 := dog{} // d1此时是dog结构体的值类型 x = d1 // d1这个值类型，sayer的变量x可以接收，因为dog实现了sayer接口 x.say() d2 := &dog{} // d2此时是dog结构体的指针类型 x = d2 // d2这个结构体指针类型，sayer的变量x，可以接收， // 原因：go对变量的指针类型会自动求值，即d2是指向dog结构体某个实例的指针，而go会自动*d2，求得其值，然后赋值给x x.say() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 汪汪汪 汪汪汪 1.6.2. 指针接收者实现接口 package main import \"fmt\" // 定义sayer接口 // 该接口有一个say方法需要实现 type sayer interface { say() } type dog struct { } func (d *dog) say() { fmt.Println(\"汪汪汪\") } func main() { var x sayer d2 := &dog{} // d2此时是dog结构体的指针类型 x = d2 // d2这个结构体指针类型，sayer的变量x，可以接收，因为实现了接口的方法的，本来就是dog的结构体指针，d2刚刚好就是 x.say() d1 := dog{} // d1此时是dog结构体的值类型 x = d1 // 此时x不能接收d1，因为实现了接口say()方法的是dog类型的指针，而不是dog的值类型 x.say() // 编译不通过，其原因见下方： // dog does not implement sayer (say method has pointer receiver) // dog并没有实现接口sayer，say方法的接收者是指针类型 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go # command-line-arguments .\\main.go:30:4: cannot use d1 (type dog) as type sayer in assignment: dog does not implement sayer (say method has pointer receiver) 1.6.3. 总结 值接收者实现接口，那么声明一个接口的变量，该变量可以接收实现了该接口的对象的实例的，值或指针； 指针接收者实现接口，那么声明一个接口的变量，该变量只可以接收实现了该接口的对象的实例的，值； 1.6.4. 面试题 下方代码能否通过编译： type People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) (talk string) { if think == \"sb\" { talk = \"你是个大帅比\" } else { talk = \"您好\" } return } func main() { var peo People = Student{} think := \"bitch\" fmt.Println(peo.Speak(think)) } 不能，还是因为，student的值类型，不能被peo变量接收，因为实现了people接口的对象student是用指针接收者实现的，实际编译报错如下： latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go # command-line-arguments .\\main.go:22:6: cannot use Student literal (type Student) as type People in assignment: Student does not implement People (Speak method has pointer receiver) 1.7. 类型与接口的关系 接口包含需要实现的方法列表，而类型只要实现了接口中所有方法，就称为该类型实现了该接口，属于该接口类型的变量 因此：一个类型可以实现多个接口，而一个接口可以有多个类型都实现 1.7.1. 一个类型实现多个接口 e.g. package main import \"fmt\" type sayer interface { say() } type mover interface { move() } // 定义2个接口 type dog struct { name string } // 定义dog结构体类型 func (d dog) say() { fmt.Printf(\"%s 在叫\\n\", d.name) } func (d dog) move() { fmt.Printf(\"%s 在动\\n\", d.name) } // 该dog结构体类型，定义了2个方法，分别实现了sayer和mover接口 func main() { var d1 = dog{ name: \"大黄\", } var x sayer var y mover x = d1 x.say() y = d1 y.move() // d1这个dog类型的变量，因为dog实现了sayer和mover接口，所以d1可以赋值给x和y，x和y可以分别调用其实现的方法 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 大黄 在叫 大黄 在动 1.7.2. 多个类型实现同一个接口 只要某类型实现了接口的所有方法，就称该类型实现了该接口，因此一个接口可以有多个类型实现 e.g. package main import \"fmt\" type mover interface { move() } type dog struct { name string } type car struct { brand string } func (d dog) move() { fmt.Printf(\"%s 运动速度是100m/s\\n\", d.name) } func (c car) move() { fmt.Printf(\"%s 运动速度是200m/s\\n\", c.brand) } // dog和car结构体类型，都实现了接口mover要求的move方法，即都实现了该接口 // 此时dog和car，就忽略了其“静态属性”如，外观，大小等，只关注其“具有的动态功能” func main() { var m mover d1 := dog{ name: \"大黄\", } d2 := car{brand: \"拖拉机\"} m = d1 m.move() m = d2 m.move() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 大黄 运动速度是100m/s 拖拉机 运动速度是200m/s 1.7.3. 嵌套其他类型实现接口的一部分方法 某类型要实现某接口时，不需要本身实现其全部方法，还可以嵌套其他类型，其他类型也实现了接口的部分方法，通过引用其他类型实现的方法从而该类型达到了“完整”实现某接口方法的目的 e.g. package main import \"fmt\" type washer interface { wash() dry() } // 定义洗衣机接口，需要wash和dry两个方法 type dryer struct { } // wash类型，嵌套了dry类型，其中dry类型实现了dry（）方法，那么wash类型本身，只需要再实现一个wash（）方法，就完整实现了washer接口要求的所有方法，实现了washer接口 func (d dryer) dry() { fmt.Println(\"我会甩干\") } type wash struct { dryer // 结构体的匿名字段 } func (w wash) wash() { fmt.Println(\"我会洗\") } func main() { var w1 washer var wash1 wash w1 = wash1 w1.dry() w1.wash() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 我会甩干 我会洗 出现的问题：（把上面的dryer类型，去掉er，改成dry，就编译报错，因为dry这个类型名，和dry（）这个方法名重名了，go把wash中嵌套的dry不当成dry类型，而是一个普通字段filed，会报错，解决：随便改个名字，不要和dry（）方法重名，加个s都行！ package main import \"fmt\" type washer interface { wash() dry() } // 定义洗衣机接口，需要wash和dry两个方法 type dry struct { } // wash类型，嵌套了dry类型，其中dry类型实现了dry（）方法，那么wash类型本身，只需要再实现一个wash（）方法，就完整实现了washer接口要求的所有方法，实现了washer接口 func (d dry) dry() { fmt.Println(\"我会甩干\") } type wash struct { dry // 结构体的匿名字段 } func (w wash) wash() { fmt.Println(\"我会洗\") } func main() { var w1 washer var wash1 wash w1 = wash1 w1.dry() w1.wash() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go # command-line-arguments .\\main.go:33:5: wash.dry is a field, not a method .\\main.go:33:5: cannot use wash1 (type wash) as type washer in assignment: wash does not implement washer (missing dry method) 1.8. 接口嵌套 接口可以嵌套其他的接口，从而组成一个新的接口： e.g. package main import \"fmt\" // 接口嵌套 type eater interface { eat() } type mover interface { move() } type animal interface { eater mover } // animal 嵌套eater和mover定义了它自己这个新的接口 type cat struct { name string } func (c cat) eat() { fmt.Printf(\"%s 会吃\\n\", c.name) } func (c cat) move() { fmt.Printf(\"%s 会动\\n\", c.name) } func main() { var x animal c1 := cat{ name: \"加菲\", } x = c1 x.eat() x.move() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 加菲 会吃 加菲 会动 1.9. 空接口 1.9.1. 空接口的定义 空接口是指，没有定义任何方法的接口，因此：所有类型的数据，都实现了空接口，任何一个类型的数据都可以被空接口变量接收！ e.g. package main import \"fmt\" // 空接口 func main() { var x interface{} n := 100 x = n fmt.Printf(\"type: %T, value: %v\\n\", x, x) b := \"hello\" x = b fmt.Printf(\"type: %T, value: %v\\n\", x, x) c := true x = c fmt.Printf(\"type: %T, value: %v\\n\", x, x) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go type: int, value: 100 type: string, value: hello type: bool, value: true 1.9.2. 空接口的应用 1、作为函数的传参类型 一般情况下，函数的传参，都是某个特定类型，但是若定义传参的类型为interface{}，就可以传入任何类型的参数 package main import \"fmt\" // 空接口做函数的传参类型 func print(a interface{}) { fmt.Printf(\"type : %T, value: %v\\n\", a, a) } func main() { print(8) print(\"hello\") print(true) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go type : int, value: 8 type : string, value: hello type : bool, value: true fmt的Printf函数其第二个传参的类型就是一个空接口 // Printf formats according to a format specifier and writes to standard output. // It returns the number of bytes written and any write error encountered. func Printf(format string, a ...interface{}) (n int, err error) { return Fprintf(os.Stdout, format, a...) } 2、空接口定义为map的值类型 定义map时，其值类型定义为空接口，那么其值部分，可以接收所有类型的数据 package main import \"fmt\" func main() { m1 := make(map[string]interface{}, 100) m1[\"name\"] = \"wang\" m1[\"age\"] = 18 m1[\"shuai\"] = true fmt.Println(m1) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go map[age:18 name:wang shuai:true] 1.10. 类型断言 空接口可以接收并存储所有类型的数据，若要具体知道其中存储的是什么类型的数据，可以通过类型断言 1.10.1. 接口值 一个接口的值，简称接口值，是由一个一个具体类型和该具体类型的值，两部分组成，这两部分分别称为动态类型和动态值； e.g. var w io.Writer w = os.Stdout w = new(bytes.Buffer) w = nil 内存中w的变化情况： 1.10.2. 类型断言 当想知道某个接口变量，其中存储的目前是什么类型的数据可以采用类型断言； 语法： x.(T) // x 某个是接口变量 // T是你要判断/猜测的数据类型，如int string等 // 判断返回2个值，判断成功则第一个返回的是该类型的值，第二个返回的是true，若判断失败，第二个返回的是false e.g. package main import \"fmt\" func main() { var a interface{} a = 8 value, ok := a.(int) if !ok { fmt.Println(\"不是int\") } else { fmt.Printf(\"是int，其值：%v\\n\", value) } } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 是int，其值：8 package main import \"fmt\" func main() { var a interface{} a = true value, ok := a.(int) if !ok { fmt.Println(\"不是int\") } else { fmt.Printf(\"是int，其值：%v\\n\", value) } } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 不是int 使用switch简化判断 package main import \"fmt\" func main() { var a interface{} a = make(map[string]int) switch a.(type) { case int: fmt.Println(\"是int\") case string: fmt.Println(\"是string\") case bool: fmt.Println(\"是bool型\") default: fmt.Println(\"反正不是int string bool\") } } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/11interface (master) $ go run main.go 反正不是int string bool ps: 空接口可以接收所有类型，使用较为广泛； 不要为了用接口而用接口，只有2个或以上的不同类型，具有相同的“功能”方法时，考虑用接口 2. 练习题 使用接口的方式，实现一个既可以往终端写日志、也可以往文件写日志的简易日志库 2.1. 需求分析 支持将日志写到不同地方 终端 日志文件 日志分级别 unknown debug trace info warning error fatal 日志支持开关控制 完整的日志记录需要包含 时间 行号 文件名 日志级别 日志定制化信息（可以接收变量并格式化输出，就像fmt.Printf 日志文件支持切割 2.2. 思路分析 2.3. 代码实现 在mylogger包中，共有3个.go文件，分别是mylogger.go file.go console.go 三个文件的实现的作用 mylogger 定义日志级别类型，基于uint16 定义logger接口，该接口定义了需要实现记录各个日志级别日志的方法 filelogger结构体和console结构体分别实现接口定义的方法，（即都实现了logger接口 将日志级别字符串如DEBUG转为自定义的日志级别类型基于uint16类型的DEBUG 将自定义的日志级别转为对应的字符串，（打印函数处使用 获取代码调用的信息函数 file.go 见下方代码中注释 console.go 见下方代码中注释 2.3.1. mylogger.go package mylogger import ( \"errors\" \"fmt\" \"path/filepath\" \"runtime\" \"strings\" ) /* 该mylogger.go实现的代码 1. 定义LogLevel类型，用于表示日志级别 2. 定义LogLevel类型的7个常量，表示6个日志级别和1个unknown级别 3. 将日志级别 从字符串类型 转为 自定义的LogLevel类型 的函数 4. 将日志级别 从自定义的LogLevel类型 转为 字符串类型 的函数 5. 获取调用日志记录方法的代码的行号，所在文件，函数名信息 */ // LogLevel 基于uint16定义个自定义类型LogLevel，用于表示日志级别 // 定义接口mylogger，里面的方法，Filelogger和ConsoleLogger都会实现，即都实现了该接口 type Mylogger interface { DEBUG(format string, args ...interface{}) TRACE(format string, args ...interface{}) INFO(format string, args ...interface{}) WARNING(format string, args ...interface{}) ERROR(format string, args ...interface{}) FATAL(format string, args ...interface{}) } type LogLevel uint16 const ( UNKNOWN LogLevel = iota // uint16 的0 DEBUG // uint16 的1 TRACE // uint16 的2 INFO // 依次自增1... WARNING ERROR FATAL ) // 将传入的日志级别字符串类型转为自定义的类型LogLevel // 因为调用mylogger时传入的是DEBUG INFO 字符串，在myloggger包内部处理时，是用LogLevel类型处理，所以需要将字符串转为LogLevel类型 // (虽然看起来都一样) func parseLogLevel(s string) (LogLevel, error) { s = strings.ToLower(s) // 先统一转为小写，方便后续switch switch s { case \"debug\": return DEBUG, nil case \"trace\": return TRACE, nil case \"info\": return INFO, nil case \"warning\": return WARNING, nil case \"error\": return ERROR, nil case \"FATAL\": return FATAL, nil default: err := errors.New(\"unknow loglevel type\") return UNKNOWN, err } } // 将自定义的日志类型logLevel，转为字符串类型，打印时，需要将传入打印函数的LogLevel类型转为字符串类型，进行printf格式化打印 func getLogString(lv LogLevel) string { switch lv { case DEBUG: return \"DEBUG\" case TRACE: return \"TRACE\" case INFO: return \"INFO\" case WARNING: return \"WARNING\" case ERROR: return \"ERROR\" case FATAL: return \"FATAL\" default: return \"DEBUG\" } } // 传入一个整数，利用runtime.Caller函数，获得调用此函数所在的函数名、文件名、代码行数 // 0代表该层函数的信息，1获得的是调用该函数的信息，2获得是调用该函数的上层函数的信息，3，依次向外加一层函数 func getCodeInfo(skip int) (funcName, fileName string, lineNo int) { pc, file, line, ok := runtime.Caller(skip) if !ok { fmt.Println(\"runtime Caller() function failed!\\n\") return } funcName = runtime.FuncForPC(pc).Name() funcName = strings.Split(funcName, \".\")[1] fileName = filepath.Base(file) lineNo = line return funcName, fileName, lineNo } 2.3.2. console.go package mylogger import ( \"fmt\" \"time\" ) // 该console.go文件作用：向终端中打印日志 // 该文件的主要代码块，功能如下： /* 1. 定义一个ConsoleLogger结构体 包含一个字段，即日志级别，实例化时需要传入一个LogLevel类型的日志级别（表示打印该级别及以上的函数 2. ConsoleLogger的一个构造函数， 作用：接收一个日志级别的字符串类型，返回一个ConsoleLogger实例 3. isEnable函数：判断实例的loglevel级别是否小于调用该实例函数级别，如果小，就执行实例函数，进行记录该级别日志，否则就不记录 举例： 实例化ConsoleLogger实例时，传入的是info级别，（即表示只记录info级别及以上的日志 则调用该实例的debug和trace方法记录相应级别日志时，则不会记录 只有调用在info或info之上的方法，才会记录相应级别日志 4. 记录各个级别日志的方法，共有6个， 接收者是指针类型的consoleLogger 分别对应：debug trace info warning error fatal 6个方法中，都只有一句代码，就是调用具体的日志记录函数 5. 具体的日志记录函数：被6个记录日志的方法调用，负责具体的日志记录实现 记录日志的时间、级别、传入的日志信息、调用记录日志的函数位置 */ // ConsoleLogger ... type ConsoleLogger struct { Level LogLevel // 该结构体实例化时，只需要传入一个日志级别，（调用各个记录各个日志级别的方法时，只有其方法对应的日志级别大于或等于实例化时传入的级别，才进行日志记录 // 通过该传值就可以实现控制日志的记录的级别 } // NewConsoleLogger 构造函数 // 接收一个日志级别的字符串类型，返回一个*ConsoleLogger实例 func NewConsoleLogger(lv string) *ConsoleLogger { loglevel, err := parseLogLevel(lv) if err != nil { panic(err) } return &ConsoleLogger{ Level: loglevel, } } func (c *ConsoleLogger) isEnable(lv LogLevel) bool { if lv >= c.Level { return true } else { return false } } // 具体进行记录日志的函数 func (c *ConsoleLogger) recordLog(lv LogLevel, format string, args ...interface{}) { if c.isEnable(lv) { // 经过判断，只有调用该方法时，该方法对应的日志级别小于或等于实例化结构体传入的日志级别Level，才进行下面的记录日志逻辑， // 一条日志要记录的内容 // 时间 // 日志级别 // 调用记录日志的代码所在的行、函数名、文件名，利用runtime.Caller实现 // 调用日志时，传入的变量和格式化输出符 // 时间 // now := time.Now().Format(\"2006-01-02 15:03:04\") now := time.Now().Format(\"2006-01-02 15:04:05.000\") // 日志级别 LevelStr := getLogString(lv) // 调用记录日志的代码所在的行、函数名、文件名，利用runtime.Caller实现 funName, fileName, lineNo := getCodeInfo(3) // 本层向外三层代码的信息 // 调用日志时，传入的变量和格式化输出符 msg := fmt.Sprintf(format, args...) // Sprintf函数，将格式化输出占位符和变量，直接格式化后，形成一个格式后的字符串返回 // 打印以上四项内容 fmt.Printf(\"[%s] [%s] [%s:%s:%d] [%s] \\n\", now, LevelStr, funName, fileName, lineNo, msg) } } // DEBUG 定义ConsoleLogger对象的DEBUG方法，该方法接收format格式化字符串，和0或以上个空接口类型的参数，（即所有类型） // 一个consoleLogger实例调用该方法，可以记录DEBUG级别的日志 func (c *ConsoleLogger) DEBUG(format string, args ...interface{}) { c.recordLog(DEBUG, format, args...) // args 本质是一个空接口类型的切片[]interface{}，传入的0或以上的参数，会以一个切片传递给函数，注意：args...要加...，不加就会把传入的0或以上的参数当作切片的第一个元素传递给函数 } // TRACE trace日志记录含数 func (c *ConsoleLogger) TRACE(format string, args ...interface{}) { c.recordLog(TRACE, format, args...) } // INFO ... func (c *ConsoleLogger) INFO(format string, args ...interface{}) { c.recordLog(INFO, format, args...) } // WARNING ... func (c *ConsoleLogger) WARNING(format string, args ...interface{}) { c.recordLog(WARNING, format, args...) } // ERROR .... func (c *ConsoleLogger) ERROR(format string, args ...interface{}) { c.recordLog(ERROR, format, args...) } // FATAL ... func (c *ConsoleLogger) FATAL(format string, args ...interface{}) { c.recordLog(FATAL, format, args...) } 2.3.3. file.go package mylogger import ( \"fmt\" \"os\" \"path/filepath\" \"time\" ) /* 该file.go文件需要实现的代码 1. filelogger结构体 包含： 日志文件路径 文件名 文件切割时的大小，即日志文件最大能达到的大小 日志级别LogLevel类型 一个普通日志文件对象 一个错误日志文件对象，（单独记录一份错误日志） （文件名包含2个，一个记录所有日志，一个记录error级别以上的错误日志） 2. filelogger结构体的构造函数 返回fileLogger的指针类型 3. 6个日志级别的记录方法，接受者是指针类型的filelogger 4. log函数 负责实现记录日志的函数，由上面6个日志级别的记录方法调用 5. isEnable函数，判断是否记录该级别的日志，由负责实际记录日志的函数调用 6. checkSize函数 记录日志时，根据当前日志文件的大小，判断是否需要进行日志文件的轮替，即日志切割 7. splitFile函数 若经过了checkSize函数的检查，需要进行日志切割的时候，则调用split函数进行日志文件的切割 8. initFile函数 被filelogger的构造函数调用，进行日志文件的初始打开工作，得到普通日志文件，错误日志文件的2个文件对象，从而得到一个完整的filelogger实例 9. 总结一下，该文件的代码逻辑： 其他代码先import该库； 通过fileLogger的构造函数，传入需要的参数，假设传入的日志级别为INFO， 再调用initFile函数，得到2个文件对象 得到一个filelogger的实例，如f1 需要记录某级别的一条日志时，就调用该实例的对于级别方法，如f1.WARNING 进入到INFO方法内部： 直接将参数传给log，调用log函数，进入log函数内部： 先调用isEnable函数，判断是否记录该级别日志，warning大于info，进行记录； 然后记录前，调用checkSize函数： 判断当前日志文件大小是否超出了定义了日志文件最大值 大于，就调用splitFile函数，进行日志切割 小于，就直接进行日志记录 然后，判断该级别是不是大于等于ERROR级别 大于，则单独记录一份日志到错误日志文件 先checkSize判断错误日志文件的大小， 超过最大值就调用split进行文件切割 不超过，就直接进行日志记录 不是，则不进行任务记录 至此，完成了一条日志的记录 */ // FileLogger ... type FileLogger struct { level LogLevel filedir string filename string errfilename string maxsize int64 fileObj *os.File errfileObj *os.File } // NewFileLogger 构造一个FileLogger实例 func NewFileLogger(lv string, filedir string, filename, errfilename string, maxsize int64) *FileLogger { loglevel, err := parseLogLevel(lv) if err != nil { panic(err) } f := &FileLogger{ level: loglevel, filedir: filedir, filename: filename, errfilename: errfilename, maxsize: maxsize, } // fileObj, err := f.initFile(filedir, filename) // errfileObj, err := f.initFile(filedir, errfilename) // f.FileObj = fileObj // f.errfileObj = errfileObj err = f.initFile() // 调用initFile方法，打开2个文件，获得2个文件对象，构成一个完整的fileLogger实例 if err != nil { panic(err) } return f } func (f *FileLogger) isEnable(lv LogLevel) bool { if lv >= f.level { return true } else { return false } } func (f *FileLogger) checkSize(fileObj *os.File) bool { // 获得传入文件的大小信息，并和f.maxsize比较 fileInfo, err := fileObj.Stat() if err != nil { fmt.Printf(\"get file info failed,err : %v\\n\", err) return false } if fileInfo.Size() >= f.maxsize { return true } else { return false } } // splitFile 该函数，接收一个文件对象，然后获取当前时间戳，将接收的文件对象加一个时间戳后缀，然后关闭它，重命名它，然后再开一个和接收的文件对象同名的文件对象，并作为返回值返回 func (f *FileLogger) splitFile(file *os.File) (*os.File, error) { fileInfo, err := file.Stat() fileName := fileInfo.Name() nowSuffix := time.Now().Format(\"20060102150405000\") // 关闭老的 file.Close() // 重命名老的 // os.Rename(fileName, fileName+\"now\") fullname := filepath.Join(f.filedir, fileName) os.Rename(fullname, fullname+nowSuffix) // 打开一个和老的文件，同名的，新文件 newfileObj, err := os.OpenFile(fullname, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Printf(\"open new file failed when split file, err:%v\\n\", err) return nil, err } return newfileObj, nil } // recordLog ... func (f *FileLogger) recordLog(lv LogLevel, format string, args ...interface{}) { // 接收三个参数，要打印的日志级别；格式化输出字符串，0或多个空接口类型的字符串（用一个空接口类型的切片接收） // 先判断该级别日志是否打印，即该级别是否大于等于实例化时传入的日志级别 if f.isEnable(lv) { // 如果大于等于，则记录，但记录前先判断当前日志文件是否需要切割 if f.checkSize(f.fileObj) { newfileObj, err := f.splitFile(f.fileObj) if err != nil { fmt.Println(err) } f.fileObj = newfileObj } // 不需要切割，或切割后生成了新文件，继续下面的逻辑，记录日志 msg := fmt.Sprintf(format, args...) now := time.Now().Format(\"2006-01-02 15:04:05.000\") // 日志级别 LevelStr := getLogString(lv) // 调用记录日志的代码所在的行、函数名、文件名，利用runtime.Caller实现 funName, fileName, lineNo := getCodeInfo(3) // 本层向外三层代码的信息 fmt.Fprintf(f.fileObj, \"[%s] [%s] [%s:%s:%d] [%s]\\n\", now, LevelStr, funName, fileName, lineNo, msg) // 记录日志后，再判断下，当前日志级别是否大于等于ERROR，如果是，单独记录一条日志到errorlog文件中 if lv >= ERROR { // 记录前，先判断errorlog文件的大小 if f.checkSize(f.errfileObj) { newfileObj, err := f.splitFile(f.errfileObj) if err != nil { fmt.Println(err) } f.errfileObj = newfileObj } // 不需要切割，或切割后生成了新文件，继续下面的逻辑，记录错误日志 fmt.Fprintf(f.errfileObj, \"[%s] [%s] [%s:%s:%d] [%s]\\n\", now, LevelStr, funName, fileName, lineNo, msg) } } } // DEBUG ... func (f *FileLogger) DEBUG(format string, args ...interface{}) { f.recordLog(DEBUG, format, args...) } // TRACE ... func (f *FileLogger) TRACE(format string, args ...interface{}) { f.recordLog(TRACE, format, args...) } // INFO ... func (f *FileLogger) INFO(format string, args ...interface{}) { f.recordLog(INFO, format, args...) } // WARNING ... func (f *FileLogger) WARNING(format string, args ...interface{}) { f.recordLog(WARNING, format, args...) } // ERROR ... func (f *FileLogger) ERROR(format string, args ...interface{}) { f.recordLog(ERROR, format, args...) } // FATAL ... func (f *FileLogger) FATAL(format string, args ...interface{}) { f.recordLog(FATAL, format, args...) } // initFile filelogger的方法，打开文件，获得文件对象，构成一个完整的filelogger对象 // 改进后，都是filelogger的方法了，（当然不需要再传递该结构体的字段值了，直接用 func (f *FileLogger) initFile() error { fullfilename := filepath.Join(f.filedir, f.filename) fileObj, err := os.OpenFile(fullfilename+\".log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return err } f.fileObj = fileObj fullerrfilename := filepath.Join(f.filedir, f.errfilename) errfileObj, err := os.OpenFile(fullerrfilename+\".log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return err } f.errfileObj = errfileObj return nil } // func (f *FileLogger) initFile(filedir, filename string) (*os.File, error) { // fullfilename := filepath.Join(filedir, filename) // fileObj, err := os.OpenFile(fullfilename+\".log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) // if err != nil { // fmt.Printf(\"open file:%s failed, err:%v\\n\", filename, err) // newerr := errors.New(\"open file failed\") // return nil, newerr // } // return fileObj, err // } 2.4. 结果测试 2.4.1. 测试main.go文件 分别构造了mylogger包中的2个构造方法，生成了filelogger和consolelogger实例，用于分别向文件和终端中记录日志（用一个接口变量可以接收该两个实例 package main import ( \"learngo/mylogger\" \"time\" ) func main() { var Newmylogger mylogger.Mylogger // fileloggerObj := mylogger.NewFileLogger(\"INFO\", \"C:\\\\myworkstation\\\\mygocode\\\\src\\\\learngo\\\\test_mylogger\", \"web\", \"weberr\", 3*1024) // Newmylogger = fileloggerObj consoleloggerObj := mylogger.NewConsoleLogger(\"TRACE\") Newmylogger = consoleloggerObj s1 := \"wang\" s2 := \"shuai\" n1 := 100 for { Newmylogger.DEBUG(\"一条debug级别日志 %s %s %d\", s1, s2, n1) Newmylogger.TRACE(\"这是一条trace级别日志\") Newmylogger.INFO(\"一条info级别日志\") Newmylogger.WARNING(\"一条warning级别日志\") Newmylogger.ERROR(\"一条error级别日志\") Newmylogger.FATAL(\"一条fatal级别日志\") time.Sleep(time.Millisecond * 500) } } 2.4.2. console输出日志测试 ten@DESKTOP-7ICOPRG MINGW64 /c/myworkstation/mygocode/src/learngo/test_mylogger (master) $ ./test_mylogger.exe [2021-01-29 13:53:54.432] [TRACE] [main:main.go:23] [这是一条trace级别日志] [2021-01-29 13:53:54.455] [INFO] [main:main.go:24] [一条info级别日志] [2021-01-29 13:53:54.456] [WARNING] [main:main.go:25] [一条warning级别日志] [2021-01-29 13:53:54.456] [ERROR] [main:main.go:26] [一条error级别日志] [2021-01-29 13:53:54.456] [FATAL] [main:main.go:27] [一条fatal级别日志] [2021-01-29 13:53:54.957] [TRACE] [main:main.go:23] [这是一条trace级别日志] [2021-01-29 13:53:54.957] [INFO] [main:main.go:24] [一条info级别日志] [2021-01-29 13:53:54.958] [WARNING] [main:main.go:25] [一条warning级别日志] [2021-01-29 13:53:54.959] [ERROR] [main:main.go:26] [一条error级别日志] [2021-01-29 13:53:54.959] [FATAL] [main:main.go:27] [一条fatal级别日志] [2021-01-29 13:53:55.460] [TRACE] [main:main.go:23] [这是一条trace级别日志] [2021-01-29 13:53:55.460] [INFO] [main:main.go:24] [一条info级别日志] [2021-01-29 13:53:55.461] [WARNING] [main:main.go:25] [一条warning级别日志] 2.4.3. file输出日志测试 可以看到，分为正常日志文件、专门的错误日志文件，2个文件，并都可以日志切割，大于实例化时传入的3*1024即3KB进行切割，文件也确实在4KB时进行了切割 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.13go基础语法之反射.html":{"url":"1-go基础语法/1.13go基础语法之反射.html","title":"1.13go基础语法之反射","keywords":"","body":"1. 变量内在机制2. 反射介绍3. reflect包3.1. TypeOf3.1.1. type name 和 type kind3.2. ValueOf3.2.1. 反射获取值3.2.2. 反射设置变量的值3.2.3. isNil()和isValid()4. 结构体反射4.1. 与结构体相关的方法4.2. StructField类型4.3. 结构体反射示例5. 反射的利与弊6. 练习题6.1. 思路分析6.2. 具体代码6.3. 运行结果1. 变量内在机制 go中变量分2部分： 类型信息：预习定义的元信息 值信息：程序运行中可动态变化的 2. 反射介绍 反射是指：程序运行中，对程序本身进行访问和修改的能力； 程序编译时，变量被转为内存地址，变量名不会被编译器写到可执行部分，运行程序时，程序无发获得自身的信息 支持反射的语言，可以在程序编译期间，将变量的反射信息，如：字段名，类型信息，结构体信息，整合到可执行文件中，并给程序提供接口访问这些反射信息，从而程序可以在运行期间获取变量的反射信息，并可以修改它们 golang在运行期间用reflect包访问程序的反射信息 例如：空接口类型的变量可以存储任何类型的变量，那么如何知道这个空接口保存的具体数据类型和数据的值呢？答案：利用反射，反射可以在运行时动态的获得一个变量的（类型信息）和（值信息） 3. reflect包 golang的反射机制中：任何接口的值都是由一个具体的类型和该具体类型的值2部分组成，反射功能由reflect包提供； 任何接口在反射中可以理解为2部分组成：reflect.Type和reflect.Value reflect包提供了2个函数reflect.TypeOf和reflect.ValueOf来获得任意对象的类型和值 3.1. TypeOf reflect.TypeOf可以获得任意一个变量的类型；返回的是reflect.Type类型 e.g. package main import ( \"fmt\" \"reflect\" ) func testReflect(x interface{}) { v := reflect.TypeOf(x) fmt.Printf(\"x的 类型是：%v\\n\", v) } func main() { var a int32 var b int var e int64 var c bool var d string testReflect(a) testReflect(b) testReflect(e) testReflect(c) testReflect(d) } ten@DESKTOP-7ICOPRG MINGW64 /c/myworkstation/mygocode/src/learngo/basic_grammar/16reflect (master) $ go run main.go x的 类型是：int32 x的 类型是：int x的 类型是：int64 x的 类型是：bool x的 类型是：string 3.1.1. type name 和 type kind 变量的类型又分2个，type.name（类型）和type.kind(种类)，kind表示的是该变量在底层的数据结构上，具体表现为什么，囊括的范围更大（有点生物上划分科 属 种的意思 e.g.下例可以看出type name和type kind的区别，其中指针类型的变量没有type name，只有type kind为ptr package main import ( \"fmt\" \"reflect\" ) func testReflect(x interface{}) { v := reflect.TypeOf(x) fmt.Printf(\"x的类型type.name是：%v, x的种类type.kind是：%v\\n\", v.Name(), v.Kind()) } func main() { type hello int64 // 自定义类型 type person struct { name string } type book struct { title string } var a *int var b int32 var c hello var d rune // rune是内置的类型别名 p1 := person{ name: \"wang\", } b1 := book{ title: \"刻意练习\", } testReflect(a) testReflect(b) testReflect(c) testReflect(d) testReflect(p1) testReflect(b1) } ten@DESKTOP-7ICOPRG MINGW64 /c/myworkstation/mygocode/src/learngo/basic_grammar/16reflect (master) $ go run main.go x的类型type.name是：, x的种类type.kind是：ptr x的类型type.name是：int32, x的种类type.kind是：int32 x的类型type.name是：hello, x的种类type.kind是：int64 x的类型type.name是：int32, x的种类type.kind是：int32 x的类型type.name是：person, x的种类type.kind是：struct x的类型type.name是：book, x的种类type.kind是：struct golang中，反射时，查看数组、切片、map、指针类型的变量时，.Name()都是返回空 reflect包中kind的定义： // A Kind represents the specific kind of type that a Type represents. // The zero Kind is not a valid kind. type Kind uint const ( Invalid Kind = iota Bool Int Int8 Int16 Int32 Int64 Uint Uint8 Uint16 Uint32 Uint64 Uintptr Float32 Float64 Complex64 Complex128 Array Chan Func Interface Map Ptr Slice String Struct UnsafePointer ) 3.2. ValueOf reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息，reflect.Value可以和原始值之间相互转换 通过reflect.Value类型，获取原始值的方法有：（即调用reflect.ValueOf()方法获得一个reflect.Value类型的变量后，该reflect.Value类型的变量，可以通过以下几种方法获得原始值。 方法 说明 Interface() interface{} 将值以interface{}类型返回，通过类型断言转为指定类型 Int() int64 将值以Int类型返回，所有有符号整型均支持该方式返回 Uint() uint64 将值以uint类型返回，所有无符号整型均支持该方式返回 Float() float64 将值以双精度float64类型返回，所有浮点数均支持 Bool() bool 将值以bool类型返回 Bytes() []bytes 将值以字节数据类型返回 String() string 将值以字符串类型返回 3.2.1. 反射获取值 package main import ( \"fmt\" \"reflect\" ) func reflectValue(x interface{}) { v := reflect.ValueOf(x) k := v.Kind() switch k { case reflect.Int32: // 调用v的Int（）方法，获得v的值，Int方法访问的是int64类型，用int32强制转回int32后打印 fmt.Printf(\"%T\\n\", v.Int()) fmt.Printf(\"x 的值是 %d\\n\", int32(v.Int())) fmt.Printf(\"%T\\n\", int32(v.Int())) case reflect.Float32: fmt.Printf(\"x 的值是 %f\\n\", v.Float()) // 默认返回的是float64 fmt.Printf(\"%T\\n\", v.Float()) case reflect.Int: fmt.Printf(\"%T\\n\", v.Int()) } } func main() { var a int32 = 100 var b float32 = 3.14 reflectValue(a) reflectValue(b) reflectValue(666) fmt.Printf(\"%T\\n\", 66) } ten@DESKTOP-7ICOPRG MINGW64 /c/myworkstation/mygocode/src/learngo/basic_grammar/16reflect (master) $ go run main.go int64 x 的值是 100 int32 x 的值是 3.140000 float64 int64 int 3.2.2. 反射设置变量的值 在函数中通过反射修改变量的值：函数的传参，传递的是值拷贝，因此，只有传递变量的地址，才能达到在函数中修改变量值的目的，**反射中用Elem()方法，获取指针对应的值 package main import ( \"fmt\" \"reflect\" ) func setReflectValue1(x interface{}) { // 获得一个reflect.Value对象，v v := reflect.ValueOf(x) if v.Kind() == reflect.Int { v.SetInt(200) // 修改的是副本，且会触发panic } fmt.Println(v.Int()) } func setReflectValue2(x interface{}) { v := reflect.ValueOf(x) if v.Elem().Kind() == reflect.Int { v.Elem().SetInt(300) } } func main() { var a int = 100 // setReflectValue1(a) // panic: reflect: reflect.flag.mustBeAssignable using unaddressable value 还会触发panic setReflectValue2(&a) // 传递的要是内存地址，即指针 fmt.Println(a) } $ go run main.go 300 3.2.3. isNil()和isValid() isNil（） isNil()方法，判断v持有的值，是否为nil，v持有的值的分类，必须是通道、函数、接口、映射、指针、切片之一，否则isNil函数会引发panic func (v Value) IsNil() bool isValid() isValid()方法，判断v是否持有一个值，如果v是Value类型，且是零值，会返回false，此时v除了isValid，Strings，Kind之外的方法都会引发panic func (v Value) IsValid() bool 例子： isNil常用于判断指针是否为空；isValid常用于判断是否有返回值 package main import ( \"fmt\" \"reflect\" ) // IsNil()方法，其接收者是: reflect.Value类型，其返回一个bool值，即true或false // 作用：常用于判断一个指针变量是否为空值，即这个指针是否没有指向任何一个内存地址 // IsValid()方法，其接收者是: reflect.Value类型，其返回一个bool值，即true或false // 作用：常用于判断一个变量，它是否持有某个值，例如：向某个map或struct中传入一个字段，判断利用IsValid（）方法判断map或struc中是否存在该字段 func main() { // *int类型空指针 var a *int fmt.Println(\"判断a这个指针变量，其是否是一个空值，即没有存储任何一个内存地址，结果是：\", reflect.ValueOf(a).IsNil()) // 下面一行，为什么是是true呢？？？空值零值啥的，还是理解不对 fmt.Println(reflect.ValueOf(a).IsValid()) // nil“变量” fmt.Println(\"判断nil，是否存储了一个值，结果是：\", reflect.ValueOf(nil).IsValid()) // 实例化一个匿名结构体 b := struct{}{} // 试着从结构体b中找\"abc\"字段 fmt.Println(\"判断b结构体中是否存在字段abc，结果是：\", reflect.ValueOf(b).FieldByName(\"abc\").IsValid()) // 试着从结构体中查找”abc“方法 fmt.Println(\"判断b结构体中是否存在方法abc，结果是：\", reflect.ValueOf(b).MethodByName(\"abc\").IsValid()) var b1 struct { name string score int } fmt.Println(\"判断b1结构体中是否存在字段score，结果是：\", reflect.ValueOf(b1).FieldByName(\"score\").IsValid()) // 从map中查找一个不存在的键 c := map[string]int{} fmt.Println(\"判断c这个map中是否存在shuaibi这个键，结果是：\", reflect.ValueOf(c).MapIndex(reflect.ValueOf(\"shuaibi\")).IsValid()) d := make(map[string]int, 10) d[\"shuaibi\"] = 100 fmt.Println(\"判断d这个map中是否存在shuaibi这个键，结果是：\", reflect.ValueOf(d).MapIndex(reflect.ValueOf(\"shuaibi\")).IsValid()) } $ ./16reflect.exe 判断a这个指针变量，其是否是一个空值，即没有存储任何一个内存地址，结果是： true true 判断nil，是否存储了一个值，结果是： false 判断b结构体中是否存在字段abc，结果是： false 判断b结构体中是否存在方法abc，结果是： false 判断b1结构体中是否存在字段score，结果是： true 判断c这个map中是否存在shuaibi这个键，结果是： false 判断d这个map中是否存在shuaibi这个键，结果是： true 4. 结构体反射 4.1. 与结构体相关的方法 通过reflect.TypeOf()获取某个变量的类型信息后，获得的是一个reflect.Type类型，并且如果它的类型是结构体，那么就可以通过reflect.Type这个类型的NumFileld()和Field()方法获得该结构体成员的详细信息 reflect.Type中获取结构体成员相关的方法如下表： 方法 方法作用 Field(i int) StructFiled 根据索引，返回索引对应的结构体字段的信息 NumFiled() int 返回结构体成员的字段数量 FileldByName(name string)(StructField, bool) 根据给定字符串，返回该字符串对应的结构体字段的信息 FileldByIndex(index []int) StructField 多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的信息 FieldByNameFunc(match func(string) bool) (StructField， bool) 根据传入的匹配函数匹配需要的字段 NumMethod() int 返回该类型的方法，方法的数目 Method(int) Method 返回该类型方法其中的第i个方法 MethodByName(string) (Method, bool) 根据方法名返回该方法中的方法 4.2. StructField类型 StructField类型用来描述结构体中一个字段的信息 StructField定义： type StructField struct { // Name is the field name. Name string // 字段的名字 // PkgPath is the package path that qualifies a lower case (unexported) // field name. It is empty for upper case (exported) field names. // See https://golang.org/ref/spec#Uniqueness_of_identifiers PkgPath string // 非导出字段的包路径 Type Type // field type字段类型 Tag StructTag // field tag string 字段标签 Offset uintptr // offset within struct, in bytes 字段在结构体中的字节偏移量 Index []int // index sequence for Type.FieldByIndex 用于Type.FieldByIndex时的索引切片 Anonymous bool // is an embedded field 是否是匿名字段 } 4.3. 结构体反射示例 使用反射得到一个结构体的数据之后，可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息 e.g. package main import ( \"fmt\" \"reflect\" ) // 定义一个结构体 type student struct { Name string `json:\"name\"` Score int `json:\"score\"` } func main() { // 实例化一个结构体 s1 := student{ Name: \"wang\", Score: 88, } // 获取s1的类型，得到一个reflect.Type类型 t := reflect.TypeOf(s1) // 打印t的type name和kind name fmt.Println(t.Name(), t.Kind()) // student struct // 通过for遍历结构体中所有的字段信息,通过索引获取字段信息 for i := 0; i 示例2：编写一个函数printMethod(a interface{})，实现打印a变量所拥有的方法， package main import ( \"fmt\" \"reflect\" ) // 定义一个结构体 type student struct { Name string `json:\"name\"` Score int `json:\"score\"` } // 给student结构体添加2个方法，注意：首字母大写，才能被reflect包内的函数所访问 func (s student) Study() string { msg := \"好好学习\" fmt.Println(msg) return msg } func (s student) Sleep() string { msg := \"早睡早起\" fmt.Println(msg) return msg } func printMethod(x interface{}) { // 获得x的reflect.Type类型和reflect.Value类型 typeX := reflect.TypeOf(x) valueX := reflect.ValueOf(x) // 获得x变量的方法数 fmt.Println(typeX.NumMethod()) for i := 0; i 5. 反射的利与弊 反射是一把双刃剑，能让我们写出更灵活的代码，但不能滥用反射： 基于反射的代码很脆弱，反射中的类型错误会在运行中引发panic，（可能在写完代码后很长时间才发现 大量使用反射的代码，通常难以理解 反射的性能低下，基于反射实现的代码，通常比正常代码运行速度慢一到2个数量级 6. 练习题 编写代码，利用反射实现一个init配置文件的解析器 ini配置文件示例 [mysql] address = 192.168.80.100 port = 3306 username = root password = linux ;注释行 将ini中内容解析到下方的结构体 // 定义一个Config 配置文件的结构体，可以嵌套多个结构体， // 如可以嵌套mysql redis pgsql 等 type Config struct { MysqlCfg `ini:\"mysql` // RedisCfg ...还可以嵌套其他的配置段，如redis } // 与mysql配置段对应的mysql配置的结构体， type MysqlCfg struct { Address string `ini:\"address` Port int `ini:\"port\"` Username string `ini:\"username` Password string `ini:\"password\"` } 6.1. 思路分析 打开ini结尾的配置文件 按照行读取 解析每一行的内容，解析逻辑：把每一行读取的配置信息，和结构体中字段在ini中的tag进行匹配，匹配到就放到对应的结构体字段当中 ini配置文件中，行的特征分类 [mysql]中括号包围的节，表示一个为一个小节配置的开始 key = value ，一个个键和值组成的具体配置信息 空行 注释 不规范的行如：[mysql少了括号，行内有非法字符等 6.2. 具体代码 package main /* 一个mysql配置段示例 [mysql] address = 192.168.80.100 port = 3306 username = root password = linux ; 注释行 [redis [] database 15 =value key= （像上面几行，注释行、空行、小节行中括号不完整或中括号中没有内容、配置行没有等号、配置行有等号但是缺少了key或value信息，都是要程序中先处理掉的） */ import ( \"errors\" \"fmt\" \"io/ioutil\" \"reflect\" \"strconv\" \"strings\" ) // Config 配置文件结构体 type Config struct { MysqlConfig `ini:\"mysql\"` } // MysqlConfig MySQL配置结构体 type MysqlConfig struct { Address string `ini:\"address\"` Port int `ini:\"port\"` Username string `ini:\"username\"` Password string `ini:\"password\"` } func loadIni(fileName string, data interface{}) (err error) { // 代码逻辑分析： // fileName要读取的配置文件名 // data是Config结构体的一个变量指针，即*Config // 0.先判断data是不是传入的结构体指针，以及其嵌套的是不是也是结构体 // 1.根据传入的文件名，打开对应ini配置文件 // 2.利用ioutil读取每一行 // 3.对每一行进行处理，解析出配置信息，放置到对应的结构体中 // 先截取出每一行，然后遍历每行 // 先去除每行开头和结尾的空格 // 去除空行 // 去除注释行 // 此时的ini处理结果 /* [mysql] address = 192.168.80.100 port = 3306 username = root password = linux [redis [] database 15 =value key= */ // 如果行以\"[\"开头——if // 先去除不规范的小节行，如上面的[redis和[] // 这时：小节行都剩下规范的 // 假设此时处理的行是[mysql]，那么，如何将它和Config结构体中嵌套的MysqlCfg关联起来呢？利用反射! // 获取data的reflect.TypeOf t, // 遍历t的NumFiled()，即拿出Config的每一个字段的tag和mysql（用变量sectionName存储）进行比较，（假设Config还有其他嵌套结构体如redis，pqsql等 // 匹配到Config中的MysqlCfg字段时，就记录下该结构体的名字，此处为MysqlCfg（用变量structName存储 // 之后，该行就处理完了！进行下次循环，读取的就该是mysql这个小节下的各个配置信息，进入到下面的else // 如果行不以\"[\"开头——else // 先去除不规范的配置行，如上面的=value 、key= 、 database 15 // 这时，配置行都剩下规范的 // 上面匹配好mysql小节和MysqlCfg这个嵌套的结构体之后，读取mysql下面的行时，就进入了下面的逻辑 // 先用strings包，切出来key和value，就比如address和192.168.80.100 // （利用反射）然后拿MysqlCfg这个结构体的每个字段和address比较，对上了，就把192.168.80.100存入到MysqlCfg这个结构体的Address字段的值中！ var sectionName string // 节点名称 var structName string // 结构体名字 // 参数校验： // 传入的data参数是否是一个结构体指针类型（要对结构体进行字段填充） t := reflect.TypeOf(data) // 判断是否是指针 if t.Kind() != reflect.Ptr { err = errors.New(\"data should be a pointer\") return err } // 判断是否是结构体指针 if t.Elem().Kind() != reflect.Struct { err = errors.New(\"data should be a Struct pointer\") return err } // 1.读文件，得到字节类型的数据,转换为字符串 b, err := ioutil.ReadFile(fileName) if err != nil { return } lineSlice := strings.Split(string(b), \"\\n\") // 2 一行一行读数据，如果是注释就忽略 // 3 一行一行读数据，如果是[开头的则代表是一个节点 // 4 一行一行读数据，如不不是[开头的就是=号分割的键值对 for idex, line := range lineSlice { // 去空格 line = strings.TrimSpace(line) // 过滤空行 if len(line) == 0 { continue } // 这是注释 if strings.HasPrefix(line, \";\") { continue } // 这是[开头的节点 if strings.HasPrefix(line, \"[\") { // 不合格的节点 if line[0] != '[' || line[len(line)-1] != ']' { err = fmt.Errorf(\"line:%d syntax error\", idex+1) return err } // []里没有内容 sectionName = strings.TrimSpace(line[1:(len(line) - 1)]) if len(sectionName) == 0 { err = fmt.Errorf(\"line:%d syntax error\", idex+1) return err } // v := reflect.ValueOf(data) // 根据sectionName找结构体 for i := 0; i 6.3. 运行结果 $ ./tmp.exe 找到mysql对应的嵌套结构体MysqlConfig {{192.168.80.100 3306 root linux}} latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.14go基础语法之并发.html":{"url":"1-go基础语法/1.14go基础语法之并发.html","title":"1.14go基础语法之并发","keywords":"","body":"1. 并发与并行2. goroutine2.1. 使用goroutine2.2. 启动单个goroutine2.3. 启动多个goroutine3. goroutine与线程3.1. 可增长的栈3.2. goroutine调度3.3. GOMAXPROCS4. channel4.1. channel类型4.2. 创建channel4.3. channel操作4.4. 无缓冲的通道4.5. 有缓冲的通道4.6. for range从通道循环取值4.7. 单向通道4.8. 通道总结5. worker pool(goroutine池)6. select多路复用7. 并发安全和锁7.1. 互斥锁7.2. 读写互斥锁7.3. sync.WaitGroup7.4. sync.Once7.5. sync.Map8. 原子操作8.1. atomic包8.2. 示例9. 练习题9.1. 练习19.2. 练习21. 并发与并行 Golang语言层面即支持并发 并发：同一个时间段内执行多个任务（“单核心情况下“，在同一个时间段，在多个任务之间切换，从宏观一段时间上来看，就像是这些任务在同时进行；但是！同一个时间点，只能执行一个任务 并行：同一个时刻执行多个任务（需要有多个处理“核心”，每个处理核心都处理任务，可以在同一个时刻/时间点，同时进行 Golang的并发通过goroutine实现，goroutine类似线程，属于用户态的线程，根据需要，可以创建成千上万个goroutine进行并发工作，goroutine是由go语言的运行时runtime调度完成，而线程是由操作系统调度完成 go提供了channel在多个goroutine间进行通信，goroutine和channel是go秉承的CSP（communication sequential process）并发模式的重要实现基础 2. goroutine java/c++中，我们需要实现并发的时候，通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需自己去调度线程执行任务并维护上下文切换，比较耗费心智，而golang提供了一种机制：程序员只需要定义很多个任务，让go的运行时去帮助程序员把这些任务分配到cpu上实现并发执行，即go的goroutine。 goroutine的概念类似于线程，但goroutine是由go的运行时runtime调度和管理的，go程序会智能地把goroutine中任务合理分配给每个cpu。 go在语言层面，内置了调度和上下文切换 go编程中，你不需要去自己写进程、线程、协程，当需要让某个任务并发执行的时候，只需要把任务包装成一个函数，加个go关键字，开启一个goroutine去执行这个函数就行了。 2.1. 使用goroutine go语言中，使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine 一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数 2.2. 启动单个goroutine 启动goroutine，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字 e.g. 下例中，hello（）函数和下方的打印是串行， package main import \"fmt\" func hello() { fmt.Println(\"this is hello func\") } func main() { hello() fmt.Println(\"this is main func\") } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/18goroutine (master) $ go run main.go this is hello func this is main func 利用goroutine启动函数 在调用hello()函数前，加一个go就可以了，但是输出中只输出了一句this is main func 没有输出hello函数中的内容，原因是启动一个goroutine会耗费一点时间，但此时代码会继续向下执行，打印下方的内容，之后main函数就会退出，main含数一退出，其内部启动的所有goroutine都会被停掉， package main import \"fmt\" func hello() { fmt.Println(\"this is hello func\") } func main() { go hello() fmt.Println(\"this is main func\") } $ go run main.go this is main func 解决方法：打印后sleep个几秒，给goroutine内部的函数有充足的时间执行 可以看到，先打印了main，才打印了hello，（因为启动goroutine去执行hello需要一定时间 package main import ( \"fmt\" \"time\" ) func hello() { fmt.Println(\"this is hello func\") } func main() { go hello() fmt.Println(\"this is main func\") time.Sleep(time.Second) } $ go run main.go this is main func this is hello func 2.3. 启动多个goroutine 发现，每次执行结果不一样，因为多个goroutine并发执行，每次的调度顺序都一定完全一样，所以打印10个数字的顺序几乎每次不同 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func hello(a int) { // 注册一个操作，函数退出前，记得关闭goroutine，wg.Add加了几个，往往就需要关闭几个 defer wg.Done() fmt.Println(a) } func main() { for i := 0; i 3. goroutine与线程 3.1. 可增长的栈 os的线程即操作系统的线程，一般都有固定的栈内存（通常是2MB，而一个goroutine线程在其生命周期开始时，其栈大小通常只有2KB，而且其栈大小可以根据需要动态的调整，其最大栈大小可以达到1GB，（因此go中一次型创建10万左右的goroutine也是可以的 3.2. goroutine调度 goroutine是go运行时管理的用户态的线程，其本质还是要靠os的线程来实际运行，一个os线程对应多个用户态的goroutine，goroutine之间的调度切换，是在用户态完成，不需要用户态和内核态之间切换，（因此较为轻量） GPM就是实现goroutine调度的系统： G就是值goroutine，里面存放了goroutine本身的信息，还有所在绑定P的信息 P管理着一组goroutine，P里面会存储当前goroutine的上下文信息（函数指针、堆栈地址、地址边界）P会对自己管理的goroutine进行调度（比如将占用cpu时间长的goroutine暂停，运行后续的goroutine）当自己队列消费完了就去全局队列取，如果全局队列消费完了就是其他P的队列里抢任务 M（machine）是go运行时对操作系统内核线程的虚拟，M和内核线程一般是一一对应的关系，一个goroutine最终要放到M上执行的 P和M一般也是一一对应，关系是：P管理着一组G，挂到一个M上，这组G都由这个M实际来负责运行，（即由这个M对应的cpu核心来执行？）当某个G阻塞到了M上，P就会新建一个M，并其组内其他G迁移到新的M上，而等到阻塞的G完成或者认为完成不了把它退出时，回收旧的M P的个数是通过runtime.GOMAXPROCS设定，最大是256，go1.5版本后默认是物理线程数，并发量大的时候可以适当增加一些P和M，但加太多就得不偿失，因为底层就这么多cpu核心，加多了还不是得让cpu核心做上下文切换，反而拖慢了 单从线程调度来讲，go相比其他语言的优势是在于os线程是有内核调度，而go的goroutine是由go运行时调度，调度器采用m:n调度，即把m的goroutine调度到n个os线程上，全部在用户态，上下文切换的成本小，**不涉及内核态用户态的频繁切换，内存池由用户态维护，几乎是平均的把若干goroutine调度到多个cpu核心，充分利用了多核cpu硬件优势 如下图示： （不一定对，先这么理解 拓展阅读 3.3. GOMAXPROCS go运行时可以通过GOMAXPROCS参数设定启用多少个os线程来运行go代码，默认值是机器的cpu核心数，例如一个8核心服务器，默认就是启用8个os线程，（m：n中的n是8） 通过runtime.GOMAXPROCE()函数可以设置当前程序并发时占用了cpu核心数 go1.5之前，默认用单核心，go1.5之后，默认使用全部的逻辑核心数 例1：2个goroutine只用一个核心 可以看到，先执行完b的goroutine之后，再执行的a的goroutine，（虽然一个核心，但也应该交叉调度运行，但因为10比较小，几乎不用调度，先执行一个，再执行后一个，实验中，10加到10000时，即便是单核心，也会交叉运行输出） package main import ( \"fmt\" \"runtime\" \"time\" ) func a() { for i := 0; i 例2: 2个goroutine用2个核心 可以看到，虽然10比较小，但是仍然是交叉输出，因为有2个核，可以同时跑a和b的goroutine package main import ( \"fmt\" \"runtime\" \"time\" ) func a() { for i := 0; i 操作系统线程和goroutine的关系 goroutine和os线程是m：n的关系 go程序可以同时刻，使用多个os线程，即多个cpu核心 一个os线程，对应多个用户态的goroutine 4. channel 单纯的将函数并发执行并无意义，函数与函数之间，还需要进行通信，即数据交换，go中利用channel实现并发函数之间的通信 实现进程间通信的方法可以通过共享内存实现，但是共享内存去通信，多个进程同时访问同一块内存的时候，会出现竞争，这时需要加锁，这就造成了性能上的低下， 而go中，提倡通过通信而共享内存，而不是通过共享内存实现通信：通过CSP（communicating sequential process)并发模型实现，通过channel，实现一个goroutine向另一个goroutine发送数据，channel就像是一个管道或者传递带，你在这头发，我在那头取 channel遵从先进先出的规则，里面可以存储各种类型的数据 4.1. channel类型 channel的类型决定了它能传输什么样的数据 channel是一种类型，一种引用类型，声明格式： var 变量名 chan 元素类型 // 例子 var ch1 chan int var ch2 chan string var ch3 chan []int // 上面3个通道变量，分别用于传输 int string []int类型的数据 4.2. 创建channel channel是引用类型，所以其空值是nil package main import \"fmt\" func main() { var ch1 chan int fmt.Println(ch1) // 是nil } $ go run main.go 只声明不行，还得用make初始化后才能使用 // 语法： make(chan 通道内存放的数据类型 , [通道的缓冲区大小,可选]) ch2 := make(chan int, 10) ch3 := make(chan string) ch4 := make(chan bool, 9) 4.3. channel操作 channel具有发送、接收、关闭三种操作，发送接收都用表示 先定义一个通道 ch := make(chan int) 发送 ch 接收 x := 关闭 关闭通道就是相当于把通道的入口关闭了，但是出口没关 close(ch) // 调用内置的close方法，关闭即可 和文件操作不同的是，文件打开后必须关闭，而通道则不是必须关闭，其可以被垃圾回收机制回收 已经关闭通道的特点 入口关闭了，再向该通道内传值会引发panic 出口没关闭，可以从该通道内继续接收值，直到通道内数据被取完，即通道变空 从一个关闭的通道，且已经取完了数据的通道，继续接收值，不会panic，只是会收到对应类型的零值 已经关闭的通道，再关闭一次，会引发panic 4.4. 无缓冲的通道 无缓冲的通道，又称为阻塞的通道 例子：编译能通过，但是运行会爆出死锁 package main func main() { ch1 := make(chan int) ch1 上例的原因是：没有缓冲区的通道，发送值的时候，必须有一方在通道另一边接着，不然发送方就一直等，直到卡死，爆出死锁（好比小区没有快递柜，快递员送快递时，必须等你到了，把快递交到你手上） 解决上例子的问题： // 启用一个goroutine来从通道收值 package main import ( \"fmt\" \"time\" ) func recv(c chan int) { ret := 使用无缓冲的通道进行通信，会使得通道2端的发送goroutine和接收goroutine同步化，因此无缓冲通道又被称为同步通道 4.5. 有缓冲的通道 有缓冲的通道，就是初始化时，给通道申请至少一个单位的空间， 有缓冲的通道也会阻塞，即通道中空间放满了数据，还没被取走，此时再放值就会阻塞 package main import \"fmt\" func main() { ch1 := make(chan int, 1) ch1 len可以获取通道内元素的数量，cap可以获取通道的总容量 4.6. for range从通道循环取值 for range 从通道遍历值的时候，当遍历的通道关闭，就会自动退出for range package main import \"fmt\" func main() { // 声明2个无缓冲的通道 ch1 := make(chan int) ch2 := make(chan int) // 开一个goroutine 一个匿名函数，作为立即执行函数，向ch1中放入1到10的值 go func() { for i := 0; i 4.7. 单向通道 在函数中，经常需要将一个通道，作为传参，在多个功能函数内部使用，为了安全考虑，可以定义将一个通道传递到一个函数中时，限制该函数内部可以对该通道执行的操作，可以将通道定义为单向通道，即函数内部只能对这个通道进行只发或只收操作 改造上面的例子 package main import \"fmt\" func send(ch chan chan 函数传参的时候，双向通道可以改成单向通道，反之不可以 4.8. 通道总结 关闭一个已经关闭的通道会panic 5. worker pool(goroutine池) 工作中，常常利用worker pool模式，即goroutine池，来限制goroutine的数量，防止goroutine的暴涨或泄漏 e.g. package main import ( \"fmt\" \"sync\" \"time\" ) // worker pool var wg sync.WaitGroup func worker(id int, ch1 6. select多路复用 当通道中没有值的时候，从通道中接收值会一直阻塞，直到通道中再次有值，对于同时从多个通道接收值的情况，可以采用如下循环：通过判断ok的值，确定是否继续接收 for { v , ok := 但上述方式，性能较差，因此go提供了select关键字，可以同时响应多个通道的操作，收或发都可以 select类似于switch操作，有一系列case分支和一个默认分支：每个case分支都有对应一个通道的操作，收或发，当某个case分支的通道的收或发的操作满足时，就会执行该case下的语句，当多个case同时满足时，就随机选择一个case执行 语法： select { case e.g. package main import ( \"fmt\" ) func main() { ch1 := make(chan int, 1) for i := 0; i select语句可以挺高代码的可读性 可以处理一个或多个channel的发送或接收操作 多个case同时满足，会随机选择一个 没有case的select{}会一直等待，可用于阻塞main函数 7. 并发安全和锁 多个goroutine执行同一个函数，而函数中又涉及到了一个函数外部的变量，此时由于goroutine是并发执行，当多个goroutine操作同一个变量时，就一般会发生数据竞争，造成结果的不确定性 下例中， package main import ( \"fmt\" \"sync\" ) var x int64 var wg sync.WaitGroup func add() { defer wg.Done() for i := 0; i 7.1. 互斥锁 互斥锁，又叫读写互斥锁，用sync的Mutex表示，当多个goroutine操作同一个变量时，需要先申请一个锁，然后才可以对数据进行操作，操作期间，其他goroutine不能读，也不能写，只有这个goroutine完事了，释放锁，其他goroutine才能申请锁，然后对变量进行操作，（多个goroutine同时等待一个锁的时候，被唤醒是随机选择的 好比，你上公共厕所，锁上门后，别人不能跟你一起上（写），也不能看着你上（读）有画面了:laughing: 用锁，修正上面的代码 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup var x int // 默认是0 // 声明一个互斥锁 var lock sync.Mutex func add() { defer wg.Done() for i := 0; i 7.2. 读写互斥锁 互斥锁是读写完全互斥的，即即使不修改数据，并发的读也不能实现，需得一个个申请锁；但是：很多场景，都是读多写少，因此互斥锁会拖慢效率，因此引入读写互斥锁 读写互斥锁分2种，读锁，申请读锁时，后续其他人也可以申请读锁，继续读，但某人有个写锁后，其他后续的读或写都得等待（因为写期间导致数据修改，这时读会读到不确定的数据 示例： package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup var x int // 默认是0 var lock sync.Mutex var rwlock sync.RWMutex func read() { defer wg.Done() // lock.Lock() rwlock.RLock() // 加读锁 time.Sleep(time.Microsecond) // 模拟读耗费1毫秒 rwlock.RUnlock() // 释放读锁 // lock.Unlock() } func write() { defer wg.Done() // lock.Lock() rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(time.Microsecond * 3) // 模拟写话费3毫秒 rwlock.Unlock() // 释放写锁 // lock.Unlock() } func main() { start := time.Now() for i := 0; i 可以看到，互斥锁花的时间比读写互斥锁要多很多，读写比，越大，效果越明显，读写比相近时，差别不大； 7.3. sync.WaitGroup sync.WaitGroup可以确定多个并发任务结束的时间，而不是用sleep，因为你无法准确预估并发goroutine结束时间， 使用步骤： var wg sync.WaitGroup 实例化一个sync.WaitGroup 每启动一个goroutine之前，就wg.Add(1) 表示注册一个goroutine，计数器加一 每个goroutine要执行的函数，都加一个defer wg.Done()表示结束该goroutine，计数器减一 wg.Wait()等到计数器减为0，才继续向下执行，减为0前代码为阻塞状态 sync.WaitGroup具有的方法 方法名 作用 func (wg *WaitGroup) Add(delta int) 计数器加delta func (wg *WaitGroup) Done() 计数器减一 func (wg *WaitGroup) Wait() 阻塞直到计数器归0 type WaitGroup struct { noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema. state1 [3]uint32 } 是个结构体， 7.4. sync.Once 启动多个goroutine执行同一个函数时，因为同一个函数，代码块相同，若其中存在加载文件、关闭文件、关闭通道，这些语句，那么在并发执行这个函数时，就是并发不安全的，因为“通道只能关闭一次”这些原因 于是go提供了sync.Once使得这些函数并发执行时，这些代码只执行一次 sync.Once只有一个方法 func (o *Once) Do(f func()) { } // 参数是无传参，无返回值的函数，若需要传递参数，则可以利用闭包实现 并发安全的单例模式 package singleton import \"sync\" type singleton struct {} var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = &singleton{} }) return instance } sync.Once内部包含一个互斥锁和一个布尔值，布尔值用于记录是否被执行过一次 7.5. sync.Map go内置的map不是并发安全的， 看下例 package main import ( \"fmt\" \"strconv\" \"sync\" ) var wg sync.WaitGroup var m = make(map[string]int) func get(key string) int { return m[key] } func set(k string, v int) { m[k] = v } func main() { for i := 0; i 内置的sync.Map 原生支持并发的map，并不需要make初始化，声明即用，且内置了Store Load LoadOrStore Delete Range等方法 package main import ( \"fmt\" \"strconv\" \"sync\" ) var wg sync.WaitGroup var m = sync.Map{} // 声明 func main() { for i := 0; i 8. 原子操作 加锁操作，涉及了内核态和用户态的切换，消耗较高，因此针对基本数据类型go提供了原子操作保证并发安全，且是在用户态完成，性能比加锁更好， 由sync/atomic提供 8.1. atomic包 8.2. 示例 比较互斥锁和原子操作的性能 不加锁，并发不安全 用互斥锁实现并发安全，性能较低 用原子操作实现并发安全，性能较高（并发数量较大时， package main import ( \"fmt\" \"sync\" \"sync/atomic\" \"time\" ) type Counter interface { Inc() Load() int64 } // 普通版 type CommonCounter struct { counter int64 } func (c CommonCounter) Inc() { c.counter++ } func (c CommonCounter) Load() int64 { return c.counter } // 互斥锁版 type MutexCounter struct { counter int64 lock sync.Mutex } func (m *MutexCounter) Inc() { m.lock.Lock() defer m.lock.Unlock() m.counter++ } func (m *MutexCounter) Load() int64 { m.lock.Lock() defer m.lock.Unlock() return m.counter } // 原子操作版 type AtomicCounter struct { counter int64 } func (a *AtomicCounter) Inc() { atomic.AddInt64(&a.counter, 1) } func (a *AtomicCounter) Load() int64 { return atomic.LoadInt64(&a.counter) } func test(c Counter) { var wg sync.WaitGroup start := time.Now() for i := 0; i 9. 练习题 使用goroutine和channel实现一个计算int64随机数各位数和的程序。 开启一个goroutine循环生成int64类型的随机数，发送到jobChan 开启24个goroutine从jobChan中取出随机数计算各位数的和，将结果发送到resultChan 主goroutine从resultChan取出结果并打印到终端输出 为了保证业务代码的执行性能将之前写的日志库改写为异步记录日志方式。 9.1. 练习1 使用goroutine和channel实现一个计算int64随机数各位数和的程序。 开启一个goroutine循环生成int64类型的随机数，发送到jobChan 开启24个goroutine从jobChan中取出随机数计算各位数的和，将结果发送到resultChan 主goroutine从resultChan取出结果并打印到终端输出 package main import ( \"fmt\" \"math/rand\" \"sync\" ) /* 1,定义2个channel ：jobChan和resChan 2，produceJob 函数，利用rand生成int64位的随机数，放到jobChan（开启1个goroutine执行 3，customJob 函数，从jobChan中接收数据，利用取余法，获得各个位数的值，相加后放到resChan中（开通24个goroutine执行 4，利用wg.Wait()等待2个goroutine全部完成后，从resChan中便利结果打印即可 */ // 声明2个jobChan var wg sync.WaitGroup // produceJob 生成10个随机数，并到jobChan中 func produceJob(job chan 0 { sum = int(num%10) + sum num = num / 10 } res 9.2. 练习2 为了保证业务代码的执行性能将之前写的日志库改写为异步记录日志方式。 package mylogger import ( \"fmt\" \"os\" \"path/filepath\" \"time\" ) /* 该file.go文件需要实现的代码 1. filelogger结构体 包含： 日志文件路径 文件名 文件切割时的大小，即日志文件最大能达到的大小 日志级别LogLevel类型 一个普通日志文件对象 一个错误日志文件对象，（单独记录一份错误日志） （文件名包含2个，一个记录所有日志，一个记录error级别以上的错误日志） 2. filelogger结构体的构造函数 返回fileLogger的指针类型 3. 6个日志级别的记录方法，接受者是指针类型的filelogger 4. log函数 负责实现记录日志的函数，由上面6个日志级别的记录方法调用 5. isEnable函数，判断是否记录该级别的日志，由负责实际记录日志的函数调用 6. checkSize函数 记录日志时，根据当前日志文件的大小，判断是否需要进行日志文件的轮替，即日志切割 7. splitFile函数 若经过了checkSize函数的检查，需要进行日志切割的时候，则调用split函数进行日志文件的切割 8. initFile函数 被filelogger的构造函数调用，进行日志文件的初始打开工作，得到普通日志文件，错误日志文件的2个文件对象，从而得到一个完整的filelogger实例 9. 总结一下，该文件的代码逻辑： 其他代码先import该库； 通过fileLogger的构造函数，传入需要的参数，假设传入的日志级别为INFO， 再调用initFile函数，得到2个文件对象 得到一个filelogger的实例，如f1 需要记录某级别的一条日志时，就调用该实例的对于级别方法，如f1.WARNING 进入到INFO方法内部： 直接将参数传给log，调用log函数，进入log函数内部： 先调用isEnable函数，判断是否记录该级别日志，warning大于info，进行记录； 然后记录前，调用checkSize函数： 判断当前日志文件大小是否超出了定义了日志文件最大值 大于，就调用splitFile函数，进行日志切割 小于，就直接进行日志记录 然后，判断该级别是不是大于等于ERROR级别 大于，则单独记录一份日志到错误日志文件 先checkSize判断错误日志文件的大小， 超过最大值就调用split进行文件切割 不超过，就直接进行日志记录 不是，则不进行任务记录 至此，完成了一条日志的记录 */ /* 利用goroutine和channel改写，实现异步方式写日志 思路： 0，构造一个通道，构造一个日志消息的结构体，通道的类型是这个日志消息结构体的指针类型 1，何时开启，日志写入通道的goroutine 调用DEBUG TRACE INFO ...这6个记录不同级别日志的方法时，其实是调用了f.recordLog(DEBUG, format, args...)，这个函数去记录日志，（原来的方式是同步写日志，一条日志的记录会走遍所有的函数，效率较低） 改造f.recordLog函数，在这个函数内部，把要写的日志信息放到日志通道中； 2，何时开启，日志消费goroutine 在初始化一个FileLogger实例的时候，就开启一个goroutine，新增一个日志消费函数，writeLogBackGround放在这个goroutine中执行 */ // FileLogger ... type FileLogger struct { level LogLevel filedir string filename string errfilename string maxsize int64 fileObj *os.File errfileObj *os.File logmsg chan *logInfo // 新加一个 通道，通道类型是存放logInfo结构体的指针 } // 改造：新加一个日志消息结构体 type logInfo struct { now string loglevel LogLevel funName string fileName string lineNo int msg string // now, loglevel, funName, fileName, lineNo, msg } // NewFileLogger 构造一个FileLogger实例 func NewFileLogger(lv string, filedir string, filename, errfilename string, maxsize int64) *FileLogger { loglevel, err := parseLogLevel(lv) if err != nil { panic(err) } f := &FileLogger{ level: loglevel, filedir: filedir, filename: filename, errfilename: errfilename, maxsize: maxsize, logmsg: make(chan *logInfo, 5000), // 实例化FileLogger时，就申请开辟一个5000大小的通道 } // fileObj, err := f.initFile(filedir, filename) // errfileObj, err := f.initFile(filedir, errfilename) // f.FileObj = fileObj // f.errfileObj = errfileObj err = f.initFile() // 调用initFile方法，打开2个文件，获得2个文件对象，构成一个完整的fileLogger实例 if err != nil { panic(err) } return f } func (f *FileLogger) isEnable(lv LogLevel) bool { if lv >= f.level { return true } else { return false } } func (f *FileLogger) checkSize(fileObj *os.File) bool { // 获得传入文件的大小信息，并和f.maxsize比较 fileInfo, err := fileObj.Stat() if err != nil { fmt.Printf(\"get file info failed,err : %v\\n\", err) return false } if fileInfo.Size() >= f.maxsize { return true } else { return false } } // splitFile 该函数，接收一个文件对象，然后获取当前时间戳，将接收的文件对象加一个时间戳后缀，然后关闭它，重命名它，然后再开一个和接收的文件对象同名的文件对象，并作为返回值返回 func (f *FileLogger) splitFile(file *os.File) (*os.File, error) { fileInfo, err := file.Stat() fileName := fileInfo.Name() nowSuffix := time.Now().Format(\"20060102150405000\") // 关闭老的 file.Close() // 重命名老的 // os.Rename(fileName, fileName+\"now\") fullname := filepath.Join(f.filedir, fileName) os.Rename(fullname, fullname+nowSuffix) // 打开一个和老的文件，同名的，新文件 newfileObj, err := os.OpenFile(fullname, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Printf(\"open new file failed when split file, err:%v\\n\", err) return nil, err } return newfileObj, nil } // 改造：writeLogBackGround func (f *FileLogger) writeLogBackGround() { // 放在goroutine中，利用无限循环从通道中取日志，再向文件中写日志 for { if f.checkSize(f.fileObj) { newfileObj, err := f.splitFile(f.fileObj) if err != nil { fmt.Println(err) } f.fileObj = newfileObj } select { case alog := = ERROR { if f.checkSize(f.errfileObj) { newfileObj, err := f.splitFile(f.errfileObj) if err != nil { fmt.Println(err) } f.errfileObj = newfileObj } fmt.Fprintf(f.errfileObj, \"[%s] [%s] [%s:%s:%d] [%s]\\n\", alog.now, getLogString(alog.loglevel), alog.funName, alog.fileName, alog.lineNo, alog.msg) } default: // 若上面的分支不满足，即通道中没日志了，执行default分支，休息500毫秒 time.Sleep(time.Microsecond * 500) } } } // recordLog ... func (f *FileLogger) recordLog(lv LogLevel, format string, args ...interface{}) { // 将这个函数改成，负责构造日志消息的结构体实例，然后放到日志通道中 // type logInfo struct { // now string // loglevel LogLevel // funName string // fileName string // lineNo string // msg string // // now, loglevel, funName, fileName, lineNo, msg // } if f.isEnable(lv) { msg := fmt.Sprintf(format, args...) time := time.Now().Format(\"2006-01-02 15:04:05.000\") funName, fileName, lineNo := getCodeInfo(3) // 本层向外三层代码的信息 alog := &logInfo{ now: time, loglevel: lv, funName: funName, fileName: fileName, lineNo: lineNo, msg: msg, } select { case f.logmsg = ERROR { // // 记录前，先判断errorlog文件的大小 // if f.checkSize(f.errfileObj) { // newfileObj, err := f.splitFile(f.errfileObj) // if err != nil { // fmt.Println(err) // } // f.errfileObj = newfileObj // } // // 不需要切割，或切割后生成了新文件，继续下面的逻辑，记录错误日志 // fmt.Fprintf(f.errfileObj, \"[%s] [%s] [%s:%s:%d] [%s]\\n\", now, LevelStr, funName, fileName, lineNo, msg) // } // } } // DEBUG ... func (f *FileLogger) DEBUG(format string, args ...interface{}) { f.recordLog(DEBUG, format, args...) } // TRACE ... func (f *FileLogger) TRACE(format string, args ...interface{}) { f.recordLog(TRACE, format, args...) } // INFO ... func (f *FileLogger) INFO(format string, args ...interface{}) { f.recordLog(INFO, format, args...) } // WARNING ... func (f *FileLogger) WARNING(format string, args ...interface{}) { f.recordLog(WARNING, format, args...) } // ERROR ... func (f *FileLogger) ERROR(format string, args ...interface{}) { f.recordLog(ERROR, format, args...) } // FATAL ... func (f *FileLogger) FATAL(format string, args ...interface{}) { f.recordLog(FATAL, format, args...) } // initFile filelogger的方法，打开文件，获得文件对象，构成一个完整的filelogger对象 // 改进后，都是filelogger的方法了，（当然不需要再传递该结构体的字段值了，直接用 func (f *FileLogger) initFile() error { fullfilename := filepath.Join(f.filedir, f.filename) fileObj, err := os.OpenFile(fullfilename+\".log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return err } f.fileObj = fileObj fullerrfilename := filepath.Join(f.filedir, f.errfilename) errfileObj, err := os.OpenFile(fullerrfilename+\".log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return err } f.errfileObj = errfileObj go f.writeLogBackGround() // 实例化Fileloger时会调用initFile打开2个日志文件，顺便在这里，就开启后台写日志的函数，放在goroutine中执行，（等待从日志通道中取出一条条日志信息，写到日志文件中 return nil } // func (f *FileLogger) initFile(filedir, filename string) (*os.File, error) { // fullfilename := filepath.Join(filedir, filename) // fileObj, err := os.OpenFile(fullfilename+\".log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) // if err != nil { // fmt.Printf(\"open file:%s failed, err:%v\\n\", filename, err) // newerr := errors.New(\"open file failed\") // return nil, newerr // } // return fileObj, err // } latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.15go基础语法之网络编程.html":{"url":"1-go基础语法/1.15go基础语法之网络编程.html","title":"1.15go基础语法之网络编程","keywords":"","body":"1. socket编程1.1. socket图解1.2. go实现tcp通信1.2.1. tcp协议1.2.2. tcp服务端1.2.3. tcp客户端1.3. tcp粘包1.3.1. 粘包示例1.3.2. 出现粘包的原因1.3.3. 解决方法1.4. go实现udp通信1.4.1. udp协议1.4.2. udp服务端1.4.3. udp客户端1. socket编程 socket是bsd unix中的进程间通信机制，也叫做“套接字”，用于描述ip地址和端口，是一个通信的句柄，socket可以理解为tcp/ip的api，其定义了很多函数，程序员可以通过它们开发tcp/ip网络的应用程序，**应用层应用程序通过socket向网络中的机器发送请求或从中接收来自网络中其他机器的网络请求 1.1. socket图解 socket是应用层与tcp/ip协议族中间的软件抽象层，在设计模式中，socket其实就是一个门面模式，负责把tcp/ip协议族的细节隐藏在socket之后，程序员只需要调用socket规定的函数，就可以让socket取管理后面复杂的tcp/ip协议，进行通信 1.2. go实现tcp通信 1.2.1. tcp协议 tcp 传输控制协议，是一种面向连接的、可靠的、具有流控的传输层协议 1.2.2. tcp服务端 一个tcp服务端可以同时连接很多个客户端，利用多个用户同时访问淘宝，而go中利用创建多个goroutine实现并发，在服务端，可以每过来一个连接请求，就创建一个goroutine去处理 tcp服务端处理请求的过程： 监听一个端口 接收到客户端的请求，并建立一个连接 创建一个goroutine处理这个连接 然后再收到请求、建立连接、创建goroutine处理连接（一直重复这个步骤 下例：用go内置的net包实现tcp服务端代码 package main import ( \"bufio\" \"fmt\" \"net\" ) // tcp server端代码 /* main函数 1 main函数中，调用net.Listen建立一个本地监听，获得一个监听对象 2 开启一个for无限循环，调用监听对象的accept方法获得一个连接对象 3 将连接对象传入到处理连接的函数中，对该连接对象进行处理 process函数 4 定义一个处理连接对象的函数，该函数接收一个连接对象类型的参数 5 开启一个for无限循环，作用是可以一直处理从这个连接发来的数据（对应一个客户端 注册一个defer，用于函数退出时，关闭连接 6 for循环内部 定义一个字节数组，用于存放客户端发来的数据 利用bufio.Reader()从传入的连接对象中获取一个reader对象 然后reader对象将客户端数据读入并放到基于上面定义的字节数据的切片中 将读取的字节切片转为字符串，并打印到控制台，就获得了客户端发来的数据 然后用连接对象的Write方法，写入需要返回给客户端的数据 */ func process(conn net.Conn) { // 注册一个关闭连接动作，当该函数处理完毕，表示该连接处理也完毕，连接应该在返回前进行关闭 defer conn.Close() // 这个for表示对于一个已经建立连接的客户端能一直接收它的多次请求 for { reader := bufio.NewReader(conn) // 获得一个*Reader类型 var buffer [128]byte // 把读取到的数据放到buffer构造的切片中，返回读取的字节大小，和可能的err n, err := reader.Read(buffer[:]) if err != nil { fmt.Println(\"read from client failed!\", err) break } recvStr := string(buffer[:n]) // 在服务器的终端打印 fmt.Printf(\"客户端发来数据：%s\\n\", recvStr) // 返回给客户端数据 conn.Write(buffer[:n]) } } func main() { // 监听在本地9000端口，并用tcp连接 listener, err := net.Listen(\"tcp\", \"127.0.0.1:9000\") if err != nil { fmt.Printf(\"listen failed,error: %v\\n\", err) return } fmt.Println(\"监听已经建立，开启准备接收建立建立的请求\") // 能正常建立监听，就利用for循环，表示一直监听 // 这个for表示能一直接收不同客户端的连接请求 for { conn, err := listener.Accept() // 建立一个连接 if err != nil { fmt.Printf(\"accept failed, err %v\\n\", err) continue // 跳出本次循环，继续建立下一个连接 } // 能正常建立连接，把连接句柄传入处理函数，并放在goroutine中执行 go process(conn) } } 1.2.3. tcp客户端 一个tcp客户端进行tcp通信的流程 建立与服务器端的连接 进行数据收发 关闭连接 下例：用go内置的net包实现tcp客户端代码 package main import ( \"bufio\" \"fmt\" \"net\" \"os\" \"strings\" ) /* 1 net.Dial进行向客户请求建立连接 建立失败，则提示错误并退出 建立成功，则获得一个连接对象，conn defer注册一个conn的关闭操作，用于函数退出后关闭连接 bufio.NewReader()从标准输入中获取一个读对象inputReader for { 建立一个无限循环 利用inputReader对象的ReadString方法，按行从标准输入中获取数据（为字符串类型 去掉字符串的换行后缀得到一行数据 先判断该次输入的是否是q，是q表示就退出客户端程序 不是，则利用conn的Write方法，发送数据给服务端 判断返回的err是否为空， 不是则打印错误，并退出 是则，再调用conn的Read方法，读取服务端发回的数据，进行打印 } */ func main() { // 向本地的9000请求建立连接，建立失败，直接退出，建立成功，注册一个连接对象关闭语句 conn, err := net.Dial(\"tcp\", \"127.0.0.1:9000\") if err != nil { fmt.Println(\"dial failed,\", err) return } defer conn.Close() // 从标准输入获取数据， // 发送到服务端， // 打印服务端的返回数据， // 写在for中，可以一直重复上面三步 for { // 从标准输入实例化一个读对象 inputReader := bufio.NewReader(os.Stdin) fmt.Println(\"请输入要发送的内容：\") inputInfo, err := inputReader.ReadString('\\n') if err != nil { fmt.Printf(\"input is failed err:%v \\n\", err) } inputString := strings.Trim(inputInfo, \"\\r\\n\") if strings.ToLower(inputString) == \"q\" { fmt.Println(\"你选择了关闭客户端\") return } _, err = conn.Write([]byte(inputString)) if err != nil { fmt.Println(\"send data to server faile. \", err) return } // 声明一个128容量的字节数组，并以此构造一个字节切片，Read方法把读到的数据写到这个字节切片中 var recvStr [128]byte recvN, err := conn.Read(recvStr[:]) if err != nil { fmt.Println(\"recv data from server failed ,\", err) return } fmt.Printf(\"收到服务端回复： %s\\n\", string(recvStr[:recvN])) } } 运行截图： 客户端：启动2个客户端，同时向服务端发送消息，每个客户端支持发送多次消息 服务端：可以收到多个客户端的多条消息 1.3. tcp粘包 1.3.1. 粘包示例 粘包服务端 package main import ( \"bufio\" \"fmt\" \"io\" \"net\" ) func main() { listener, err := net.Listen(\"tcp\", \"127.0.0.1:9000\") if err != nil { fmt.Println(\"listen failed,\", err) return } defer listener.Close() for { conn, err := listener.Accept() if err != nil { fmt.Println(\"accept failed\", err) continue } go process(conn) } } func process(conn net.Conn) { defer conn.Close() serverReader := bufio.NewReader(conn) var recvStr [1024]byte for { n, err := serverReader.Read(recvStr[:]) if err == io.EOF { break } if err != nil { fmt.Println(\"read from client failed,\", err) break } clientContent := string(recvStr[:n]) fmt.Println(\"收到客户端的数据：\", clientContent) } } 粘包客户端 package main import ( \"fmt\" \"net\" ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:9000\") if err != nil { fmt.Println(\"connect server failed .\", err) return } defer conn.Close() for i := 0; i 运行截图 可以看到，按照逻辑，本应该打印20行，结果只打印了2行，10条数据都被放在了一行，即出现了粘包 1.3.2. 出现粘包的原因 客户端粘包，由nagle算法导致，该算法使得，tcp在收到应用层发送的数据时，不会立即就向目标机器发送，而是会等待一会，看应用层是否还有数据要发，如果有就发数据合并到起来，再发送目标机器，其本意是为了改善网络传输效率，但可能导致客户端粘包 服务端同样也可能出现粘包，在服务端收到某个客户端发来的数据时，上层应用取数据不及时，导致了多次客户端发来的数据放在tcp缓冲区，之后应用层来取数据时，就把多次数据“粘”到了一起 1.3.3. 解决方法 出现粘包的关键在于，接收方不知道数据包的边界在哪里，即如果多段数据堆在了一起，不知道如何切分这串数据 解决方法：给数据包进行封包和拆包，给数据加上一个固定长度的包头，包头内存放了它这段数据的长度，类似ip头和以太网头部的原理，这样就可以正确切分数据 1、自定义封包协议 协议内容：数据包的前4个字节为包头，内部就存储了一个int32的数据，表示的是后面数据的长度，（假设里面数值为10000，那么接收就知道再向后数10000长度，就是一个完整的数据端，不会多切，也不会少切） 协议包 package protocol import ( \"bufio\" \"bytes\" \"encoding/binary\" ) // 对要发送的数据进行编码 // 接收要发送的字符串，然后返回一个可以发送的字节切片，和可能的error func Encode(msg string) ([]byte, error) { // 读取消息长度，转为int32类型的一个数据，然后放到消息头中 var length = int32(len(msg)) var pkg = new(bytes.Buffer) // 写入消息头 err := binary.Write(pkg, binary.LittleEndian, length) if err != nil { return nil, err } // 写入消息体 err = binary.Write(pkg, binary.LittleEndian, []byte(msg)) if err != nil { return nil, err } return pkg.Bytes(), nil } // 对要发送的数据进行解码， // 接收一个bufio.Reader类型，返回一个string类型，和可能的error func Decode(reader *bufio.Reader) (string, error) { // 先读取消息的长度,读取前4个字节的数据 lengthByte, _ := reader.Peek(4) lengthBuff := bytes.NewBuffer(lengthByte) var length int32 // 从lengthBuff中读取其中以binary方式编码的数据，并解码出来，赋值给length // 说人话就是：读取前4个字节中的int32数值，赋值给length，即读取消息实体的长度 err := binary.Read(lengthBuff, binary.LittleEndian, &length) if err != nil { return \"\", err } // Buffered返回缓冲中现有的可读取的字节数 if int32(reader.Buffered()) 2、改造服务端:用protocol包中的decode解析数据 package main import ( \"bufio\" \"fmt\" \"io\" \"learngo/basic_grammar/protocol\" // 导入自定义的protocol包 \"net\" ) func main() { listener, err := net.Listen(\"tcp\", \"127.0.0.1:9000\") if err != nil { fmt.Println(\"listen failed,\", err) return } defer listener.Close() for { conn, err := listener.Accept() if err != nil { fmt.Println(\"accept failed\", err) continue } go process(conn) } } func process(conn net.Conn) { defer conn.Close() serverReader := bufio.NewReader(conn) for { // 改造后 msg, err := protocol.Decode(serverReader) if err == io.EOF { return } if err != nil { fmt.Println(\"decode msg failed ,\", err) return } fmt.Println(\"客户端发来的数据：\", msg) } } 3、改造客户端：用protocol中的encode方法，封装数据， package main import ( \"fmt\" \"learngo/basic_grammar/protocol\" \"net\" ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:9000\") if err != nil { fmt.Println(\"connect server failed .\", err) return } defer conn.Close() for i := 0; i 4、运行截图 服务端可以正确的切分数据了，每行打印一个 1.4. go实现udp通信 1.4.1. udp协议 udp协议，中文名为用户数据报协议，面向无连接、不可靠的、不确保按序到达、没有流控的传输层协议，但性能高，延迟低，常用于视频直播领域 1.4.2. udp服务端 package main import ( \"fmt\" \"net\" ) // udp server demo func main() { listen, err := net.ListenUDP(\"udp\", &net.UDPAddr{ IP: net.IPv4(0, 0, 0, 0), Port: 10000, }) if err != nil { fmt.Println(\"udp listen failed, \", err) return } defer listen.Close() for { // 将从udp客户端读取的数据放到data切片中 var data [1024]byte n, addr, err := listen.ReadFromUDP(data[:]) // 返回读取的字节大小、对端地址、可能的错误 if err != nil { fmt.Println(\"read from udp client failed, \", err) continue } fmt.Printf(\"data: %v addr: %v count: %v\\n\", string(data[:n]), addr, n) // 发送响应数据给客户端 _, err = listen.WriteToUDP(data[:n], addr) if err != nil { fmt.Println(\"write to udp client failed, err\", err) continue } } } 1.4.3. udp客户端 package main import ( \"fmt\" \"net\" ) func main() { socket, err := net.DialUDP(\"udp\", nil, &net.UDPAddr{ IP: net.IPv4(127, 0, 0, 1), Port: 10000, }) if err != nil { fmt.Println(\"connect udp server failed,\", err) return } defer socket.Close() sendData := []byte(\"hello udp server\") _, err = socket.Write(sendData) if err != nil { fmt.Println(\"send to udp failed,\", err) return } data := make([]byte, 2048) n, remoteAddr, err := socket.ReadFromUDP(data) if err != nil { fmt.Println(\"recv from udp server failed\", err) return } fmt.Printf(\"remoteaddr :%v content :%v, count: %v\\n\", remoteAddr, string(data[:n]), n) } 运行截图 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.16go基础语法之单元测试.html":{"url":"1-go基础语法/1.16go基础语法之单元测试.html","title":"1.16go基础语法之单元测试","keywords":"","body":"1. go test工具2. 测试函数2.1. 测试函数的格式2.2. 测试函数示例2.3. 测试组2.4. 子测试2.5. 测试覆盖率3. 基准测试3.1. 基准测试函数格式3.2. 　基准测试函数示例3.3. 性能比较函数3.4. 重置时间3.5. 并行测试4. Setup和TearDown4.1. TestMain4.2. 子测试的Setup和Teardown5. 示例函数5.1. 示例函数的格式5.2. 示例函数示例6. 练习题6.1. 思路6.2. 代码实现6.3. 代码改进6.3.1. 测试失败例16.3.2. 测试失败例21. go test工具 golang中的测试依赖go test命令，编写测试代码和编写普通的go代码是类似的， go test命令是一个按照一定约定和组织测试代码的驱动程序，在包目录内部，所有以_test.go为后缀的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。 在*_test.go文件中，有三种类型的函数，单元测试函数、基准测试函数、和示例函数 类型 格式 作用 测试函数 函数名前缀为Test 测试程序的逻辑行为是否符合预期 基准函数 函数名前缀为Benchmark 测试函数的性能 示例函数 函数名前缀为Example 为文档提供示例 go test命令，会遍历所有的*_test.go文件中，符号上述命令规则的函数，然后生成一个临时的main包用于调用所有的测试函数，然后构建运行、报告测试结果、最后清理测试中生成的临时文件 2. 测试函数 2.1. 测试函数的格式 每个测试函数必须导入testing包，测试函数的基本格式如下： func TestName(t *testing.T) { //... } 测试函数的名字必须以Test开头，后缀名必须以大写字母开头，举例： func TestAdd(t *testing.T) { ...} func TestSum(t *testing.T) { ...} func TestLog(t *testing.T) { ...} 其中参数t用于报告测试失败和附加的日志信息，testing.T拥有的方法如下： func (c *T) Error(args ...interface{}) func (c *T) Erroff(format string, args ...interface{}) func (c *T) Fail() func (c *T) FailNow() func (c *T) Failed() bool func (c *T) Fatal(args ...interface{}) func (c *T) Fatalf(format string, args ...interface{}) func (c *T) Log(args ...interface{}) func (c *T) Logf(format string, args ...interface{}) func (c *T) Name() string func (t *T) Parallel() func (t *T) Run(name string, f func(t *T)) bool func (c *T) Skip(args ...interface{}) func (c *T) SkipNow() func (c *T) Skipf(format string, args ...interface{}) func (c *T) Skipped() bool 2.2. 测试函数示例 一个完整的软件程序是由很多小的单元组件构造的，单元组件可以是函数、结构体、方法等，只有确保这些小的单元组件都正常运行，组成的完整软件程序，才有可能正常运行，因此拆分出来一个个小的组件，测试它们的功能，确保它们的功能符合预期，这就是单元测试 1、定义一个split包，包中包含一个split.go文件，其中实现了一个split函数，代码如下： package split // split/split.go文件 import \"strings\" // 函数功能：接收一个字符串s ，一个字符串sep，将s按照sep为分隔符，分割为一个个子字符串，并以字符串切片的形式返回 // 示例： abcbdebh，应该切成a c de h func Split(s, sep string) (result []string) { // 求出sep在s中第一次出现的下标， i := strings.Index(s, sep) for i > -1 { result = append(result, s[:i]) s = s[i+1:] i = strings.Index(s, sep) } // 最后一部分不包含分隔符sep的追加到result切片中,然后返回 result = append(result, s) return } 2、在同目录下创建一个split_test.go文件，并定义一个测试函数如下 package split import ( \"reflect\" \"testing\" ) // 函数定义为标准格式，Test后加上要测试的函数名，并首字母大写即可 func TestSplit(t *testing.T) { got := Split(\"a:b:c\", \":\") // 实际运行函数 并把运行的结果赋值给got want := []string{\"a\", \"b\", \"c\"} // 预期的函数运行结果 if !reflect.DeepEqual(want, got) { // 切片不能直接比较，借助反射包中提供的方法比较2个字符串切片 t.Errorf(\"expected: %v, but got :%v\\n\", want, got) // 如果测试失败，则打印上面的提示 } } 3、在split包的目录下，执行go test命令，输出结果如下 ten@DESKTOP-7ICOPRG MINGW64 /c/myworkstation/mygocode/src/learngo/basic_grammar/23unit_test/split (master) $ ls -l total 2 -rw-r--r-- 1 ten 197121 621 2月 3 17:00 split.go -rw-r--r-- 1 ten 197121 580 2月 3 17:06 split_test.go $ go test PASS ok learngo/basic_grammar/23unit_test/split 0.163s 4、在split_test.go文件中再添加一个测试用例函数，如下 // 测试分隔符为字符串而不是单个字符的测试函数 func TestSplitMultixString(t *testing.T) { got := Split(\"abcd\", \"bc\") want := []string{\"a\", \"d\"} if !reflect.DeepEqual(want, got) { t.Errorf(\"expected: %v, got: %v \\n\", want, got) } } 5、再次执行go test命令，输出如下，可以看到测试用例失败，使用go test -v查看详细的测试函数执行信息 $ go test --- FAIL: TestSplitMultixString (0.00s) split_test.go:24: expected: [a d], got: [a cd] FAIL exit status 1 FAIL learngo/basic_grammar/23unit_test/split 0.064s // 详细输出信息 $ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestSplitMultixString split_test.go:24: expected: [a d], got: [a cd] --- FAIL: TestSplitMultixString (0.00s) FAIL exit status 1 FAIL learngo/basic_grammar/23unit_test/split 0.037s 6、跟据上面输出可以看到添加的测试用例函数，没有通过用例，原因为实现的split函数没有考虑到分隔符为多个字母的情况，改进split函数如下： package split // split/split.go文件 import \"strings\" // 函数功能：接收一个字符串s ，一个字符串sep，将s按照sep为分隔符，分割为一个个子字符串，并以字符串切片的形式返回 // 示例： abcbdebh，应该切成a c de h func Split(s, sep string) (result []string) { // 求出sep在s中第一次出现的下标， i := strings.Index(s, sep) for i > -1 { result = append(result, s[:i]) // s = s[i+1:] s = s[i+len(sep):] // 切的时候把sep整个子串切出去 i = strings.Index(s, sep) } // 最后一部分不包含分隔符sep的追加到result切片中,然后返回 result = append(result, s) return } 7、再执行测试go test，可以发现2个测试用例都通过了，测试结果如下： $ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestSplitMultixString --- PASS: TestSplitMultixString (0.00s) PASS ok learngo/basic_grammar/23unit_test/split 0.038s 8、`go test -v -run=\"一个正则表达式\"，可以利用正则匹配特定的测试函数进行测试，而不是执行全部的测试函数 $ go test -v -run=\"Multi\" === RUN TestSplitMultixString split_test.go:24: expected: [a d], got: [a cd] --- FAIL: TestSplitMultixString (0.00s) FAIL exit status 1 FAIL learngo/basic_grammar/23unit_test/split 0.034s ps，修改代码后，应该执行全部的测试函数，确保都能通过，避免修改代码后引入新的问题 2.3. 测试组 上面测试一组用例，就写一个测试函数有些繁琐，可以只写一个函数，然后将多组测试数据存放在切片中，依次遍历其中的每个测试用例，即为测试组 1、测试组示例 package split import ( \"reflect\" \"testing\" ) // 定义测试组，即将一组要测试的输入，和期望的状态，组成一个切片，然后遍历切片 // 对切片中每个元素进行测试 func TestSplit(t *testing.T) { // 定义一个测试用例的结构体 type test struct { input string sep string want []string } // 声明一个test类型的切片，把要测试的3组数据放进去 testGroup1 := []test{ {input: \"a:b:c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"}}, {input: \"a:b:c\", sep: \",\", want: []string{\"a:b:c\"}}, {input: \"沙河有沙又有河\", sep: \"沙\", want: []string{\"河有\", \"又有河\"}}, } for _, testUnit := range testGroup1 { got := Split(testUnit.input, testUnit.sep) want := testUnit.want if !reflect.DeepEqual(got, want) { t.Errorf(\"expected : %v, but got : %v\", want, got) } } } 2、测试结果 $ go test -v === RUN TestSplit split_test.go:29: expected : [河有 又有河], but got : [ 河有 又有河] --- FAIL: TestSplit (0.00s) FAIL exit status 1 FAIL learngo/basic_grammar/23unit_test/split 0.040s 3、改进输出信息格式， %#v if !reflect.DeepEqual(got, want) { t.Errorf(\"expected : %#v, but got : %#v\", want, got) } // 可以看到，其实切出来的第一个是一个空字符串， $ go test -v === RUN TestSplit split_test.go:29: expected : []string{\"河有\", \"又有河\"}, but got : []string{\"\", \"河 有\", \"又有河\"} --- FAIL: TestSplit (0.00s) FAIL exit status 1 FAIL learngo/basic_grammar/23unit_test/split 0.048s // 把want前面加个空字符串就通过测试了 $ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) PASS ok learngo/basic_grammar/23unit_test/split 0.056s 2.4. 子测试 1、给每个测试用例加个标识符，方便区分 package split import ( \"reflect\" \"testing\" ) // 定义测试组，即将一组要测试的输入，和期望的状态，组成一个切片，然后遍历切片 // 对切片中每个元素进行测试 func TestSplit(t *testing.T) { // 定义一个测试用例的结构体 type test struct { input string sep string want []string } // 声明一个test类型的切片，把要测试的3组数据放进去 // testGroup1 := []test{ // {input: \"a:b:c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"}}, // {input: \"a:b:c\", sep: \",\", want: []string{\"a:b:c\"}}, // {input: \"沙河有沙又有河\", sep: \"沙\", want: []string{\"\", \"河有\", \"又有河\"}}, // } // 在每个测试用例前加个名字，作为简单的标识符 testGroup1 := map[string]test{ \"test1\": {input: \"a:b:c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"}}, \"test2\": {input: \"a:b:c\", sep: \",\", want: []string{\"a:b:c\"}}, \"test3\": {input: \"沙河有沙又有河\", sep: \"沙\", want: []string{\"河有\", \"又有河\"}}, } for name, testUnit := range testGroup1 { got := Split(testUnit.input, testUnit.sep) want := testUnit.want if !reflect.DeepEqual(got, want) { t.Errorf(\"本次测试用例名字：%v,expected : %#v, but got : %#v\", name, want, got) } } } 出错时，方便根据名字快速定位到具体哪个用例没通过 $ go test -v === RUN TestSplit split_test.go:36: 本次测试用例名字：test3,expected : []string{\"河有\", \"又有河\"}, but got : []string{\"\", \"河有\", \"又有河\"} --- FAIL: TestSplit (0.00s) FAIL exit status 1 FAIL learngo/basic_grammar/23unit_test/split 0.043s 2、针对此种情况，官方还推出了子测试，利用t.Run()方法方便的实现子测试 t.Run()的函数定义如下： func (t *T) Run(name string, f func(t *T)) bool package split import ( \"reflect\" \"testing\" ) // 定义测试组，即将一组要测试的输入，和期望的状态，组成一个切片，然后遍历切片 // 对切片中每个元素进行测试 func TestSplit(t *testing.T) { // 定义一个测试用例的结构体 type test struct { input string sep string want []string } // 声明一个test类型的切片，把要测试的3组数据放进去 // testGroup1 := []test{ // {input: \"a:b:c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"}}, // {input: \"a:b:c\", sep: \",\", want: []string{\"a:b:c\"}}, // {input: \"沙河有沙又有河\", sep: \"沙\", want: []string{\"\", \"河有\", \"又有河\"}}, // } // 在每个测试用例前加个名字，作为简单的标识符 testGroup1 := map[string]test{ \"test1\": {input: \"a:b:c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"}}, \"test2\": {input: \"a:b:c\", sep: \",\", want: []string{\"a:b:c\"}}, \"test3\": {input: \"沙河有沙又有河\", sep: \"沙\", want: []string{\"河有\", \"又有河\"}}, } for name, testUnit := range testGroup1 { t.Run(name, func(t *testing.T) { got := Split(testUnit.input, testUnit.sep) if !reflect.DeepEqual(got, testUnit.want) { t.Errorf(\"expected: %#v, but got : %#v\", testUnit.want, got) } }) } } 此时再测试，就可以看到更清晰的输出信息(可以输出整体测试的信息，以及每个测试用例的信息) $ go test -v === RUN TestSplit === RUN TestSplit/test1 === RUN TestSplit/test2 === RUN TestSplit/test3 split_test.go:36: expected: []string{\"河有\", \"又有河\"}, but got : []string{\"\", \"河有\", \"又有河\"} --- FAIL: TestSplit (0.00s) --- PASS: TestSplit/test1 (0.00s) --- PASS: TestSplit/test2 (0.00s) --- FAIL: TestSplit/test3 (0.00s) FAIL exit status 1 FAIL learngo/basic_grammar/23unit_test/split 0.116s 下面是都测试通过的结果 $ go test -v === RUN TestSplit === RUN TestSplit/test1 === RUN TestSplit/test2 === RUN TestSplit/test3 --- PASS: TestSplit (0.00s) --- PASS: TestSplit/test1 (0.00s) --- PASS: TestSplit/test2 (0.00s) --- PASS: TestSplit/test3 (0.00s) PASS ok learngo/basic_grammar/23unit_test/split 0.054s 还可以通过/选择某个用例的名字，来指定运行它，如下： -run加正则表达式可以匹配要运行的测试用例，测试组名/某个测试用例的名字，也可以运行某个单独的额测试用例 $ go test -v -run=Split/test3 === RUN TestSplit === RUN TestSplit/test3 --- PASS: TestSplit (0.00s) --- PASS: TestSplit/test3 (0.00s) PASS ok learngo/basic_grammar/23unit_test/split 0.037s 2.5. 测试覆盖率 测试覆盖率通常是指，语句的覆盖率，就代码在测试中，至少会被执行一次的代码所占的比重 1、查看语句的测试覆盖率 $ go test -cover PASS coverage: 100.0% of statements ok learngo/basic_grammar/23unit_test/split 0.039s 2、将生成的覆盖率结果，生成一个c.out文件 $ go test -coverprofile=c.out PASS coverage: 100.0% of statements ok learngo/basic_grammar/23unit_test/split 0.041s 3、将生成的c.out文件，以html网页形式展示 $ go tool cover -html=c.out 绿色的表示测试中，会被至少运行一次的代码，红色的表示没有被测试到 3. 基准测试 3.1. 基准测试函数格式 基准测试就是在一定的工作负载之下检测程序性能的一种方法，基准测试的基本格式如下： func BenchmarkName(b *testing.B) { ... } 函数名以Benchmark为前缀，需要一个*testing.B类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的具体值是根据系统实际情况调整的，从而保证测试的稳定性，testing.B拥有的方法如下： func (c *B) Error(args ...interface{}) func (c *B) Errorf(format string, args ...interface{}) func (c *B) Fail() func (c *B) FailNow() func (c *B) Failed() bool func (c *B) Fatal(args ...interface{}) func (c *B) Fatalf(format string, args ...interface{}) func (c *B) Log(args ...interface{}) func (c *B) Logf(format string, args ...interface{}) func (c *B) Name() string func (b *B) ReportAllocs() func (b *B) ResetTimer() func (b *B) Run(name string, f func(b *B)) bool func (b *B) RunParallel(body func(*PB)) func (b *B) SetBytes(n int64) func (b *B) SetParallelism(p int) func (c *B) Skip(args ...interface{}) func (c *B) SkipNow() func (c *B) Skipf(format string, args ...interface{}) func (c *B) Skipped() bool func (b *B) StartTimer() func (b *B) StopTimer() 3.2. 　基准测试函数示例 1、为Split函数编写基准测试函数如下： package split import ( \"reflect\" \"testing\" ) func BenchmarkSplit(b *testing.B) { for i := 0; i 2、执行基准测试函数，输出如下 其中： BenchmarkSplit-4表示基本测试的对象是Split，4为使用的GOMAXPROCS的值， 1628038表示执行了这些次Split函数 770ns/op为执行了1628038次Split所得到的一次函数的平均执行时间 $ go test -bench=Split goos: windows goarch: amd64 pkg: learngo/basic_grammar/23unit_test/split BenchmarkSplit-4 1628038 770 ns/op PASS ok learngo/basic_grammar/23unit_test/split 2.070s 3、查看内存相关的测试信息 其中 1898406 为执行了这么多次函数 平均一次执行时间为617 ns 平均一次占用内存112B即112字节 平均一次操作，申请了3次内存 $ go test -bench=Split -benchmem goos: windows goarch: amd64 pkg: learngo/basic_grammar/23unit_test/split BenchmarkSplit-4 1898406 617 ns/op 112 B/op 3 allocs/op PASS ok learngo/basic_grammar/23unit_test/split 1.867s 4、针对内存测试结果，优化Split函数 （预先申请result所需要的内存，避免切片使用append函数时，自动扩容申请内存，减少内存申请次数 package split import \"strings\" // split/split.go文件 // 函数功能：接收一个字符串s ，一个字符串sep，将s按照sep为分隔符，分割为一个个子字符串，并以字符串切片的形式返回 // 示例： abcbdebh，应该切成a c de h func Split(s, sep string) (result []string) { // 预先估计result的容量，然后一次性申请下来 result = make([]string, 0, strings.Count(s, sep)+1) // 求出sep在s中第一次出现的下标， i := strings.Index(s, sep) for i > -1 { result = append(result, s[:i]) // s = s[i+1:] s = s[i+len(sep):] // 切的时候把sep整个子串切出去 i = strings.Index(s, sep) } // 最后一部分不包含分隔符sep的追加到result切片中,然后返回 result = append(result, s) return } 5、查看优化后的Split函数的基准测试结果 $ go test -bench=Split -benchmem goos: windows goarch: amd64 pkg: learngo/basic_grammar/23unit_test/split BenchmarkSplit-4 2404686 597 ns/op 48 B/op 1 allocs/op PASS ok learngo/basic_grammar/23unit_test/split 1.999s 可以看到： 每次执行时间减少为597ns 每次占用内存减少到了48B 每次只需要申请一次内存，allocs/op 通过提前申请内存，减少了2/3次的内存请求操作，减少了一半的内存空间占用 3.3. 性能比较函数 上述基准测试，得到的是某个函数的绝对耗时，更多情况下，会需要考虑同一个函数，在处理不同数量级的数据时的耗时，比如有些函数随着数据量的增长，所消耗的时间可能是指数级增长，（对于大数据量的处理不利 性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用，例如： func benchmark(b *testing.B, size int) { ... } func benchmark10(b *testing.B) {benckmark(b,10)} func benchmark100(b *testing.B) {bencnmark(b, 100)} func benchmark1000(b *testing.B) {benchmakr(b, 1000)} 1、计算斐波那契数列的函数如下： // 计算斐波那契数列函数 func Fib(n int) int { if n 2、编写对应的性能比较函数 package split import ( \"reflect\" \"testing\" ) func benchmarkFib(b *testing.B, n int) { for i := 0; i 3、运行测试结果如下： 可以看到，随着数量级的增大，每次函数运行消耗的时间，急剧增大，运行次数也降低 默认情况下，每个基准测试，至少运行1s，如果函数返回时还未到1s，则会再次运行该函数，b.N的值，会按照1 2 5 10 20 50 ...的规律增加，并再次运行函数，直到到达1s $ go test -bench=. goos: windows goarch: amd64 pkg: learngo/basic_grammar/23unit_test/split BenchmarkFib1-4 161065544 14.4 ns/op BenchmarkFib2-4 70591141 24.1 ns/op BenchmarkFib3-4 33200372 34.9 ns/op BenchmarkFib10-4 923061 1959 ns/op BenchmarkFib20-4 5509 289835 ns/op BenchmarkFib40-4 1 3154768500 ns/op BenchmarkSplit-4 2423743 451 ns/op PASS ok learngo/basic_grammar/23unit_test/split 15.291s 看到，Fib40只运行了1次，是因为默认运行1s作用的时间，数量不大，不够准确，可以加大基准运行时间，使得其多运行几次，求平均值，如下： 20s，运行了8次，稍微精确点，根据需要可以继续加大时间 $ go test -bench=Fib40 -benchtime=20s goos: windows goarch: amd64 pkg: learngo/basic_grammar/23unit_test/split BenchmarkFib40-4 8 2719915912 ns/op PASS ok learngo/basic_grammar/23unit_test/split 62.454s 常见错误： 使用性能比较函数做测试时，容易犯的错误就是把b.N作为输入的大小，如下均为错误示例 func BenchmarkFibWrong(b *testing.B) { for n:=0; n 3.4. 重置时间 b.ResetTimer之前的处理不会放到执行时间例，也不会输出到报告中，可以在此之前做一些不打算作为测试报告的操作 func BenchmarkSplit(b *testing.B) { time.Sleep( 5 * time.Second) // 模拟操作 b.RestTimer() // 重置计数器 for i:=0; i 3.5. 并行测试 func (b *B) RunParallel(body func(*PB))会以并行的方式执行给定的基准测试 RunParallel会创建多个goroutine，其中goroutine的数量默认值为MAXPROCS，RunParallel通常会和-cpu标志一起使用 package split import ( \"testing\" ) func BenchmarkSplitParallel(b *testing.B) { // b.SetParallelism(2) 设置使用的cpu数 b.RunParallel(func(pb *testing.PB) { for pb.Next() { Split(\"a:b:c\", \":\") } }) } 执行基准测试如下： $ go test -bench=. goos: windows goarch: amd64 pkg: learngo/basic_grammar/23unit_test/split BenchmarkSplitParallel-4 5128570 301 ns/op PASS ok learngo/basic_grammar/23unit_test/split 1.967s 指定使用的cpu数量，进行并行测试 $ go test -bench=. -cpu 2 goos: windows goarch: amd64 pkg: learngo/basic_grammar/23unit_test/split BenchmarkSplitParallel-2 5040146 209 ns/op PASS ok learngo/basic_grammar/23unit_test/split 1.446s 4. Setup和TearDown 测试程序时，有时需要在测试之前进行额外的设置setup，或在测试后执行拆卸teardown 4.1. TestMain 在*_test.go文件中定义TestMain函数，可以在测试之前进行额外的设置setup或在测试之后进行拆卸teardown操作 如果测试文件包含函数：func TestMain(m *testing.M)，那么生成的测试会先调用TestMain(m)，然后再运行具体的测试代码， 在m.Run()之前写需要的setup代码 调用m.Run()执行具体的测试，并获得一个返回值retCode 在m.Run()之后写需要的teardown代码 os.Exit(retCode)通过返回值调用os.Exit退出测试 使用TestMain函数进行设置Setup和TearDown的示例如下： func TestMain(m *testing.M) { fmt.Println(\"this is some setup code\") retCode := m.Run() // 运行具体的测试代码，即上面的那个测试函数 fmt.Println(\"this is some teardown code\") os.Exit(retCode) } 注意：调用TestMain时，flag.Parse并没有被调用，如果TestMain依赖与命令行标志，应该显示的调用flag.Parse 4.2. 子测试的Setup和Teardown 有时需要为每个测试集，设置setup和teardown，也可能为每个子测试设置setup和teardown， 1、定义2个工具函数如下： // setupGroupTest 给测试集定义setup和teardown func setupGroupTest(t *testing.T) func(t *testing.T) { t.Log(\"这是测试组的setup 操作\") return func(t *testing.T) { t.Log(\"这是测试组的teardown 操作\") } } // setupSubTest 给子测试定义setup和teardown func setupSubTest(t *testing.T) func(t *testing.T) { t.Log(\"这是子测试的setup\") return func(t *testing.T) { t.Log(\"这是子测试的teardown\") } } 2、在测试文件中使用上面的工具函数 package split import ( \"reflect\" \"testing\" ) // setupGroupTest 给测试集定义setup和teardown func setupGroupTest(t *testing.T) func(t *testing.T) { t.Log(\"这是测试组的setup 操作\") return func(t *testing.T) { t.Log(\"这是测试组的teardown 操作\") } } // setupSubTest 给子测试定义setup和teardown func setupSubTest(t *testing.T) func(t *testing.T) { t.Log(\"这是子测试的setup\") return func(t *testing.T) { t.Log(\"这是子测试的teardown\") } } func TestSplit(t *testing.T) { // 定义一个测试用例的结构体 type test struct { input string sep string want []string } // 在每个测试用例前加个名字，作为简单的标识符 testGroup1 := map[string]test{ \"test1\": {input: \"a:b:c\", sep: \":\", want: []string{\"a\", \"b\", \"c\"}}, \"test2\": {input: \"a:b:c\", sep: \",\", want: []string{\"a:b:c\"}}, \"test3\": {input: \"沙河有沙又有河\", sep: \"沙\", want: []string{\"\", \"河有\", \"又有河\"}}, } // 执行setupGroupTest函数，会把setup操作执行了， // 得到的一个函数类型，注册为延迟执行，函数退出前，会把teardown操作执行了 teardownGroup := setupGroupTest(t) defer teardownGroup(t) for name, testUnit := range testGroup1 { t.Run(name, func(t *testing.T) { teardownSub := setupSubTest(t) defer teardownSub(t) got := Split(testUnit.input, testUnit.sep) if !reflect.DeepEqual(got, testUnit.want) { t.Errorf(\"expect : %#v, got : %#v\", testUnit.want, got) } }) } } 3、运行测试如下 $ go test -v === RUN TestSplit split_test.go:10: 这是测试组的setup 操作 === RUN TestSplit/test1 split_test.go:18: 这是子测试的setup split_test.go:20: 这是子测试的teardown === RUN TestSplit/test2 split_test.go:18: 这是子测试的setup split_test.go:20: 这是子测试的teardown === RUN TestSplit/test3 split_test.go:18: 这是子测试的setup split_test.go:20: 这是子测试的teardown === CONT TestSplit split_test.go:12: 这是测试组的teardown 操作 --- PASS: TestSplit (0.00s) --- PASS: TestSplit/test1 (0.00s) --- PASS: TestSplit/test2 (0.00s) --- PASS: TestSplit/test3 (0.00s) PASS ok learngo/basic_grammar/23unit_test/split 0.079s 5. 示例函数 5.1. 示例函数的格式 被go test识别的第三种函数就是示例函数，函数名以Example为前缀，没有参数和返回值，格式如下 func ExampleName() { ... } 5.2. 示例函数示例 为Split函数编写一个示例函数 func ExampleSplit() { fmt.Println(Split(\"a:b:c\", \":\")) fmt.Println(Split(\"abc\", \"b\")) // Output: // [a b c] // [a c] } 为函数编写示例代码，基于web的godoc可以把示例 函数和对于函数自动关联 示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。 $ go test -run Example PASS ok learngo/basic_grammar/23unit_test/split 0.090s 示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。 6. 练习题 编写一个回文检测函数，并为其编写单元测试和基准测试，并根据测试的结果进行逐步优化。 回文字符串示例 Madam i m Adam 油灯少灯油 6.1. 思路 函数接收一个字符串类型，返回一个bool类型 函数内部 先对字符串进行lowcase大小写的统一转换 遍历字符串，索引是i，字符串长是len， 判断i和len-i -i是否相等，每次遍历后i+1，直到i 6.2. 代码实现 判断是否回文数的代码 package palindromeNum import ( \"strings\" ) func palindromeNum(s string) bool { str := strings.ToLower(s) lenOfStr := len(s) strRune := []rune(str) for i := 0; i 初步单元测试函数 package palindromeNum import ( \"reflect\" \"testing\" ) func TestPalindromeNum(t *testing.T) { type test struct { str string is bool } tGroup := map[string]test{ \"t1\": {str: \"aaBAa\", is: true}, // \"t2\": {str: \"Madam,I’mAdam\", is: true}, // \"t3\": {str: \"我是就是我\", is: true}, // \"t4\": {str: \"你是大帅比\", is: false}, } for name, unit := range tGroup { t.Run(name, func(t *testing.T) { got := palindromeNum(unit.str) if !reflect.DeepEqual(got, unit.is) { t.Errorf(\"expected : %#v, but actually : %#v\", unit.is, got) } }) } } 测试结果 $ go test -v === RUN TestPalindromeNum === RUN TestPalindromeNum/t1 --- PASS: TestPalindromeNum (0.00s) --- PASS: TestPalindromeNum/t1 (0.00s) PASS ok learngo/basic_grammar/23unit_test/palindromeNum 0.061s 基准测试函数 func BenchmarkPalindromeNum(b *testing.B) { for i := 0; i 6.3. 代码改进 6.3.1. 测试失败例1 不管是不是回文，都处理不了中文，报错如下： panic: runtime error: index out of range [14] with length 5 [recovered] panic: runtime error: index out of range [14] with length 5 解决：应该取的是转为rune类型切片后的长度 func palindromeNum(s string) bool { str := strings.ToLower(s) // lenOfStr := len(s) // 问题出在这，应该取的是转为rune类型切片后的长度，而不是转换前字符串格式的长度，这样就可以处理中文了 strRune := []rune(str) lenOfStr := len(strRune) for i := 0; i 6.3.2. 测试失败例2 回文字符串中有逗号，等特殊符号，处理不了，解决：（利用正则把特殊符号过滤掉 package palindromeNum import ( \"regexp\" \"strings\" ) func palindromeNum(s string) bool { var str string // 先利用正则，把字符串中的一些特殊符号过滤掉,得到一个字符串切片 reg1 := regexp.MustCompile(\"[^‘’,']+\") sSlic := reg1.FindAllString(s, -1) // 再把字符串切片，拼接为字符串， for _, val := range sSlic { str = str + val } // 转为小写，再转为rune类型切片 str = strings.ToLower(str) strRune := []rune(str) len := len(strRune) for i := 0; i latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.1go基础语法之变量与常量.html":{"url":"1-go基础语法/1.1go基础语法之变量与常量.html","title":"1.1go基础语法之变量与常量","keywords":"","body":"1. 标识符与关键字1.1. 标识符1.2. 关键字1.2.1. go的25个关键字1.2.2. go的37个保留字2. 变量2.1. 变量是什么2.2. 变量类型2.3. 变量声明2.3.1. 标准声明2.3.2. 批量声明2.3.3. 变量的初始化2.4. 注意事项3. 常量3.1. iota3.1.1. iota示例1. 标识符与关键字 1.1. 标识符 ​ 标识符开发程序时定义的具有特定含义的词，如：变量名、常量名、函数名等... ​ 组成由：字母、数字、下划线_组成，只能以字母和下划线_开头 ​ 例如：abc _123 a123 1.2. 关键字 ​ 关键字时编程语言中保留定义好的具有特定含义的字符，关键字和保留字都不可用作变量名； 1.2.1. go的25个关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 1.2.2. go的37个保留字 Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover 2. 变量 2.1. 变量是什么 ​ 程序中的数据，都以二进制方式，存储在内存的某个地址中，操作数据时，需要指明数据所在的内存地址，而内存地址的标识较为繁琐，因此给内存地址起个名字，就是变量名，变量名对应的就是内存地址； 2.2. 变量类型 ​ 变量的作用，存储数据，数据又分多种不同的类型，常见又：整型、浮点型、布尔型、字符型、字符串型； ​ go中，每个变量都必须有一个类型，且变量必须先声明，再使用； 2.3. 变量声明 go变量声明后，才可使用； 且，声明后必须使用； 同一个作用域内，不可重复使用； 2.3.1. 标准声明 格式： var 变量名 变量类型 示例： var name string var age int var isOk bool 2.3.2. 批量声明 go支持一个关键字var，声明多个变量，简化代码： var ( a string b int c boo d float32 ) 2.3.3. 变量的初始化 go在声明一个变量时，会自动对变量所在内存区进行初始化，每个变量的值会被初始化该类型的默认值：如：整型和浮点型默认值是：0；字符串变量默认值是：空字符串；布尔型变量值默认值是：false；切片、函数、指针默认为nil； 声明变量同时赋值； 格式： var 变量名 类型 = 值表达式 示例： var name string = \"wang\" var age int = 18 批量初始化： var name,age = \"wang\", 18 类型推导； 省略变量的类型时，编译器会根据=右边表达式推导变量的类型，完成初始化； var name = \"wang\" 推导为string类型 var age = 18 推导为int类型 短变量声明； 在函数内部，:=可以更简洁的初始化变量 package main import ( \"fmt\" ) // 全局变量m，且使用了类型推导 var m = 100 func main () { n := 10 m := 20 // 此处为局部变量m fmt.Println(m,n) } 匿名变量； 多重赋值时，想忽略某值，可以用匿名变量anonymous variable，匿名变量用下划线_表示 匿名变量，不占用命令空间、不分配内存、匿名变量不存在重复声明 示例： package main import ( \"fmt\" ) func foo(){ return 10,\"wang\" } func main(){ x,_ := foo() _,y := foo() fmt.Println(\"x=\",y) fmt.Println(\"y=\",y) } 2.4. 注意事项 函数外，每个语句，需以关键字开头；var、const、func等； := 不能在函数外使用； _ 多用于占位，表示想忽略的值； 3. 常量 常量，即程序运行期间不会改变值的量，参数声明和变量一致，只需把var换为const，常量定义时必须赋值 demo1： const pi = 3.14 const e = 2.7182 demo2:批量声明 const ( pi = 3.14 e = 2.7 ) demo3:批量声明时，忽略值的常量，则和上面一行相同 const ( n1 = 100 n2 n3 ) demo: package main import \"fmt\" const ( n = 100 m = 200 ) const ( i = 10 j ) // j和i 同值 func main() { fmt.Println(n) fmt.Println(m) fmt.Println(i) fmt.Println(j) } // go build 后输出 D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\02const>02const.exe 100 200 10 10 3.1. iota iota是go中常量的计数器，只能在常量的表达式中用； iota在const关键字出现时将被重置为0，const中每新增一行常量声明将使得iota计数加一，iota可理解为const语句块中的行索引，定义枚举时可用 const ( n1 = iota //0 n2 //1 n3 //2 n4 //3 ) // 根据规则，n2到n4没定义时默认和上一行保持相同，即都是iota，而iota每多一行常量定义，就+1，所以 n1 n2 n3 内 分别是 0 到 3 package main import \"fmt\" // iota demo const ( n1 = iota n2 n3 n4 ) func main() { fmt.Println(n1) fmt.Println(n2) fmt.Println(n3) fmt.Println(n4) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\02const>02const.exe 0 1 2 3 3.1.1. iota示例 iota之间插入值 package main import \"fmt\" const ( n1 = iota // 0 n2 = 100 // 100 n3 = iota // 2 n4 // 3 ) func main() { fmt.Println(n1) fmt.Println(n2) fmt.Println(n3) fmt.Println(n4) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\02const>02const.exe 0 100 2 3 ​ 使用_ 跳过某些不需要的值 const ( n1 = iota _ n3 n4 ) func main() { fmt.Println(n1) // fmt.Println(n2) fmt.Println(n3) fmt.Println(n4) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\02const>02const.exe 0 2 3 定义数量级 const ( _ = iota kb = 1 02const.exe 1024 1048576 1073741824 一行中，使用多个iota const ( a, b = iota + 1, iota + 2 // 同属于一行，2个表达式里的iota值一样，都是0 c, d e, f ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) fmt.Println(e) fmt.Println(f) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\02const>02const.exe 1 2 2 3 3 4 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.2go基础语法之基本数据类型.html":{"url":"1-go基础语法/1.2go基础语法之基本数据类型.html","title":"1.2go基础语法之基本数据类型","keywords":"","body":"1. 基础数据类型1.1. 整型1.1.1. 特殊整型1.1.2. 数字字面量语法1.2. 浮点型1.3. 复数1.4. 布尔值1.5. 字符串1.5.1. 字符串转义符1.5.2. 多行字符串1.5.3. 字符串的常用操作1.6. byte和rune类型1.6.1. 修改字符串1.7. 类型转换2. 练习1. 基础数据类型 go语言中数据类型： 整型 浮点型 布尔型 字符串 数组 切片 结构体 函数 map 通道channel ... 1.1. 整型 整型分2大类： 有符号整型: 其中数字代表内存中一个该类型数据占几位，位越多，能表示的范围就越大； int8 int16：对应c语言的short int32 int64：对应c语言中的long型 无符号位整型: 无符号位的整型，因第一位不用充当符号位，即正数或负数，表示的访问为无符号数最大值砍半，然后均分在0的2侧； uint8：即byte型， uint16 uint32 uint64 图示： 1.1.1. 特殊整型 unit：没有指明位数，在32位系统就是uint32，在64位系统就是uint64 int，在32位系统就是int32，在64系统就是int64 uintptr，无符号整型，存放一个指针； 所以，考虑到不同平台的差异，最后明确指定位数的整型数据； 1.1.2. 数字字面量语法 go1.13版本引入，方便以二进制、八进制、十六进制定义数字； eg： v := 0b00101101 表示二进制101101，相当于十进制45 v := 0o377表示二进制377，十进制的255 v :=0x1p-2表示十六进制的1除以2的平方，相当于十进制0.25 使用_分隔数据 v := 123_456，v值就是123456 demo函数 package main import \"fmt\" func main() { // 十进制 var a int = 10 // 定义一个十进制数10 fmt.Printf(\"%d \\n\", a) // 以十进制格式输出，还是10 fmt.Printf(\"%b \\n\", a) // 将10以二进制格式输出，就是1010 // 二进制 以0开头 var b int = 077 fmt.Printf(\"%o \\n\", b) fmt.Printf(\"%d \\n\", b) // 十六进制 以0x开头 var c int = 0xff fmt.Printf(\"%x \\n\", c) fmt.Printf(\"%X \\n\", c) fmt.Printf(\"%d \\n\", c) // %d 表示十进制格式 // %b 表示二进制格式 // %o 八进制而是 // %x 十六进制小写格式 // %X 十六进制大写格式 } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe 10 1010 77 63 ff FF 255 1.2. 浮点型 go支持2种浮点型，float32和float64； float32范围：3.4e38，使用常量定义：math.MaxFloat32 float64范围：1.8e308，使用常量定义：math.MaxFloat64 demo: 打印浮点数，%f是浮点数的格式占位符； package main import ( \"fmt\" \"math\" ) func main() { fmt.Printf(\"%f\\n\", math.Pi) // 默认是取小数点后6位 fmt.Printf(\"%.2f\\n\", math.Pi)// .2表示取小数点后2位 } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe 3.141593 3.14 1.3. 复数 complex64和complex128,复数分为实部和虚部，complex64的实部和虚部都是64位，complex32则都是32位； package main import ( \"fmt\" ) // 复数demo func main() { var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe (1+2i) (2+3i) 1.4. 布尔值 布尔型bool，只有ture和fasle2个值， 默认是false go不允许将整型，强制类型转换为，布尔型 布尔型无法参于数据运算，无法和其他类型进行转换 package main import ( \"fmt\" ) // bool demo func main() { var isOk bool fmt.Println(isOk) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe false 1.5. 字符串 字符串是go语言中原生数据类型，go中字符串实现采用utf-8编码，所以go的字符串变量中可以填入“万国字符”——中文、英文、日文都中，其格式为外部有双引号。 s1 := \"hello\" s2 := \"你好\" 1.5.1. 字符串转义符 go中常用转义符： \\r 回车符，跳到下一行的行首 \\n 换行符，跳到下一行的同列位置 \\t 制表符 \\'单引号 \\\"\" 双引号 \\ 反斜杠 demo：打印windows下的文件路径： package main import ( \"fmt\" ) // 字符串demo，并转义 func main() { fmt.Println(\"str := \\\"c:\\\\Code\\\\lesson01\\\\go.exe\\\"\") } // 打印时，像\" 和 \\ 这种特殊字符，需要前面加一个\\进行转义 D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe str := \"c:\\Code\\lesson01\\go.exe\" 1.5.2. 多行字符串 package main import ( \"fmt\" ) // 多行字符串 func main() { s1 := ` line1 line2 line3 ` fmt.Println(s1) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe line1 line2 line3 1.5.3. 字符串的常用操作 len(str)求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix或strins.HasSuffix前缀或后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置，从前数，或从后数 strings.Join(a[]string, sep string) join操作 1.6. byte和rune类型 组成字符串的每个元素：都叫做字符，如一个汉字、一个英文字母，一个日文、都是一个字符，注:不同字符所占据的字节是不同的; 通过遍历字符串，可获得其中的字符元素、字符用单引号包裹； var a := \"中\" var b := \"Y\" go的字符有以下2种： uint8类型，或叫byte型，代表ascill码表的一个字符， rune类型，代表一个utf-8字符，**中文、日文、韩文、这种需要用到rune类型，rune本质是一个int32类型） go使用rune类型处理unicode编码，更方便处理基于unicode的文件，若一个文件都是ascill字符，则可以使用byte类型做文本处理，更节省空间 demo： package main import ( \"fmt\" ) // 遍历字符串demo func main() { s := \"hello沙河\" for i := 0; i 03_data_type.exe 104(h)101(e)108(l)108(l)111(o)230(æ)178(²)153()230(æ)178( ²)179(³) 104(h)101(e)108(l)108(l)111(o)27801(沙)27827(河) 1.6.1. 修改字符串 字符串本质是一个byte数组，一个字符占据一个数组的下标，修改字符串步骤： 先将其转换为[]rune适合utf-8编码的字符串，或[]byte，适合纯ascill字符组成的字符串！ 对字符串数据，中的字符元素，进行修改，利用数组下标 完成后再转为string 转换中，会重新分配内存，并复制字节数组 demo： package main import ( \"fmt\" ) // 字符串修改demo func main() { s1 := \"big\" bytes1 := []byte(s1) // 先转为字符串数组bytes1 bytes1[0] = 'p' // 对bytes1的0号元素，替换为p // 注意赋值用等号= , 单个字符用''单引号 fmt.Println(string(bytes1)) // 再转回string类型 s2 := \"白萝卜\" runes2 := []rune(s2) // 包含汉字，用[]rune做类型转换 runes2[0] = '红' fmt.Println(string(runes2)) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe pig 红萝卜 1.7. 类型转换 go中，只有强制类型转换，没有隐式类型转换，只有2个类型数据，支持相互转换时，才可做类型转换； 语法： ​ T(表达式)：T是要转换的类型，表达式可是：变量、复杂算子、函数返回值等 demo： package main import ( \"fmt\" \"math\" ) // 类型转换demo func main() { var a, b = 3, 4 var c int c = int(math.Sqrt(float64(a*a + b*b))) // math.Sqrt 函数接收的参数类型是float64类型， // 所以，需要对内部计算表达式的结果做float64类型的转换 fmt.Println(c) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe 5 2. 练习 编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用fmt.Printf()搭配%T分别打印出上述变量的值和类型。 package main import ( \"fmt\" ) // test1 func main() { var num int = 10 var f1 float32 = 6.66 var isOk bool = true var str string = \"good good study\" fmt.Printf(\"%d, %T \\n\", num, num) fmt.Printf(\"%.1f, %T \\n\", f1, f1) fmt.Println(isOk) fmt.Printf(\"%T \\n\", isOk) fmt.Println(str) fmt.Printf(\"%T \\n\", str) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe 10, int 6.7, float32 true bool good good study string 编写代码统计出字符串\"hello沙河小王子\"中汉字的数量 package main import ( \"fmt\" ) // test2 // 先转换为rune数组，然后遍历数组的字符元素， // 遍历时，字符元素再转换为string类型，并利用len函数求其长度， // 若长度大于或等于3，则是汉字，计数值加1 func main() { s1 := \"hello沙河小王子溜溜溜\" numOfHanzi := 0 runes1 := []rune(s1) for i := 0; i = 3 { numOfHanzi++ } } fmt.Printf(\"the num of hanzi is : %d\", numOfHanzi) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\03_data_type>03_data_type.exe the num of hanzi is : 8 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.3go基础语法之运算符.html":{"url":"1-go基础语法/1.3go基础语法之运算符.html","title":"1.3go基础语法之运算符","keywords":"","body":"1. go运算符1.1. 算术运算1.2. 关系运算1.3. 逻辑运算1.4. 位运算1.5. 赋值运算2. 练习1. go运算符 1.1. 算术运算 运算符 作用 + 相加 - 相减 * 乘法 / 除法 % 取余数 1.2. 关系运算 运算符 作用 == 判断是否相等，相等返回true != 判断是否不等，不等返回true > 是否大于右边，是返回true >= 是否大于等于右边，是返回true 是否小于右边，是返回true 是否小于等于右边，是返回true 1.3. 逻辑运算 运算符 作用 && 逻辑与，两边都真，才为真 \\ \\ 逻辑或，两边有一个真，就为真 ! 逻辑非，对表达式取反，表达式是真，就为假，反之亦然 1.4. 位运算 对整数型，在内存中的二进制形式，进行操作 运算符 作用 & 参与运算的两数，每个二进制位相与，（1与1才是1） \\ 参与运算的两数，每个二进制位相或，（有一个1，就是1） ^ 每个二进制位异或，2位不同结果是1,2位相同结果是0 左移n位，就是乘以2的N次方（a >> 右移n位，除以2的n次方(a>>b a的每个二进制位右移b位) 1.5. 赋值运算 运算符 作用 = 将右边的值，赋给左边 += 相加后赋值 -+ 相减后赋值 *= 相乘后赋值 /= 相除后赋值 %= 求余后赋值 左移后赋值 >>= 右移后赋值 &= 按位与后赋值 \\ = 按位或后赋值 ^= 按位异或后赋值 2. 练习 有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？ 原理：异或运算的三条特性 任何数与0异或，结果都是其本身； 任何数与本身异或，结果都是0； 异或运算，满足，交换律、结合律 0与0异或，结果也是0 demo: package main import ( \"fmt\" ) // 异或运算的应用 func main() { a := [...]int{1, 2, 3, 3, 2, 1, 6, 9, 8, 8, 6} // 应该找出的是9 n := a[0] for i := 1; i 03_data_type.exe 9 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.4go基础语法之流程控制.html":{"url":"1-go基础语法/1.4go基础语法之流程控制.html","title":"1.4go基础语法之流程控制","keywords":"","body":"1. if-else1.1. if语法1.2. if特殊语法2. for2.1. for语法3. for-range键值循环4. switch-case5. goto6. break跳出本层循环7. continue跳出本次循环继续本层的下次循环8. 练习题1. if-else 1.1. if语法 if expr1 ｛ // 表达式的左括号，一定要在上一行的最后，否则会触发编译错误 分支1 ｝else if expr2 ｛ 分支2 ｝else expr3 ｛ 分支3 ｝ // else if和 else都是可选 // demo： package main import ( \"fmt\" ) func ifDemo1() { score := 88 if score > 90 { fmt.Println(\"good\") } else if score > 80 { fmt.Println(\"not bad\") } else { fmt.Println(\"bu za di\") } } func main() { ifDemo1() } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>04_controll.exe not bad 编译错误demo： package main import ( \"fmt\" ) func ifDemo1() { score := 88 if score > 90 { // 要求放在上一行if表达式的后面 fmt.Println(\"good\") } else if score > 80 { fmt.Println(\"not bad\") } else { fmt.Println(\"bu za di\") } } func main() { ifDemo1() } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>go build # learngo/basic_grammar/04_controll .\\main.go:10:17: syntax error: unexpected newline, expecting { after if clause 1.2. if特殊语法 在if的表达式之前，加一个执行语句 package main import ( \"fmt\" ) func ifDemo2() { // 把score的表达式放入了if，判断式的前面 if score := 66;score > 90 { fmt.Println(\"good\") } else if score > 80 { fmt.Println(\"not bad\") } else { fmt.Println(\"bu za di\") } } func main() { //ifDemo1() ifDemo2() } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>04_controll.exe bu za di 2. for go中，所有循环，都可以用for实现 2.1. for语法 for 初始语句；条件表达式；结束条件 ｛ 循环体语句 ｝ fordemo1： package main import ( \"fmt\" ) func fordemo1 (){ for i :=1 ; i 04_controll.exe 1 2 3 4 5 6 7 8 9 fordemo2:省略初始语句放在其他位置 package main import ( \"fmt\" ) func fordemo1 (){ i := 5 for ; i 04_controll.exe 5 6 7 8 9 fordemo3:省略初始语句，和结束条件，放在其他位置； package main import ( \"fmt\" ) func fordemo1 (){ i := 5 for ; i fordemo4:无限循环 for { 循环体 } for，通过break，goto，return，panic，强制退出循环 3. for-range键值循环 go中，通过for range，遍历数组、切片、字符串、map、通道channel，for range遍历后返回值特点： 数组、切片、字符串返回索引和值； map返回键和值； 通道channel返回通道内的值； for-range：demo package main import ( \"fmt\" ) func main() { s1 := \"hello\" for index, value := range s1 { fmt.Printf(\"%d \\n\", index) fmt.Printf(\"%c \\n\", value) // 接收索引和字符 } } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>04_controll.exe 0 h 1 e 2 l 3 l 4 o 4. switch-case demo1： package main import ( \"fmt\" ) func main() { finger := 3 switch finger { case 1: fmt.Println(\"大拇指\") case 2: fmt.Println(\"食指\") case 3: fmt.Println(\"中指\") case 4: fmt.Println(\"无名指\") case 5: fmt.Println(\"小拇指\") default: fmt.Println(\"输入无效\") } } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>04_controll.exe 中指 demo2: case比对的值，可以跟有多个 package main import ( \"fmt\" ) func main() { num := 7 switch num { case 1,3,5,7: fmt.Println(\"奇数\") case 2,4,6,8: fmt.Println(\"偶数\") default: fmt.Println(\"自己看\") } } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>04_controll.exe 奇数 demo3: case后跟表达式 package main import ( \"fmt\" ) func main() { score := 100 switch { // 此时switch后，不需要跟变量了，每个case后会跟包含变量的表达式 case score > 90: fmt.Println(\"good\") case score > 80: fmt.Println(\"not bad\") default: fmt.Println(\"bad\") } } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>04_controll.exe good demo4: fallthrough语法，可以执行满足条件的case的下一个case，为了兼容c语言中的case设计； package main import ( \"fmt\" ) func main() { score := 100 switch { case score > 90: fmt.Println(\"good\") fallthrough // 输出good后，会输出下一个not bad case score > 80: fmt.Println(\"not bad\") default: fmt.Println(\"bad\") } } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\04_controll>04_controll.exe good not bad 5. goto goto语句，通过标签，进行代码之间的无条件跳转；也可方便简化代码 1，跳出双层for循环：（没用goto package main import ( \"fmt\" ) // goto demo1 func main() { var breakFlag bool for i := 0; i 04_controll.exe 0-0 0-1 2，简化代码：（用了goto package main import ( \"fmt\" ) // goto demo2 func main() { for i := 0; i 04_controll.exe 0-0 0-1 结束for循环 6. break跳出本层循环 break可以结束for、switch、select的代码块： break还可以在语句后加标签，表示退出某个标签对应的代码块： 标签必须定义在对应的for，switch，select的代码块上： 借助标签，跳出2层循环 package main import \"fmt\" // break demo1 func main() { breakdemo1: for i := 1; i 04_controll.exe 1-1... 没有标签，只能跳出一层循环 package main import \"fmt\" // break demo1 func main() { for i := 1; i 04_controll.exe 1-1 2-1 3-1 4-1 5-1 6-1 7-1 8-1 9-1 ... 7. continue跳出本次循环继续本层的下次循环 continue语句，结束本次循环，进入本层循环的下一次循环； 仅仅在for循环内部使用； continue语句后加标签，表示开始标签对应的循环 借助标签，可以跨越2层循环 package main import \"fmt\" // continue demo1 func main() { forloop1: for i := 0; i 04_controll.exe 0-0 0-1 0-2 0-3 0-4 1-0 1-1 1-2 1-3 1-4 2-0 2-1 避开了2-2,2-3,2-4 3-0 3-1 3-2 3-3 3-4 4-0 4-1 4-2 4-3 4-4 没有借助标签，只能跳出一层循环，只跳出了本层循环的本次循环 package main import \"fmt\" // continue demo1 func main() { for i := 0; i 04_controll.exe 0-0 0-1 0-2 0-3 0-4 1-0 1-1 1-2 1-3 1-4 2-0 2-1 只避开了2-2 2-3 2-4 3-0 3-1 3-2 3-3 3-4 4-0 4-1 4-2 4-3 4-4 8. 练习题 编写代码打印9*9乘法表 package main import \"fmt\" // 9x9 乘法表打印 func main(){ for i := 1; i go run main.go 1 * 1 = 1 1 * 2 = 2 2 * 2 = 4 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.5go基础语法之数组.html":{"url":"1-go基础语法/1.5go基础语法之数组.html","title":"1.5go基础语法之数组","keywords":"","body":"1. 数组定义2. 数组初始化2.1. 方法12.2. 方法22.3. 方法33. 数组的遍历4. 多维数组4.1. 二维数据定义4.2. 二维数据遍历5. 数组是值类型6. 练习1. 数组定义 数组：同一种数据类型的集合，go中，数组在声明时就必须确定、使用时可以修改数组中元素、但数组大小，即数组长度不可变； 定义语法： // 定义一个长度为3，元素数据类型为int的数组 var a [3]int // 语法 var 数组变量名 [数组的长度]数组中元素类型 数组中，数组长度必须是常量，并长度属于数组类型的一部分，长度不同的数组，属于不同的数据类型，如[5]int 和[10]int属于不同类型； var a [4]int var b [6]int a = b // 不可以将b赋值给不属于同类型的a 数组，可以通过下标访问，下标从0开始，最后一个下标，len-1，访问越界时，会触发访问越界，panic； 2. 数组初始化 2.1. 方法1 package main import \"fmt\" func main() { // 数组定义法1 var array1 [3]int // 数组定义时，没指定元素值时，默认值为该类型的默认值，int是0，bool是false var array2 = [3]int{1, 2} // 第三个元素补0 var cityArray = [3]string{\"北京\", \"上海\", \"杭州\"} fmt.Println(array1) fmt.Println(array2) fmt.Println(cityArray) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\05_array>go run main.go [0 0 0] [1 2 0] [北京 上海 杭州] 2.2. 方法2 package main import \"fmt\" func main() { // 数组定义法1 var array1 [3]int var array2 = [3]int{1, 2} var cityArray = [3]string{\"北京\", \"上海\", \"杭州\"} fmt.Println(array1) fmt.Println(array2) fmt.Println(cityArray) // 数组定义法2，根据数组元素个数，推断数组长度， var array3 [2]bool var array4 = [...]int{1,2,3,4,5} var array5 = [...]string{\"你好\",\"杭州\"} fmt.Println(array3) fmt.Printf(\"type of array4:%T\", array4) fmt.Println(array4) fmt.Printf(\"type of array5:%T\", array5) fmt.Println(array5) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\05_array>go run main.go [0 0 0] [1 2 0] [北京 上海 杭州] [false false] type of array4:[5]int[1 2 3 4 5] type of array5:[2]string[你好 杭州] 2.3. 方法3 package main import \"fmt\" func main() { // 数组定义法1 var array1 [3]int var array2 = [3]int{1, 2} var cityArray = [3]string{\"北京\", \"上海\", \"杭州\"} fmt.Println(array1) fmt.Println(array2) fmt.Println(cityArray) // 数组定义法2，根据数组元素个数，推断数组长度， var array3 [2]bool var array4 = [...]int{1,2,3,4,5} var array5 = [...]string{\"你好\",\"杭州\"} fmt.Println(array3) fmt.Printf(\"type of array4:%T\", array4) fmt.Println(array4) fmt.Printf(\"type of array5:%T\", array5) fmt.Println(array5) // 数组定义3，指定索引初始化数组中特定索引的值 a := [...]int{1:1,3:5} fmt.Println(a) fmt.Printf(\"type of a: %T\\n\", a) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\05_array>go run main.go r\\05_array> [0 0 0] [1 2 0] [北京 上海 杭州] [false false] type of array4:[5]int[1 2 3 4 5] type of array5:[2]string[你好 杭州] [0 1 0 5] type of a: [4]int 3. 数组的遍历 数组遍历有2种方式， for结合len，根据数组长度遍历 for range，直接遍历数组 package main import \"fmt\" func main() { // 数组遍历 a := [...]int{1, 3, 4, 7, 9} for i := 0; i go run main.go 1 3 4 7 9 0: 1 1: 3 2: 4 3: 7 4: 9 4. 多维数组 go支持多维数组，即数组中的元素类型是数组，数组嵌套数组 4.1. 二维数据定义 package main import \"fmt\" func main() { // 多维数组 a := [3][2]string { {\"haha\",\"xixi\"}, {\"gogo\",\"java\"}, {\"python\",\"C\"}, } fmt.Println(a) fmt.Printf(a[2][1]) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\05_array>go run main.go [[haha xixi] [gogo java] [python C]] C 4.2. 二维数据遍历 package main import \"fmt\" func main() { // 多维数组 a := [3][2]string{ {\"haha\", \"xixi\"}, {\"gogo\", \"java\"}, {\"python\", \"C\"}, } // 多维数组遍历 for _, v1 := range a { for _, v2 := range v1 { fmt.Printf(\"%s\\t\", v2) } fmt.Println() } } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\05_array>go run main.go haha xixi gogo java python C 注：多维数组，只有最外层支持编译器推导数组长度 // 多维数组 a := [...][2]string{ {\"haha\", \"xixi\"}, {\"gogo\", \"java\"}, {\"python\", \"C\"}, } 5. 数组是值类型 数组是值类型、赋值和传参会复制整个数组，因此改变副本的值，不会改变本身的值！ 与之相对的，是引用类型 package main import \"fmt\" func modifyArray(x [3]int) { x[0] = 666 fmt.Println(x) } func main() { // 数组是值类型 a := [3]int{1,2,3} modifyArray(a) fmt.Println(a) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\05_array>go run main.go [666 2 3] [1 2 3] // 可以看到，修改时，只是修改了数组的副本， ps: 数组，支持== != 操作符，因为内存总是被初始化过的； [n]T 表示指针数组，\\[n]T表示数组指针 6. 练习 求数组[1, 3, 5, 7, 8]所有元素的和 package main import \"fmt\" func main() { a := [...]int{1,3,5,7,8} sum := 0 for _,v := range a { sum += v } fmt.Println(sum) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\05_array>go run main.go 24 找出数组中和为指定值的两个元素的下标，比如从数组[1, 3, 5, 7, 8]中找出和为8的两个元素的下标分别为(0,3)和(1,2)。 package main import \"fmt\" func main() { a := [...]int{1, 3, 5, 7, 8} sum := 0 for _, v := range a { sum += v } fmt.Println(sum) for i := 0; i go run main.go 24 (0,3)(1,2) latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.6go基础语法之切片.html":{"url":"1-go基础语法/1.6go基础语法之切片.html","title":"1.6go基础语法之切片","keywords":"","body":"1. 切片是什么2. 切片的定义2.1. 语法与示例2.2. 切片的长度和容量2.3. 切片表达式2.4. 切片表达式的省略2.5. make函数构造切片2.6. 切片本质2.7. 判断切片是否为空3. 切片不能直接比较4. 切片的赋值拷贝5. 切片遍历6. append方法给切片添加元素7. 切片的扩容策略8. copy函数复制切片9. 从切片中删除元素10. 练习1. 切片是什么 go的数组，因定义后，长度固定，不可增删其中元素，不方便， go的切片slice，是一个具有相同类型元素的可变长序列的组合，是基于数组类型做的一层封装，灵活，支持自动扩容 go切片是引用类型，内部结构：包括：地址、长度、容量，切片一般用于快速的操作一块数据集合 2. 切片的定义 2.1. 语法与示例 语法： var name []T name为变量名 T为元素类型 和数组不同之处：[]内没有指定长度，也没有...利用编译器推测长度 示例 package main import \"fmt\" func main() { var a []string // 声明一个字符串切片，默认是空 var b = []int{} // 声明一个整型切片并初始化，没赋值也是空 var c = []bool{false,true} var d = []bool{false,true} fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(a == nil) // 只有a等于nil fmt.Println(b == nil) fmt.Println(c == nil) fmt.Println(d == nil) // 切片是引用类型，不支持直接比较，只能和nil比较 } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\06slice>go run main.go [] [] [false true] true false false false 2.2. 切片的长度和容量 切片有自己的长度、len（）函数可以求得；cap（）函数可以求切片的容量； package main import \"fmt\" func main() { // 1，简单的切片表达式，s := a[low:high] a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] fmt.Printf(\"s:%v len(s):%v cap(s):%v \\n\", s, len(s), cap(s)) } s:[2 3] len(s):2 cap(s):4 2.3. 切片表达式 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片、有2种变体； 指定low和high2的索引界限值 除了指定low和high还指定容量的完整形式，加上max 1、简单切片表达式： 切片底层就是数组、可以基于数组通过切片表达式，得到切片；切片表达式中的low和high表示一个索引范围，左包含、右不包含；例如：下面代码从数组a，选出1长度=high-low，容量等于得到的切片的底层数组的容量（但要从切的位置开始数，如下，从a的第一个下标开始数，容量是4） package main import \"fmt\" func main() { // 1，简单的切片表达式，s := a[low:high] a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] fmt.Printf(\"s:%v len(s):%v cap(s):%v \\n\", s, len(s), cap(s)) } s:[2 3] len(s):2 cap(s):4 2.4. 切片表达式的省略 package main import \"fmt\" func main() { a := [5]int{1, 2, 3, 4, 5} // 2, 切片表达式的省略 s1 := a[2:] s2 := a[:3] s3 := a[:] fmt.Printf(\"%v\", s1) fmt.Printf(\"%v\", s2) fmt.Printf(\"%v\", s3) fmt.Println(\"\") // 3,对切片再切片时，high的上限边界是切片的容量，而不是长度！ // 在切片s 的基础上，再切出一个s4，s是[2 3] // s4的high上限是s的容量，即4，而low是从0开始计算，即s的0是2，从这里开始计算，那么s的3，就对应a的5，所以s4就是一个5，长度为1，容量为1 // a 1 2 3 4 5 // s 2 3 // s4 s4 := s[3:4] fmt.Printf(\"s4:%v len(s4):%v cap(s4):%v \\n\", s4, len(s4), cap(s4)) // 4，完整的切片表示式： a[low:high:max] // a := [5]int{1, 2, 3, 4, 5} // max-low就是该切片的cap容量，max的作用是限制切片的容量，没有max，默认会到数组的最后一个元素 t := a[1:3:5] fmt.Printf(\"t值%v t长度%v t容量%v\\n\", t, len(t), cap(t)) } [3 4 5][1 2 3][1 2 3 4 5] s4:[5] len(s4):1 cap(s4):1 t值[2 3] t长度2 t容量4 2.5. make函数构造切片 package main import \"fmt\" func main() { // 5，使用make()函数构造切片，而不是基于数组去切 // 语法: make([]T ,size, cap) T 是元素类型，size是元素数量，cap是切片的容量，即元素数量的上限 slice1 := make([]int, 2, 10) fmt.Println(slice1) fmt.Println(len(slice1)) // 长度为2 fmt.Println(cap(slice1)) // 容量为10 } [0 0] 2 10 2.6. 切片本质 切片的本质：对数组进行的封装 切片：包含3个信息：底层数组的指针、切片的长度len、切片的容量cap 2.7. 判断切片是否为空 package main import \"fmt\" func main() { // 6,判断切片是否为空，用len(s) == 0判断，而不是s == nil slice2 := make([]int,0,10) if len(slice2) == 0 { fmt.Println(\"slice2 is null\") } } slice2 is null 3. 切片不能直接比较 package main import \"fmt\" func main() { // 7, 切片不能直接比较，切片唯一能比较的是nil,容量和长度都是0的切片，不一定义等于nil，反过来，则成立 // var slice3 []int // len=0 cap =0 slice3=nil // slice4 := []int{} // len=0 cap =0 ,slice4!=nil // slice5 := make([]int,0) // // len=0 cap =0 ,slice5!=nil } 4. 切片的赋值拷贝 package main import \"fmt\" func main() { // 8,切片的赋值拷贝，切片是引用类型，基于同一个数组的切片，一个改了，会影响其他切片 slice6 := make([]int,3) slice7 := slice6 // 此时6个7公用一个底层数组 slice7[0] = 233 fmt.Println(slice6) fmt.Println(slice7) } [233 0 0] [233 0 0] 5. 切片遍历 package main import \"fmt\" func main() { // 9,切片的遍历,和数组的遍历一致，支持for和for range遍历 // for i := 0, i 6. append方法给切片添加元素 根据打印结果，看出，从一个空值的切片开始算，默认扩容策略是1,2,4,8,16，前一次的2倍，其指针指向的内存地址，也会随之扩容，而变化 package main import \"fmt\" func main() { // 切片的追加 var s []int s = append(s, 1) // 通过var定义的空值切片，可以在append值直接追加，无需初始化 fmt.Println(s) s = append(s, 2, 3, 4) fmt.Println(s) // 切片的自动扩容 // 从一个空值的切开开始算，默认扩容策略是1,2,4,8,16，前一次的2倍 // 每个切片都会指向一个底层数组，当底层数组不能够容纳新元素时，切片会根据”策略“进行扩容，此时切片指向的数组指针，就会发生改变 var slice []int for i := 0; i go run main.go [1] [1 2 3 4] [0] 1 1 0xc000012120 [0 1] 2 2 0xc000012140 [0 1 2] 3 4 0xc00000a460 [0 1 2 3] 4 4 0xc00000a460 [0 1 2 3 4] 5 8 0xc0000102c0 [0 1 2 3 4 5] 6 8 0xc0000102c0 [0 1 2 3 4 5 6] 7 8 0xc0000102c0 [0 1 2 3 4 5 6 7] 8 8 0xc0000102c0 [0 1 2 3 4 5 6 7 8] 9 16 0xc000018100 [0 1 2 3 4 5 6 7 8 9] 10 16 0xc000018100 [0 1 2 3 4 5 6 7 8 9 666 233 999] 7. 切片的扩容策略 对应源码：$GOROOT/src/runtime/slice.go newcap := old.cap doublecap := newcap + newcap if cap > doublecap { newcap = cap } else { if old.len 8. copy函数复制切片 1、切片是引用型 package main import \"fmt\" func main() { // copy复制切片demo a := []int{1,3,5,7,9} b := a fmt.Println(a) fmt.Println(b) b[0] = 100 fmt.Println(a) fmt.Println(b) } // 切片是引用型，a和b切片，指向的都是同一个内存地址，改一个，另一个也会变， D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\06slice>go run main.go [1 3 5 7 9] [1 3 5 7 9] [100 3 5 7 9] [100 3 5 7 9] 2、对切片进行复制，使得对副本的修改，不影响原切片 package main import \"fmt\" func main() { // copy复制切片demo a := []int{1,3,5,7,9} b := make([]int,5,5) copy(b,a) fmt.Println(a) fmt.Println(b) b[0] = 100 fmt.Println(a) fmt.Println(b) } // 可以看到，修改b，对a无影响，因为b是a的另一份数据拷贝，指向不同内存地址 D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\06slice>go run main.go [1 3 5 7 9] [1 3 5 7 9] [1 3 5 7 9] [100 3 5 7 9] 9. 从切片中删除元素 go本身不支持切片，但利用append函数，可以实现切片中元素的删除 package main import \"fmt\" func main() { // 切片的元素删除demo a := []int{1, 4, 5, 7, 8, 9} fmt.Println(a) // 现删除5，其索引为2 a = append(a[:2], a[3:]...) fmt.Println(a) // 通过的格式：要删除a切片中，某个index的元素：a = append(a[:index],a[index+1:]...) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\06slice>go run main.go [1 4 5 7 8 9] [1 4 7 8 9] 10. 练习 请写出下面代码的输出结果。 func main() { var a = make([]string, 5, 10) for i := 0; i go run main.go [ 0 1 2 3 4 5 6 7 8 9] len of a:15cap of a:20 请使用内置的sort包对数组var a = [...]int{3, 7, 8, 9, 1}进行排序（附加题，自行查资料解答） package main import ( \"fmt\" \"sort\" ) func main() { // 练习2 var a = [...]int{3, 7, 8, 9, 1} //升序 sort.Ints(a[:]) fmt.Println(a) // 降序 sort.Sort(sort.Reverse(sort.IntSlice(a[:]))) fmt.Println(a) } D:\\workstation\\mycode\\gocode\\src\\learngo\\basic_grammar\\06slice>go run main.go [1 3 7 8 9] [9 8 7 3 1] latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.7go基础语法之map.html":{"url":"1-go基础语法/1.7go基础语法之map.html","title":"1.7go基础语法之map","keywords":"","body":"1. map定义1.1. 何为map1.2. 声明语法1.3. 初始化语法2. map基础使用2.1. 值填充2.2. 判断某key是否存在2.3. map的遍历2.4. delete删除键值2.5. 按照指定顺序遍历map2.6. 元素为map类型的切片2.7. 值为切片类型的map3. 练习1. map定义 go中，提供映射关系的容器为map，内部用hash表实现； 1.1. 何为map map是一种无序的基于k-v的数据结构，go中的map是引用类型，必须先初始化才能使用 map类型的变量，声明后：初始值为nil，使用make函数来分配内存，才可使用，（否则会报错 1.2. 声明语法 map[keyType]valueType // keyType键的类型 // valueType值的类型 package main import \"fmt\" func main() { // 只声明一个map变量m1，但并没初始化，其没有分配任何内存，\"值\"等于nil var m1 map[string]int fmt.Println(m1 == nil) m1[\"wang\"] = 24 // 此时使用会报错：panic: assignment to entry in nil map } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go true panic: assignment to entry in nil map goroutine 1 [running]: main.main() D:/workstation/mycode/gocode/src/learngo/basic_grammar/07map/main.go:9 +0xb9 exit status 2 1.3. 初始化语法 make(map[keytype]valuetype,[cap]) // cap指定了map的容量，非必须，但应该初始化时，就预估好容量 初始化分配内存： package main import \"fmt\" func main() { // 只声明一个map变量m1，但并没初始化，其没有分配任何内存，\"值\"等于nil var m1 map[string]int fmt.Println(m1 == nil) // m1[\"wang\"] = 24 // make函数，为m1初始化，给其分配内存，不再等于nil， m1 = make(map[string]int, 6) m1[\"wang\"] = 24 fmt.Println(m1 == nil) fmt.Println(m1) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go true false map[wang:24] 2. map基础使用 2.1. 值填充 1，定义后填充值 package main import \"fmt\" // map使用 func main() { scoreMap := make(map[string]int, 8) scoreMap[\"wang\"] = 100 scoreMap[\"li\"] = 80 fmt.Println(scoreMap) fmt.Println(scoreMap[\"wang\"]) fmt.Printf(\"type of scoreMap:%T\\n\", scoreMap) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go map[li:80 wang:100] 100 type of scoreMap:map[string]int 2，声明时，就填充值 package main import \"fmt\" // 声明时，即赋值 func main() { userInfo := map[string]string{ \"username\": \"wang\", \"Passwd\": \"wang\", } fmt.Println(userInfo) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go map[Passwd:wang username:wang] ​ 2.2. 判断某key是否存在 package main import \"fmt\" // 判断map中某键是否存在 func main() { // value, ok := map[key] // value和ok可自定义，但一般为它们，见明知意，key为要判断的key m1 := make(map[string]int) fmt.Println(m1 == nil) m1[\"wang\"] = 100 m1[\"li\"] = 99 v, ok := m1[\"wang\"] if ok { fmt.Println(v) fmt.Println(\"wang is exist\") }else { fmt.Println(\"wang is no exist\") } v1, ok1 := m1[\"haha\"] if ok1 { fmt.Println(v1) fmt.Printf(\"haha is exist\") }else { fmt.Println(\"haha is not exist\") } } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go false 100 wang is exist haha is not exist 2.3. map的遍历 遍历和添加键值对时的顺序不无关，map是无序的 package main import \"fmt\" // 遍历map func main() { m1 := make(map[string]int, 10) m1[\"wang\"] = 100 m1[\"li\"] = 10 m1[\"zhou\"] = 1 // 遍历键和值 for k, v := range m1 { fmt.Println(k,v) } // 只遍历key for _,v := range m1 { fmt.Println(v) } // 只遍历value for k := range m1 { fmt.Println(k) } } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go wang 100 zhou 1 li 10 100 1 10 li zhou wang 2.4. delete删除键值 package main import \"fmt\" func main() { scoreTable := make(map[string]int, 10) scoreTable[\"wang\"] = 100 scoreTable[\"li\"] = 90 scoreTable[\"lin\"] = 80 delete(scoreTable, \"wang\") for k, v := range scoreTable { fmt.Println(k, v) } } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go lin 80 li 90 2.5. 按照指定顺序遍历map package main import ( \"fmt\" \"math/rand\" \"sort\" \"time\" ) // 使得无序存放的map，按照顺序输出，思路：将map的所有key取出放在一个切片中，利用排序函数对切片进行排序，然后遍历切片，根据切片中排序好的key，打印的也是排序好后的map func main() { rand.Seed(time.Now().UnixNano()) // 初始化随机数种子 var scoreTable = make(map[string]int, 20) // 声明并初始化一个容量为20的map // 先根据生成的随机字符串，组成一组无序的，map键值 for i := 0; i 2.6. 元素为map类型的切片 package main import ( \"fmt\" ) // 元素类型为map的切片： func main() { var mapSlice = make([]map[string]string, 3) for k, v := range mapSlice { fmt.Printf(\"key: %v, value: %v \\n\", k, v) } // 定义并初始化，一个切片，其每个元素都是一个map类型 // 初始化切片的第一个元素，即一个map，用make分配内存 mapSlice[0] = make(map[string]string, 3) // 向其中填充值 mapSlice[0][\"name\"] = \"wang\" mapSlice[0][\"age\"] = \"18\" mapSlice[0][\"passwd\"] = \"123\" mapSlice[1] = make(map[string]string, 2) mapSlice[1][\"name\"] = \"wang\" mapSlice[1][\"shuai\"] = \"haha\" for k, v := range mapSlice { fmt.Printf(\"key: %v, value: %v \\n\", k, v) } } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go key: 0, value: map[] key: 1, value: map[] key: 2, value: map[] key: 0, value: map[age:18 name:wang passwd:123] key: 1, value: map[name:wang shuai:haha] key: 2, value: map[] 2.7. 值为切片类型的map package main import \"fmt\" // 键值对中，其值为切片类型，的map func main() { var sliceMap = make(map[string][]string, 0) fmt.Println(sliceMap) fmt.Println(\"after init\") // 定义一个键，先判断该键是否在map中， // 如果不在，就将该键对应的值，初始化为一个，string类型的切片，长度为0 // 之后，对该切片追加2个元素 // 最后，将键、和值，添加到map中，打印map即可 k1 := \"中国\" value, ok := sliceMap[k1] if !ok { value = make([]string, 0) } value = append(value, \"上海\", \"杭州\") sliceMap[k1] = value fmt.Println(sliceMap) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go map[] after init map[中国:[上海 杭州]] 3. 练习 写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。 package main import \"fmt\" func main() { s1 := make([]string, 0,4) s1 = append(s1, \"how\", \"do\", \"you\", \"do\") fmt.Println(s1) m1 := make(map[string]int) for _, v := range s1 { m1[v] = m1[v] + 1 } fmt.Println(m1) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go [how do you do] map[do:2 how:1 you:1] 观察下面代码，写出最终的打印结果。 // 没整明白？ package main import \"fmt\" func main() { type Map map[string][]int m := make(Map) s := []int{1, 2} s = append(s, 3) fmt.Printf(\"%+v\\n\", s) m[\"q1mi\"] = s s = append(s[:1], s[2:]...) fmt.Printf(\"%+v\\n\", s) fmt.Printf(\"%+v\\n\", m[\"q1mi\"]) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/07map (master) $ go run main.go [1 2 3] [1 3] [1 3 3] latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.8go基础语法之函数.html":{"url":"1-go基础语法/1.8go基础语法之函数.html","title":"1.8go基础语法之函数","keywords":"","body":"1. 函数基础1.1. 函数定义1.2. 函数的调用1.3. 参数1.3.1. 参数简写1.3.2. 可变参数1.4. 返回值1.4.1. 多个返回值1.4.2. 返回值命名1.4.3. 返回值补充2. 函数进阶2.1. 变量作用域2.1.1. 全局变量2.1.2. 局部变量2.1.3. 局部变量优先2.1.4. if、for、语句块中的局部变量2.2. 函数类型与变量2.2.1. 定义函数类型2.2.2. 函数类型变量2.3. 高阶函数2.3.1. 函数作为参数2.3.2. 函数作为返回值2.4. 匿名函数与闭包2.4.1. 匿名函数2.4.2. 闭包2.5. defer语句2.5.1. defer执行时机2.5.2. defer经典案例2.5.3. defer面试题3. 内置函数介绍3.1. panic/recover4. 练习1. 函数基础 1.1. 函数定义 函数是什么？ ​ 函数是组织好的，可复用的，具有特定功能的代码块； go中，支持函数、匿名函数、闭包； 函数定义格式： func 函数名(参数)(返回值){ 函数体 } 其中： 函数名：字母、数字、下划线组成，不能以数字开头，（同一个包内，函数名不能重复） 参数：参数与参数变量、参数变量的类型组成，多个参数由,分隔 返回值：返回值变量、和其变量类型组成，也可以只写返回值的类型，多个返回值需要用（）包裹，用,分隔 函数体：实现特定功能的代码块 demo1：2个简单函数示例： 求和函数 打印字符串函数 package main import \"fmt\" // 求2个整数之和的函数 func sumInt(x int, y int) (res int) { res = x + y return } // 没有参数，和返回值的函数 func justPrint() { fmt.Printf(\"just print\") } func main() { a := sumInt(2, 5) fmt.Println(a) justPrint() } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go 7 just print 1.2. 函数的调用 func main() { a := sumInt(2, 5) fmt.Println(a) justPrint() } // 根据函数名即可调用，依据函数格式，传参或者不传参； // 有返回值的函数，也可不接收其返回值 1.3. 参数 1.3.1. 参数简写 当多个传参的类型一致时，可以在最后只写一次它们的类型，如下sumInt2所示： // 求2个整数之和的函数 func sumInt(x int, y int) int { var res = x + y return res } // 参数的数据类型简写 func sumInt2(x, y int) int { var res = x + y return res } 1.3.2. 可变参数 可变长的传参，本质是一个切片，打印其类型，可以发现， package main import \"fmt\" // 可变长传参数 func sumInt3(x int, y ...int) int { // 格式：参数名...参数类型，用省略号表示 sum := x fmt.Printf(\"type of y:%T\\n\", y) for _, v := range y { sum += v } return sum } // 没有参数，和返回值的函数 func justPrint() { fmt.Printf(\"just print\") } func main() { r1 := sumInt3(100, 10) r2 := sumInt3(100, 10, 20) r3 := sumInt3(100, 10, 20, 30) fmt.Println(r1, r2, r3) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go type of y:[]int type of y:[]int type of y:[]int 110 130 160 1.4. 返回值 1.4.1. 多个返回值 package main import \"fmt\" // 多返回值，当一个函数具有多个返回值时，必须用()将其返回值的类型都包裹起来 func f1(x, y int)(int, int) { sum := x + y sub := x - y return sum, sub } // 返回值命名 // 返回值补充 func main() { fmt.Println(f1(10, 8)) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go 18 2 1.4.2. 返回值命名 package main import \"fmt\" // 返回值命名 // 在定义返回值的第二个扩号，定义了返回值的变量名：sum和sub，相当于已经先声明了变量名 // 因此在函数体中，可以直接使用，因此使用的是= 直接赋值，而不是:= 声明并赋值 // return时，也无需指定返回哪个值，（因为就是返回sum和sub func f2(x, y int)(sum, sub int) { sum = x + y sub = x - y return } // 返回值补充 func main() { fmt.Println(f1(10, 8)) fmt.Println(f2(8, 6)) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go 18 2 14 2 1.4.3. 返回值补充 不对？ // 返回值补充,当返回值是一个空的切片时，可以直接返回一个nil，nil可以作为空的切片返回，而无需[]int{} func f3(x string) []int { if x == \"\" { return nil } } func main() { fmt.Println(f1(10, 8)) fmt.Println(f2(8, 6)) fmt.Println(f3(\"\")) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go # command-line-arguments .\\main.go:27:1: missing return at end of function 2. 函数进阶 2.1. 变量作用域 2.1.1. 全局变量 package main import \"fmt\" // 全局变量 var n1 int = 10 func main() { fmt.Println(n1) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go 10 2.1.2. 局部变量 package main import \"fmt\" // 全局变量 var n1 int = 10 func f1(x int) int { sum := x + 1 fmt.Println(x) return sum } func main() { fmt.Println(n1) fmt.Println(x) } // 编译报错，x未定义，因为x只在 f1函数内生效 ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go # command-line-arguments .\\main.go:18:14: undefined: x 2.1.3. 局部变量优先 // 全局变量、局部变量，同名时，局部变量优先 package main import \"fmt\" // 全局变量 var n1 int = 10 func f1(x int) int { sum := x + 1 fmt.Println(x) return sum } func main() { var n1 int = 100 fmt.Println(n1) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go 100 2.1.4. if、for、语句块中的局部变量 func main() { var n1 int = 100 fmt.Println(n1) for i := 0; i 2.2. 函数类型与变量 2.2.1. 定义函数类型 不仅仅可以定义一般数据类型的变量，还可以定义类型为函数的变量： eg： package main import \"fmt\" type cal func(int, int) int // 定义了一个变量类型，其类型是接收2个int，返回一个int的函数类型，凡事满足该格式的函数定义，都是属于该类型，如下的add 和 sub func add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } var c cal = add // 定义了一个变量c，其类型是一个函数类型， // c 和 add都符合上面的函数类型定义，因此 add 和sub 都是 可以赋值给c //赋值后， c 和 add一样，具有了add函数的功能 func main() { fmt.Println(c(10, 100)) fmt.Println(add( 100, 100)) } $ go run main.go 110 200 2.2.2. 函数类型变量 package main import \"fmt\" type cal func(int, int) int // 定义了一个变量类型，其类型是接收2个int，返回一个int的函数类型，凡事满足该格式的函数定义，都是属于该类型，如下的add 和 sub func add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } func main() { c := add // add 和sub都属于上述定义的cal函数类型，将其分别赋值给c和d后，c，d也成为了该类型的变量； d := sub fmt.Println(c(10, 100)) fmt.Printf(\"type of c :%T\\n\", c) fmt.Println(d(100, 10)) fmt.Printf(\"type of d :%T\\n\", d) // 打印其类型，函数类型 } $ go run main.go 110 type of c :func(int, int) int 90 type of d :func(int, int) int 2.3. 高阶函数 高阶函数中：函数可以作为参数，也可以作为返回值； 2.3.1. 函数作为参数 package main import \"fmt\" // 高阶函数：函数作为参数 func add(x, y int) int { return x + y } func cal(x, y int, op func(int, int) int) int { // 传参为2个整型，一个函数型，（该函数类型为接收2个int，返回一个int），整体该函数返回一个int整型 return op(x, y) // 返回的int整型为，传递的函数对x和y处理后的结果， } func main() { res := cal(10, 20, add) // 传递10，20 2个整型，一个函数名，add，该add函数符合cal传参的要求， fmt.Println(res) } $ go run main.go 30 2.3.2. 函数作为返回值 package main import ( \"errors\" \"fmt\" ) // 高阶函数：函数作为返回值 func add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } func do(s string) (func(int, int) int, error) { switch s { case \"+\": return add, nil case \"-\": return sub, nil default: err := errors.New(\"无法识别的操作符\") return nil, err } } func main() { fmt.Println(do(\"+\")) fmt.Println(do(\"-\")) fmt.Println(do(\"*\")) } ten@LAPTOP-5TPRJ6VQ MINGW64 /d/workstation/mycode/gocode/src/learngo/basic_grammar/08_func (master) $ go run main.go 0x49e750 0x49e770 无法识别的操作符 2.4. 匿名函数与闭包 2.4.1. 匿名函数 在函数内部定义的函数，不可以加名字，即匿名函数，匿名函数可以有传参和返回值，但是不可以通过名字调用，所以匿名函数1：保存到变量，通过变量名调用，2：定义为立即执行函数，定义后通过()直接传参使用 e.g. package main import \"fmt\" // 匿名函数 func main() { // 将匿名函数保存到变量 add := func(x, y int) { fmt.Println(x + y) } add(10, 20) // 自执行函数，添加完匿名函数直接执行，适合只运行一次的代码块 func(x, y int) { fmt.Println(x - y) }(20, 10) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go 30 10 匿名函数，多用于回调函数，和闭包 2.4.2. 闭包 闭包定义 闭包，首先是一个函数 闭包，还包含对其外部作用域的变量的引用 闭包就是：函数，和该函数对其外部作用域变量的引用，2者的集合 符合闭包定义的示例 package main import \"fmt\" func add(x int) func(int) int{ return func(y int) int { x += y return x } } func main(){ res := add(10) // res 是add函数的返回值，返回值是一个函数类型，该函数接收一个int，返回一个int // 向res传一个20，y=20，返回的x=x+20，而x=10，是add中一开始传递的10，所以最终结果是30 // 闭包是一个函数 // 闭包且包含其函数外部作用域的变量 // 所以，闭包就是：函数+函数外部作用域的变量的引用 fmt.Println(res(20)) } demo1 下例的f是adder函数的返回值，是函数类型，此时f就是一个闭包，包含其函数定义和其外部作用域的变量x，闭包包含的范围如下： var x int // 没赋值，默认是0 return func(y int) int { x += y return x } // return不算 package main import \"fmt\" func adder() func(int) int { var x int // 没赋值，默认是0 return func(y int) int { x += y return x } } func main() { f := adder() // f是一个函数类型，接收一个int，返回一个int的函数类型 // 注意x是f函数的外部作用域的变量，每调用一次f函数，对x的修改是会累积的 // 此时f就是一个闭包，其生命周期内，x一直有效，且是同一个x fmt.Println(f(10)) // 10 fmt.Println(f(20)) // 30 fmt.Println(f(30)) // 60 // 又新调用了一次adder，此时x重新等于0 f1 := adder() fmt.Println(f1(30)) // 30 fmt.Println(f1(50)) // 80 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go 10 30 60 30 80 利用闭包封装函数，传递到另一个函数的传参中，示例： package main import \"fmt\" func f1(f func()) { fmt.Println(\"this is f1\") f() } func f2(x, y int) { fmt.Println(\"this is f2\") fmt.Println(x + y) } // 要求：f1(f2) 将f2传递到f1中 // 因f2的函数类型，不符号f1能接收的类型 // 需要用闭包包装一下 // 包装思路： // f2 不能直接传递到f1中，那先构造一个能接收f2类型传参的函数f3， // 现在，f2能“套进”f3里了，f3再返回一个符合f1传参要求的函数类型，调用f3获得返回的函数，现在f3返回的函数类型能“套进”f1的传参里了 // 1，调用f3获得返回值 2，f3的返回值传递给f1，该返回值是符号f1传参要求的 没有传参，没有返回值的函数，该函数在f3中时一个匿名函数，其中调用了传递给f3的f2函数，从而实现了传递f2到f1中 // 总结：就是包装，f3中通过定义个匿名函数，将接收进来的f2包装一下，然后返回该匿名函数（该匿名函数符合f1的传参要求 // 如下是f3的包装示例 func f3(f func(int, int), x, y int) func() { // 第一个传参f构造的和f2的函数类型一样，能接收f2 // x y 是f2的传参要求，2个int类型， // 这些参数传递给f3后，实现了一个效果：f3中可以调用f2了 tmp := func() { f(x, y) } // 定义个匿名函数，其中调用了f，即传递进来的f2，再将该匿名函数当作返回值返回，（实际相当于返回了f2，因为匿名函数的函数体只有一个功能，即调用执行f2，这就实现了将f2通过包装“套壳”传递进了f1中 return tmp // 另一个写法 直接return // return func () { // f(x, y) // } } func main() { res := f3(f2, 100, 200) // 此时 res是f3的返回值，是无传参，无返回值的函数类型，就是套在f2函数的壳子，但因为满足f1的传参要求，可以传递给f1 f1(res) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go this is f1 this is f2 300 闭包示例1 package main import \"fmt\" func adder(x int) func(int) int { return func(y int) int { x += y return x } } func main() { f1 := adder(10) fmt.Println(f1(20)) // 30 fmt.Println(f1(20)) // 50 fmt.Println(f1(40)) // 90 f2 := adder(30) fmt.Println(f2(80)) // 110 fmt.Println(f2(80)) // 190 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go 30 50 90 110 190 闭包示例2:构造一个文件后缀批量更新函数 package main import ( \"fmt\" \"strings\" ) func makeSuffix(sufffix string) func(string) string { return func(name string) string { if !strings.HasSuffix(name, sufffix) { return name + sufffix } return name } } func main() { txtFunc := makeSuffix(\".txt\") jpgFunc := makeSuffix(\".jpg\") // 得到2个闭包，其函数部分功能上是判断传入字符串是否是某后缀，是不变，不是就加上该结尾， // 分别是txt jpg结尾 fmt.Println(txtFunc(\"file1\")) // file1.txt fmt.Println(txtFunc(\"file1.txt\")) // file1.txt fmt.Println(jpgFunc(\"file2\")) // file2.jpg fmt.Println(jpgFunc(\"file2.jpg\")) // file2.jpg } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go file1.txt file1.txt file2.jpg file2.jpg 闭包示例3 package main import \"fmt\" func calc(base int) (func(int) int, func(int) int) { add := func(i int) int { base += i return base } sub := func(i int) int { base -= i return base } return add, sub } func main() { f1, f2 := calc(10) // 获得一个闭包，2个函数，分别有加减功能，外部变量是一个base fmt.Println(f1(1), f2(2)) // 11 9 fmt.Println(f1(3), f2(4)) // 12 8 fmt.Println(f1(5), f2(6)) // 13 7 // 需要注意的是，三次打印都是同一个f1，f2，所以base都是同一个外部变量，对base的更改是对下次操作有影响的， } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go 11 9 12 8 13 7 2.5. defer语句 defer作用： defer会将定义其后的语句，暂存起来，延后执行，底层实现应该是一个栈结构，先进后出，defer所在函数，在返回时，把函数内部定义的defer语句，按照出现顺序的逆序执行，即：先定义的defer后执行 defer可以延迟执行语句，常用语，函数执行完毕时，释放资源，清理数据，文件关闭，锁释放，等操作，如一个建立网络连接的函数，中定义defer，在函数返回时，通过defer中定义的语句，释放网络连接 一个例子： // defer 语句 package main import \"fmt\" func main() { fmt.Println(\"start\") defer fmt.Println(\"1\") defer fmt.Println(\"2\") defer fmt.Println(\"3\") fmt.Println(\"end\") } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go start end 3 2 1 2.5.1. defer执行时机 golang中，return语句，底层实现，并不是不可拆解的原子操作，而是分为2步，1：返回值赋值，2：ret指令返回返回值 defer执行时机，就在这2步中间 2.5.2. defer经典案例 package main import \"fmt\" // defer经典案例 func f1() int { x := 5 defer func() { x++ }() return x } // 5 /* 过程分析： 调用f1时，定义一个x，并赋值给5 遇到了defer语句，先把改函数，“暂存起来” return x 分3步： 1，返回值赋值，即返回值现在=x=5 2，执行defer中函数，该函数是无传参，无返回值的匿名函数，功能就是x++，匿名函数内部没有x，向外找，找到了f1定义的x，即5+1，此时f1内部的x变成了6 3，ret指令，返回返回值，返回值是5，因为返回值=x=5时，它的值就固定为了5，和x的变化已经没有关系咯 */ func f2() (x int) { defer func() { x++ }() return 5 } // 6 /* 分析： 遇到个defer，把后面的匿名函数，暂存起来 return 5分三步： 1，返回值此时就是x变量，（因为返回值中指明了用x接收返回值，返回值就是x=5 2，执行defer，该匿名函数，执行x++，x在匿名函数内没有，向外找，外部有一个x变量，即用来当返回值容器的x变量，此时执行x++，x变成了6 3，执行ret指令，ret指令，返回返回值是x，x是6 */ func f3() (y int) { x := 5 defer func() { x++ }() return x } // 5 /* 分析： 先定义个x，赋值为5 遇到defer，暂存后面的匿名含数 return x分3步 1，返回值的容器现在是y；返回值=y=x=5 2，执行defer，匿名函数功能使得x+1，变成6 7，ret指令，返回的返回值放在容器“y“中，返回的结果最终是5 */ func f4() (x int) { // 这个x，是f4内部的x defer func(x int) { // 这个x是匿名函数内部的x，是用于存放其传参值的容器 x++ // 这个x是匿名函数内部的x }(x) // 这个x也是f4内部的x，在return语句的第一步，x被赋值为了5，所以就变成了一个具体数字 return 5 } // 5 /* 分析： 遇到defer，暂存后面的匿名含数 return 5分三步 1，返回值的容器此时是x；返回值=x=5 2，执行defer，匿名函数，接收一个int传参，调用时，传入的是x，x的值是5，函数内部执行x++，即5+1,变成6 3，执行ret指令，返回值的容器是x，x此时是5 容易迷惑的点： 此x非彼x，一共出现四个x，其实是2个不同的变量，不同的作用范围 */ func main() { fmt.Println(f1()) fmt.Println(f2()) fmt.Println(f3()) fmt.Println(f4()) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go 5 6 5 5 2.5.3. defer面试题 package main import \"fmt\" func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { x := 1 y := 2 defer calc(\"AA\", x, calc(\"A\", x, y)) x = 10 defer calc(\"BB\", x, calc(\"B\", x, y)) y = 20 } /* 要点，defer注册的延迟执行的函数，其所有传参的值，要是确定下来的！！！ 过程分析： 1，x = 1 y =2 2, 执行calc(\"A\", x, y)， 打印出 A 1 2 3 返回一个3 3，defer注册一个calc(\"AA\", 1, 3) 4， x 赋值为 10 5，执行calc(\"B\", x, y)，即calc(\"B\", 10, 2) 打印出 B 10 2 12, 返回一个12 6，defer注册一个calc(\"BB\", 10, 12) 7， y 赋值为 20 准备返回 先执行calc(\"BB\", 10, 12) 打印出 BB 10 12 22 后执行calc(\"AA\", 1, 3) 打印出 AA 1 3 4 最终输出结果： A 1 2 3 B 10 2 12 BB 10 12 22 AA 1 3 4 */ latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go A 1 2 3 B 10 2 12 BB 10 12 22 AA 1 3 4 3. 内置函数介绍 常见内置函数： close：关闭channel len，求长度，string，array，alice，map，channel new，分配内存，主要用于值类型，如int，struct，返回的是指针 make，分配内存，主要用于引用类型，如chan，map，slice append，追加元素到数组、slice中 panic，和recover，做错误处理 3.1. panic/recover golang中，目前没有异常机制，使用panic/recover模式处理错误，panic可以在任何地方触发，但recover只有在defer调用的函数中有效， 手动模拟panic触发示例： 遇到funcB中的手动模拟的panic后，funcC函数就无法执行了，程序异常退出 package main import \"fmt\" func funcA() { fmt.Println(\"funcA\") } func funcB() { panic(\"panic in B\") } func funcC() { fmt.Println(\"funcC\") } func main() { funcA() funcB() funcC() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go funcA panic: panic in B goroutine 1 [running]: main.funcB(...) D:/myCode/Go/src/learngo/basic_grammar/08_func/main.go:10 main.main() D:/myCode/Go/src/learngo/basic_grammar/08_func/main.go:18 +0x9d exit status 2 定义recover捕捉panic recover可以捕捉panic的发生，并处理panic，然后执行向下执行，使得程序不会中断退出 要点： recover（）必须搭配defer使用 defer一定在可能发生panic的地方之前，（可以放在函数第一行）否则发现panic遇不到defer package main import \"fmt\" func funcA() { fmt.Println(\"funcA\") } func funcB() { /* 将recover处理函数定义在defer中，defer一定在可能发生panic的地方之前，（可以放在函数第一行）否则发现panic遇不到defer 发生panic时，recover就有值，此时err就不为空 if判断，若err不为空时，打印提示信息，recover函数使得代码能继续执行 */ defer func() { err := recover() if err != nil { fmt.Println(\"there is panic in funcB , but already recovered , program can continue\") } }() panic(\"panic in B\") } func funcC() { fmt.Println(\"funcC\") } func main() { funcA() funcB() funcC() } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go funcA there is panic in funcB , but already recovered , program can continue funcC 4. 练习 分金币： package main import \"fmt\" /* 你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。 分配规则如下： a. 名字中每包含1个'e'或'E'分1枚金币 b. 名字中每包含1个'i'或'I'分2枚金币 c. 名字中每包含1个'o'或'O'分3枚金币 d: 名字中每包含1个'u'或'U'分4枚金币 写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？ 程序结构如下，请实现 ‘dispatchCoin’ 函数 */ /* 思路： 编写一个dispatchCoin()函数实现 变量coins存储金币总量； 变量users切片存储所有人员姓名； 变量distribution的map存储每个人和其对应分的的金币数 该函数逻辑： 遍历存放了所有人员的切片， 每个人员的名字，遍历每个字符， 利用case，分4种情况，每符号一种情况，就向该人员所在的map中，其值部分加相应数量的金币，并在金币数量上减去相应部分 所有人员遍历下来， 变量map 打印每个人姓名和，其对应金币数 return 剩余的金币数，就得到了剩余的金币数 */ var ( coins = 50 users = []string{ \"Matthew\", \"Sarah\", \"Augustus\", \"Heidi\", \"Emilie\", \"Peter\", \"Giana\", \"Adriano\", \"Aaron\", \"Elizabeth\", } distribution = make(map[string]int, len(users)) ) func dispatchCoin() int{ for _, name := range users { for _, char := range name { switch char { case 'e': distribution[name] ++ coins -- // 这里没有用+=和-=，是因为vscode提示，用++ --，更好 case 'i': distribution[name] += 2 coins -= 2 case 'o': distribution[name] += 3 coins -= 3 case 'u': distribution[name] += 4 coins -= 4 } } } for n, num := range distribution { fmt.Printf(\"%v:%v\\n\", n, num) } return coins } func main() { left := dispatchCoin() fmt.Println(\"剩下：\", left) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/08_func (master) $ go run main.go Heidi:5 Emilie:5 Giana:2 Aaron:3 Matthew:1 Augustus:12 Peter:2 Adriano:5 Elizabeth:3 剩下： 12 latteplus            updated 2021-02-15 10:40:45 "},"1-go基础语法/1.9go基础语法之指针.html":{"url":"1-go基础语法/1.9go基础语法之指针.html","title":"1.9go基础语法之指针","keywords":"","body":"1. golang指针介绍1.1. 指针地址和指针类型1.2. 指针取值1.3. 指针传值1.4. new与make1.4.1. new1.4.2. make1.4.3. new与make的区别1. golang指针介绍 区别于c/c++中指针，golang中指针不能进行偏移和运算，是安全指针 指针是什么？ 程序指令和程序要操作的数据，载入内存后，在内存都有自己的地址，这就是指针，为了保存一个数据在内存中的地址，需要指针变量：也可看作一种数据类型，像int，string一样，只不过该变量存储的数据是某数据的内存地址，0x开头的内存地址 指针举例： 定义一个string类型heiheihei，用变量s1存储，s1这个变量在内存中就会有一个地址，假设是0x123456，然后将0x123456这个内存地址赋值给变量p1，此时，变量p1就是一个指针变量，（因它存储的数据类型是指针/是一个内存地址；通过变量s1和变量p1都可以找到heiheihei 指针就类比与门牌号，不同门牌地址里，住着不同的数据 指针操作种类： 取内存地址& 根据内存地址取值* 1.1. 指针地址和指针类型 变量在程序运行时，都有一个内存地址；该地址代表了该变量存储在内存的哪个位置， &符号放在变量名前面，表示取得该变量的内存地址，如：&a golang中的值类型（int float bool string array struct）都有对应的指针类型，如int int64 *string（说人话就是：某个指针变量，其存储了一个内存地址，根据这个内存地址摸上门去，里面是啥类型的数据，该指针变量就是啥类型的指针类型 一个栗子： package main import \"fmt\" func main() { a := 5 b := \"heiheihei\" ptrA := &a ptrB := &b fmt.Printf(\"%d %p %p\\n\", a, ptrA, &a) // 打印变量a的值，和变量a所在的内存地址 fmt.Printf(\"%s %p %p\\n\", b, ptrB, &b) // 打印变量b的值，和变量b所在的内存地址 fmt.Printf(\"%T\\n\", ptrA) fmt.Printf(\"%T\\n\", ptrB) // 打印ptrA ptrB的指针类型，分别是*int *string } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/09_ptr (master) $ go run main.go 5 0xc0000140b0 0xc0000140b0 heiheihei 0xc0000481f0 0xc0000481f0 *int *string b := &a 的图示： 1.2. 指针取值 &放在变量名前，是取变量的地址 *放在指针变量名前，是取指针变量，执向的内存地址中，其存储的值 两者为互反操作 package main import \"fmt\" func main() { a := 10 b := &a c := *b fmt.Printf(\"%v %T\\n\", a, a) fmt.Printf(\"%v %T\\n\", b, b) fmt.Printf(\"%v %T\\n\", c, c) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/09_ptr (master) $ go run main.go 10 int 0xc0000140b0 *int 10 int 1.3. 指针传值 package main import \"fmt\" func modify1(x int) { // 接收的是int类型的数据 x = 100 } func modify2(x *int) { // 接收的是指向一个int类型数据的指针（一个内存地址） *x = 100 // 对内存地址加* ，可以找到其指向的值，从而实现修改本函数外变量的目的 } func main() { a := 10 modify1(a) fmt.Println(a) // 还是10 modify2(&a) // 传递的是a的指针，即a的内存地址 fmt.Println(a) // 此时a是100，在modify2中被通过指针/内存地址，找上门儿来，改掉其值 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/09_ptr (master) $ go run main.go 10 100 1.4. new与make 一个错误的栗子 该例子会引发panic，因为：go中对于引用类型的变量，要想使用有两步：1、声明该变量；2、显式给该变量申请内存；之后就可以正常使用；对与值类型的变量，要想使用有一步：1、声明该类型的一个变量就行，（因为声明时会默认分配好内存，无需用户显式申请） 申请内存的函数：new和make，golang内置的函数 package main import \"fmt\" func main() { var a *int // 声明一个指针变量，将来存储的内存地址，指向的应该是一个int类型数据 *a = 100 // 通过对指针变量取值，找到其内存地址，向其中存储一个int类型数据，为100 fmt.Println(*a) var b map[string]int // 声明一个map类型变量b， b[\"dashuaibi\"] = 100 // 直接使用它，并向它赋值，不行！因还没申请内存 fmt.Println(b) } // 错误如下： latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/09_ptr (master) $ go run main.go panic: runtime error: invalid memory address or nil pointer dereference [signal 0xc0000005 code=0x1 addr=0x0 pc=0x49e77a] goroutine 1 [running]: main.main() D:/myCode/Go/src/learngo/basic_grammar/09_ptr/main.go:7 +0x2a exit status 2 1.4.1. new 1、new的函数定义 func new(Type) *Type 接收一个传参：为某个数据类型，如int，string，map这些； 返回一个该类型的指针，即返回一个内存地址，其指向某个数据类型的某个数据如传入int，返回一个int，传入一个string返回一个\\string 2、new使用示例 new函数不常用，使用new函数得到是某个数据类型的数据的指针，通过该指针找到那块内存，就可以向其中写入该类型的具体数据了 package main import \"fmt\" func main() { a := new(int) // 获得一个指针，即获得一个内存地址，该内存地址可以存储一个int数据 b := new(bool) // 获得一个指针，即获得一个内存地址，该内存地址可以存储一个bool数据 // 且默认情况下，获得的内存地址，其中存储的数据，是该类型的“零值” 比如int的是0，bool的是false fmt.Println(*a) // 0 fmt.Println(*b) // false fmt.Println(a) fmt.Println(b) fmt.Printf(\"%T\\n\", a) fmt.Printf(\"%T\\n\", b) *a = 100 *b = true fmt.Println(*a) fmt.Println(*b) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/09_ptr (master) $ go run main.go 0 false 0xc0000140b0 0xc0000140b8 *int *bool 100 true 3、使用new对上述错误例子的修正 // var a *int 错误之处：声明了一个指针变量，但是没有初始化，意思是，该变量没有值，即没有填充一个内存地址，即不知道指向那块内存，（但是a变量本身，是存储指针的变量，它应该是已经有内存的，只是它里面没有填充值，所以*a通过内存地址取值的时候会panic，因为你根本还没存储一个内存地址,也不可能给他一个默认的零值，内存地址哪有默认的零值，瞎指指坏了咋整） // 修改后 func main() { var a *int // a变量有内存，但是它里面没有值，没有存储一个内存地址 a = new(int) // new函数，返回一个*int，即一个内存地址，该内存地址指向的地方能存储一个int数据，该内存地址赋值给a，此时a就有值了，也就是初始化 *a = 100 // 通过a获得内存地址，然后向里写入一个100 fmt.Println(*a) } 1.4.2. make make函数也是用于分配内存，区别与new，它只能用于slice、map、channel的内存创建；且其返回的东西，就是该类型本身，而不是它们的指针（它们的内存地址） 1、make函数的定义 定义slice、map、channel时，都需要先用make申请内存，才可以使用它们 func make(t Type, size ...IntegerType) Type 2、make函数使用示例 func main() { var b map[string][int] b = make(map[string][int], 10) b[\"dashuaibi\"] = 100 fmt.Println(b) } 1.4.3. new与make的区别 两者都是用于内存分配； make只用于slice、map、channel的内存分配，返回的是这三个类型本身 new用于类型的内存分配，并且分配的内存，默认其填充值是该类型的“零值”，返回的是指向该类型数据的指针（说人话：就是返回的是一个能存储该类型数据的内存地址） latteplus            updated 2021-02-15 10:40:45 "},"2-go与数据库/1-go操作mysql.md.html":{"url":"2-go与数据库/1-go操作mysql.md.html","title":"1-go操作mysql.md","keywords":"","body":"1. go操作mysql1.1. 连接1.1.1. 　下载依赖1.1.2. 使用mysql驱动1.1.3. 初始化连接1.1.4. SetMaxOpenConns1.1.5. SetMaxIdleConns1.2. CRUD1.2.1. 建库建表1.2.2. 查询数据1.2.3. 插入数据1.2.4. 更新数据1.2.5. 删除数据1.2.6. 总结：1.3. mysql预处理1.3.1. 什么是预处理1.3.2. 为什么要预处理1.3.3. go实现mysql预处理1.3.4. sql注入1.4. go实现mysql事务1.4.1. 什么是事务1.4.2. 事务的ACID1.4.3. 事务相关方法1.4.4. 事务示例2. 练习1. go操作mysql 1.1. 连接 golang中，database/sql包提供了保证sql或类sql数据库的泛用接口，并不提供具体的数据库驱动，相当于定义了一个通用规范，使用database/sql包时必须注入一个数据库驱动（其必须实现sql包定义的接口规范） 常用的数据库都有现成的连接库实现：如myql驱动 1.1.1. 　下载依赖 $ go get -u github.com/go-sql-driver/mysql 1.1.2. 使用mysql驱动 Open函数签名： func Open(driverName, dataSourceName string) (*DB, error) 其中： driveName表示数据库类型，mysql，pgsql这种 dataSourceName表示数据库连接字符串，ip端口用户名密码这些 返回一个DB类型的指针类型，和可能的error 连接示例： package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) func main() { // DSN:data source name dsn := \"root:123456@tcp(192.168.80.100:3306)/mysql\" db, err := sql.Open(\"mysql\", dsn) if err != nil { panic(err) } defer db.Close() fmt.Println(\"connect mysql is successful\") } $ ./mysql.exe connect mysql is successful 1.1.3. 初始化连接 上例中，使用sql.Open只是校验了参数的准确与否，并不实际检测于mysql的连接是否正常，若要检测，需要用db对象的Ping()方法 返回的DB对象，可以安全被多个goroutine并发使用，并维护自己的空闲连接池，open函数仅仅应该被调用一次，很少需要关闭DB对象 e.g. package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) // 定义一个全局的DB对象 var db *sql.DB func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/db1?charset=utf8mb4&parseTime=True\" // 并不尝试与数据库建立连接 db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } // 测试与数据库的连接 err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") } $ ./mysql.exe init db failed Error 1130: Host '192.168.80.1' is not allowed to connect to this MariaDB server 因为mysql默认没有放行程序所在ip，所以不通 放行 MariaDB [(none)]> grant all on *.* to root@'192.168.80.%' identified by '123456'; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]> flush privileges; Query OK, 0 rows affected (0.01 sec) 再运行 $ ./mysql.exe init db success! *sql.DB是表示连接的数据库对象，结构体，保存了数据库连接相关的信息，内部维护了一个具有0到多个底层连接的连接池，可以被安全的被goroutine并发使用 定义： type DB struct { // Atomic access only. At top of struct to prevent mis-alignment // on 32-bit platforms. Of type time.Duration. waitDuration int64 // Total time waited for new connections. connector driver.Connector // numClosed is an atomic counter which represents a total number of // closed connections. Stmt.openStmt checks it before cleaning closed // connections in Stmt.css. numClosed uint64 mu sync.Mutex // protects following fields freeConn []*driverConn connRequests map[uint64]chan connRequest nextRequest uint64 // Next key to use in connRequests. numOpen int // number of opened and pending open connections // Used to signal the need for new connections // a goroutine running connectionOpener() reads on this chan and // maybeOpenNewConnections sends on the chan (one send per needed connection) // It is closed during db.Close(). The close tells the connectionOpener // goroutine to exit. openerCh chan struct{} closed bool dep map[finalCloser]depSet lastPut map[*driverConn]string // stacktrace of last conn's put; debug only maxIdle int // zero means defaultMaxIdleConns; negative means 0 maxOpen int // 1.1.4. SetMaxOpenConns func (db *DB) SetMaxOpenConns(n int) 设置最大能打开的连接数目，若n大于0，小于最大空闲的连接数，则最大空闲连接数会减少到匹配最大开启连接的限制 1.1.5. SetMaxIdleConns func (db *DB) SetMaxIdleConns(n int) 设置最大空闲连接数 1.2. CRUD 1.2.1. 建库建表 1、建立测试库 MariaDB [sql_test]> create database sql_test; 2、切换到测试库 MariaDB [sql_test]> use sql_test; 3、创建测试表 MariaDB [sql_test]> CREATE TABLE `user` ( -> `id` BIGINT(20) NOT NULL AUTO_INCREMENT, -> `name` VARCHAR(20) DEFAULT '', -> `age` INT(11) DEFAULT '0', -> PRIMARY KEY(`id`) -> )ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; Query OK, 0 rows affected (0.01 sec) 1.2.2. 查询数据 0、向user表插入几条数据 MariaDB [sql_test]> insert user( name, age) values(\"wang\", 24); Query OK, 1 row affected (0.00 sec) MariaDB [sql_test]> insert user( name, age) values(\"li\", 22); Query OK, 1 row affected (0.00 sec) MariaDB [sql_test]> insert user( name, age) values(\"zhangsan\", 18); Query OK, 1 row affected (0.00 sec) MariaDB [sql_test]> select * from user; +----+----------+------+ | id | name | age | +----+----------+------+ | 1 | wang | 24 | | 2 | li | 22 | | 3 | zhangsan | 18 | +----+----------+------+ 1、定义对user表对应的结构体，用于存储一条数据条目 全局定义 type user struct { id int name string age int } 2、单行查询 单行查询函数签名： func (db *DB) QueryRow(query stirng, args ...interface{}) *Row package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func queryRow() { var u1 user // 声明一个变量u1 sqlStr := `select id ,name, age from sql_test.user where id = ?` // QueryRow传入一个包含占位符的字符串，占位符用？表示 // QueryRow得到一个*Row对象，该对象的Scan方法可以将查的数据存放到其参数的变量中 // QueryRow之后，一定调用Scan方法，来释放数据库连接 err := db.QueryRow(sqlStr, 1).Scan(&u1.id, &u1.name, &u1.age) if err != nil { fmt.Println(\"query and scan failed\") return } fmt.Println(u1.id, u1.name, u1.age) } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/db1?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") queryRow() } $ ./mysql.exe init db success! 1 wang 24 3、多行查询 多行查询函数Query签名 func (db *DB) Query(query string, args ...interface{}) (*Rows, error) e.g. package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func queryMutilRow() { var u1 user sqlStr := `select id , name, age from sql_test.user where id > ?` rows, err := db.Query(sqlStr, 0) if err != nil { fmt.Printf(\"query failed, err : %v\\n\", err) return } // 注册一个关闭连接函数 defer rows.Close() // 遍历多行 for rows.Next() { err = rows.Scan(&u1.id, &u1.name, &u1.age) if err != nil { fmt.Println(\"scan failed\") continue } fmt.Println(u1.id, u1.name, u1.age) } } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/db1?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") // queryRow() queryMutilRow() } $ ./mysql.exe init db success! 1 wang 24 2 li 22 3 zhangsan 18 1.2.3. 插入数据 插入、更新、删除操作都用Exec方法 func (db *DB) Exec(query string, args ...interface{}) (Result , error) 返回的Result是sql命令的执行结果的提示信息，args是 query字符串的占位参数 插入demo package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/db1?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func insertOne() { sqlStr := `insert into sql_test.user(name, age) values(?, ?)` res, err := db.Exec(sqlStr, \"haha\", 18) if err != nil { fmt.Println(\"insert failed\", err) return } id, err := res.LastInsertId() if err != nil { fmt.Println(\"get last id failed\", err) return } fmt.Println(\"insert id is : \", id) } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") insertOne() } 运行结果 $ ./mysql.exe init db success! insert id is : 4 MariaDB [sql_test]> select * from user -> ; +----+----------+------+ | id | name | age | +----+----------+------+ | 1 | wang | 24 | | 2 | li | 22 | | 3 | zhangsan | 18 | | 4 | haha | 18 | +----+----------+------+ 4 rows in set (0.00 sec) 1.2.4. 更新数据 package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/db1?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func updataDemo() { sqlStr := `update sql_test.user set age = ? where id > ?` res, err := db.Exec(sqlStr, 100, 1) if err != nil { fmt.Println(\"update failed\", err) return } num, err := res.RowsAffected() if err != nil { fmt.Println(\"row affect failed\", err) return } fmt.Printf(\"there was %d line was changed\\n\", num) } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") updataDemo() } 运行结果 $ ./mysql.exe init db success! there was 3 line was changed MariaDB [sql_test]> select * from user; +----+----------+------+ | id | name | age | +----+----------+------+ | 1 | wang | 24 | | 2 | li | 100 | | 3 | zhangsan | 100 | | 4 | haha | 100 | +----+----------+------+ 4 rows in set (0.00 sec) 1.2.5. 删除数据 package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/db1?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func deleteDemo() { sqlStr := `delete from sql_test.user where id = ?` res, err := db.Exec(sqlStr, 1) if err != nil { fmt.Println(\"delete failed\", err) return } num, err := res.RowsAffected() if err != nil { fmt.Println(\" get delelte operation affect num failed\", err) return } fmt.Printf(\"there was %d line was deleted \\n\", num) } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") deleteDemo() } 运行结果： $ ./mysql.exe init db success! there was 1 line was deleted MariaDB [sql_test]> select * from user; +----+----------+------+ | id | name | age | +----+----------+------+ | 2 | li | 100 | | 3 | zhangsan | 100 | | 4 | haha | 100 | +----+----------+------+ 3 rows in set (0.00 sec) 1.2.6. 总结： 查询使用db对象的QueryRow（单行）和Query（多行）方法，而插入、更新、删除都是用db对象的Exec方法；得到的对象有2个方法，分别是LastInsertId()和RowsAffected() 1.3. mysql预处理 1.3.1. 什么是预处理 普通sql执行过程 go程序把查询sql语法，发送给后端数据库， 数据库对sql进行编译，然后执行 将执行后的结果，返回给go程序 预处理sql执行过程 把sql分为2部分，命令部分和数据部分 将命令部分（常用且重复）发给数据库进行编译 然后把每次要执行的sql的数据部分（重复频率不高）发给数据库编译 数据库结合命令、数据编译部分的结果，执行命令 返回结果给go程序 1.3.2. 为什么要预处理 好处： 将重复用的命令部分一次编译，多次使用，减少了部分sql编译时间 避免sql注入问题 1.3.3. go实现mysql预处理 database/sql中使用Prepare()方法实现预处理操作 func (db *DB) Prepare(query string) (*Stmt , error) Prepare方法，会先将sql发到数据库，然后返回一个准备好的状态，即*Stmt对象，用于之后的命令，返回值可以同时执行多个查询命令 查询预处理示例代码： package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func prepareQueryDemo() { var u user // 先把包含占位符的sql语句发到数据库 sqlStr := `select id, name , age from user where id > ?` stat, err := db.Prepare(sqlStr) if err != nil { fmt.Println(\"prepare failed : \", err) return } defer stat.Close() // 用得到的stat的Query方法查询，把要查询的sql的数据部分传入 rows, err := stat.Query(1) if err != nil { fmt.Println(\"stat query failed, : \", err) return } defer rows.Close() // 得到的是row，利用Next（）方法遍历 for rows.Next() { err = rows.Scan(&u.id, &u.name, &u.age) if err != nil { fmt.Println(\"scan failed, :\", err) continue } fmt.Println(u.id, u.name, u.age) } } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") prepareQueryDemo() } 运行结果： $ ./mysql.exe init db success! 2 li 100 3 zhangsan 100 4 haha 100 插入预处理示例： package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func prepareInsertDemo() { // 先把包含占位符的sql语句发到数据库 sqlStr := `insert user(name, age) values(?, ?)` stat, err := db.Prepare(sqlStr) if err != nil { fmt.Println(\"prepare failed : \", err) return } defer stat.Close() _, err = stat.Exec(\"heihei\", 18) if err != nil { fmt.Println(\"stat exec first failed, \", err) return } // 执行多次 _, err = stat.Exec(\"haohaohao\", 78) if err != nil { fmt.Println(\"stat exec second failed, \", err) return } fmt.Println(\"insert two sucess!\") } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") prepareInsertDemo() } 运行结果： $ ./mysql.exe init db success! insert two sucess! MariaDB [sql_test]> select * from user; +----+-----------+------+ | id | name | age | +----+-----------+------+ | 2 | li | 100 | | 3 | zhangsan | 100 | | 4 | haha | 100 | | 5 | heihei | 18 | | 6 | haohaohao | 78 | +----+-----------+------+ 5 rows in set (0.00 sec) 更新、删除和更新类似 总结： 和普通的sql查询不同的步骤是： 先利用db.Prepare()把要执行的sql语句（包含占位符）发送给服务端 得到的*Stmt对象，执行Query或Exec方法，再把与占位符对应的部分传入，数据库端得以执行完整的sql，然后返回结果 得到*Stmt类型的变量时，注意defer 对象变量名.Close()注册一个关闭操作 得到的*Stmt对象，可以执行多次命令 1.3.4. sql注入 任何时候，都不应该自行拼接sql语句，下为一个自行拼接sql的示例：实现一个根据name字段查询user表的函数如下 package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } func sqlInjectDemo(name string) { sqlStr := fmt.Sprintf(\"select id, name, age from user where name = '%s'\", name) fmt.Println(sqlStr) var u user rows, err := db.Query(sqlStr) if err != nil { fmt.Println(err) return } defer rows.Close() for rows.Next() { err = rows.Scan(&u.id, &u.name, &u.age) if err != nil { fmt.Println(\"scan failed\", err) continue } fmt.Printf(\"user: %#v \\n\", u) } } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") sqlInjectDemo(\"xxx ' or '1=1\") } 用户输入正常时 $ ./mysql.exe init db success! select id, name, age from user where name = 'wang' user: main.user{id:1, name:\"wang\", age:18} 此时用户输入以下字符串作为查询条件，都会导致sql注入，引发安全问题 sqlInjectDemo(\"xxx ' or '1=1\") // 同样的还有： sqlInjectDemo(\"xxx' union select * from user #\") sqlInjectDemo(\"xxx' and (select count(*) from user) 不同的数据库中，sql语句中，使用的占位符不尽相同 数据库 占位符语法 mysql ？ postgreSQL $1 $2 sqllite ? $1 oracle :name 1.4. go实现mysql事务 1.4.1. 什么是事务 一组sql的操作，要么全部成功，要么失败回滚，该组sql组成的即是事务，典型的有银行的转账操作； 1.4.2. 事务的ACID 事务通常需要满足4个条件，ACID，原子性atomicity，一致性Consistency，隔离性Isolation，持久性Durability 条件 解释 原子性 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 1.4.3. 事务相关方法 Golang中用以下三个方法实现mysql中的事物操作 开始事务 func (db *DB) Begin() (*Tx, error) 提交事务 func (tx *TX) Commit() error 回滚事务 func (tx *TX) Rollback() error 1.4.4. 事务示例 下面为一个简单的事务操作，其中操作可以保证2次更新要么都成功，要么都失败，不存在中间状态 package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) var db *sql.DB type user struct { id int name string age int } /* 首先利用db.Begin()方法开启一个事务， 得到一个事务对象tx，和一个error类型err，判断err是否为空，不是这返回 判断tx是否为空，不是就返回 正常得到开启事务后： 利用事务的Exec（）方法执行一条更新语句， 判断得到的err，不为空则返回 判断得到影响的行数变量，不为空则返回 再执行一条更新语句， 判断得到的err，不为空则返回 判断得到影响的行数变量，不为空则返回 然后利用与操作判断2次更新的行数是否都为1， 都为1是，进行tx的提交事务操作 否则，进行tx的回滚操作 */ func transactionDemo() { tx, err := db.Begin() // 得到一个tx对象，和可能的err if err != nil { if tx != nil { tx.Rollback() } fmt.Println(\"事务开启失败:\", err) return } // 给用户id为1的用户年龄加100 sqlStr1 := `update user set age=age + 100 where id = ?` ret1, err := tx.Exec(sqlStr1, 1) if err != nil { fmt.Println(\"执行sql1失败，\", err) return } affectRow1, err := ret1.RowsAffected() if err != nil { fmt.Println(\"得到sql1执行后受影响的行数失败\", err) return } // 给用户id为2的用户年龄减去100 sqlStr2 := `update user set age=age - 100 where id = ?` ret2, err := tx.Exec(sqlStr2, 2) if err != nil { fmt.Println(\"执行sql2失败，\", err) return } affectRow2, err := ret2.RowsAffected() if err != nil { fmt.Println(\"得到sql2执行后受影响的行数失败\", err) return } // 判断2个语句是否都执行成功，若是，则进行事务的提交 if affectRow1 == 1 && affectRow2 == 1 { fmt.Println(\"事务将要进行提交\") tx.Commit() } else { fmt.Println(\"事务将进行回滚\") tx.Rollback() } } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" // 并不尝试与数据库建立连接 db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } // 测试与数据库的连接 err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed\", err) return } fmt.Println(\"init db success!\") transactionDemo() } 事务提交的结果 MariaDB [sql_test]> select * from user; +----+------+------+ | id | name | age | +----+------+------+ | 1 | wang | 18 | | 2 | li | 22 | | 3 | gu | 24 | +----+------+------+ 3 rows in set (0.00 sec) MariaDB [sql_test]> select * from user; +----+------+------+ | id | name | age | +----+------+------+ | 1 | wang | 118 | | 2 | li | -78 | | 3 | gu | 24 | +----+------+------+ 3 rows in set (0.00 sec) 事务执行失败，回滚的结果 // 给用户id为25的用户年龄加100 因为找不到id为25的用户，所以这句执行不成功，所以下面的if判断，就会执行事务回滚的逻辑， MariaDB [sql_test]> update user set age=age + 100 where id = 25; Query OK, 0 rows affected (0.00 sec) Rows matched: 0 Changed: 0 Warnings: 0 sqlStr1 := `update user set age=age + 100 where id = ?` ret1, err := tx.Exec(sqlStr1, 25) if err != nil { fmt.Println(\"执行sql1失败，\", err) return } 数据表，也不会有任何变化 MariaDB [sql_test]> select * from user; +----+------+------+ | id | name | age | +----+------+------+ | 1 | wang | 18 | | 2 | li | 22 | | 3 | gu | 24 | +----+------+------+ 3 rows in set (0.00 sec) 2. 练习 结合net/http和database/sql实现一个使用MySQL存储用户信息的注册及登陆的简易web程序。 暂略 latteplus            updated 2021-02-15 10:40:45 "},"2-go与数据库/2-go采用sqlx第三方库.html":{"url":"2-go与数据库/2-go采用sqlx第三方库.html","title":"2-go采用sqlx第三方库","keywords":"","body":"1. sqlx介绍2. sqlx安装3. sqlx基本使用3.1. 连接数据库3.2. 查询3.3. 插入、更新、删除3.4. NamedExec3.5. NamedQuery3.6. 事务操作4. sqlx.In4.1. sqlx.In的批量插入示例4.2. sqlx.In的查询示例1. sqlx介绍 sqlx可以认为是database/sql的超集，在其之上提供了一组扩展，包括Get，Select等查询相关的方法 参考链接 2. sqlx安装 go get github.com/jmoiron/sqlx 3. sqlx基本使用 3.1. 连接数据库 package main import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) var db *sqlx.DB func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sqlx.Connect(\"mysql\", dsn) if err != nil { return err } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed,\", err) return } fmt.Println(\"conncet database sucess!\") } $ ./sqlx.exe conncet database sucess! 3.2. 查询 查询单行： 注意结构体user的字段要首字母大写，对外可见；因为要被sqlx中的db对象的Get方法访问， package main import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) type user struct { Id int Name string Age int } var db *sqlx.DB func queryDemo() { sqlStr := `select id ,name ,age from user where id = ?` var u user err := db.Get(&u, sqlStr, 1) if err != nil { fmt.Println(\"get failed\", err) return } fmt.Printf(\"%v, %v, %v \\n\", u.Id, u.Name, u.Age) } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sqlx.Connect(\"mysql\", dsn) if err != nil { return err } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed,\", err) return } fmt.Println(\"conncet database sucess!\") queryDemo() } $ go run main.go conncet database sucess! id:1 name:wang age:18 查询多行： 查询多行，用db对象的Select方法 package main import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) type user struct { Id int Name string Age int } var db *sqlx.DB func queryMultiDemo() { sqlStr := `select id, name, age from user where id > ?` var u []user err := db.Select(&u, sqlStr, 1) if err != nil { fmt.Println(\"query failed:\", err) return } fmt.Println(u) } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sqlx.Connect(\"mysql\", dsn) if err != nil { return err } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed,\", err) return } fmt.Println(\"conncet database sucess!\") // queryDemo() queryMultiDemo() } $ go run main.go conncet database sucess! [{2 li 22} {3 gu 24}] 3.3. 插入、更新、删除 插入、更新、删除和原生的sql库中的使用方法几乎一致； 示例如下： package main import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) type user struct { Id int Name string Age int } var db *sqlx.DB func testSqlxInsertUpdateDelte() { sqlInsert := `insert user(name, age) values(?, ?)` ret1, err := db.Exec(sqlInsert, \"zhangsan\", 100) if err != nil { fmt.Println(\"insert failed:\", err) return } lastId, err := ret1.LastInsertId() if err != nil { fmt.Println(\"get lastId failed:\", err) return } fmt.Println(\"insert id is :\", lastId) sqlUpdate := `update user set age=? where id = ?` ret2, err := db.Exec(sqlUpdate, 666, 1) if err != nil { fmt.Println(\"update failed: \", err) return } affectRow2, err := ret2.RowsAffected() if err != nil { fmt.Println(\"get affectRow2 failed:\", err) return } fmt.Println(\"affectRow2 is : \", affectRow2) sqlDelete := `delete from user where id = ?` ret3, err := db.Exec(sqlDelete, 2) if err != nil { fmt.Println(\"delete failed:\", err) return } affectRow3, err := ret3.RowsAffected() if err != nil { fmt.Println(\"get rowAffect3 failed:\", err) return } fmt.Println(\"affectRow3 is :\", affectRow3) } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sqlx.Connect(\"mysql\", dsn) if err != nil { return err } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed,\", err) return } fmt.Println(\"conncet database sucess!\") testSqlxInsertUpdateDelte() } 执行结果： $ ./sqlx.exe conncet database sucess! insert id is : 4 affectRow2 is : 1 affectRow3 is : 1 MariaDB [sql_test]> select * from user; +----+------+------+ | id | name | age | +----+------+------+ | 1 | wang | 18 | | 2 | li | 22 | | 3 | gu | 24 | +----+------+------+ 3 rows in set (0.00 sec) MariaDB [sql_test]> select * from user; +----+----------+------+ | id | name | age | +----+----------+------+ | 1 | wang | 666 | | 3 | gu | 24 | | 4 | zhangsan | 100 | +----+----------+------+ 3 rows in set (0.00 sec) 3.4. NamedExec *sqlx.DB类型对象的NamedExec()方法用来将要传递给sql字符串的变量进行绑定，根据字段名进行映射，一般是struct和map。 package main import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) type user struct { Id int Name string Age int } var db *sqlx.DB func NamedExecDemo() { sqlStr := `insert into user(name, age) values(:name, :age)` _, err := db.NamedExec(sqlStr, map[string]interface{}{ \"name\": \"lueluelue\", \"age\": 233, // name和age会和上面values中的name和age一一对应。 }) if err != nil { fmt.Println(\"nameExec failed:\", err) return } return } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sqlx.Connect(\"mysql\", dsn) if err != nil { return err } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed,\", err) return } fmt.Println(\"conncet database sucess!\") // testSqlxInsertUpdateDelte() NamedExecDemo() } 执行后，数据库的变化 MariaDB [sql_test]> select * from user; +----+----------+------+ | id | name | age | +----+----------+------+ | 1 | wang | 666 | | 3 | gu | 24 | | 4 | zhangsan | 100 | +----+----------+------+ 3 rows in set (0.00 sec) MariaDB [sql_test]> select * from user; +----+-----------+------+ | id | name | age | +----+-----------+------+ | 1 | wang | 666 | | 3 | gu | 24 | | 4 | zhangsan | 100 | | 5 | lueluelue | 233 | +----+-----------+------+ 4 rows in set (0.00 sec) 3.5. NamedQuery 和NamedQuery性质一样，只不过是用于查询； package main import ( \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) type user struct { Id int Name string Age int } var db *sqlx.DB func NamedQueryDemo() { sqlStr := `select id,name,age from user where name=:name` rows, err := db.NamedQuery(sqlStr, map[string]interface{}{\"name\": \"wang\"}) if err != nil { fmt.Println(\"query failed:\", err) return } defer rows.Close() var u user for rows.Next() { err = rows.Scan(&u.Id, &u.Name, &u.Age) if err != nil { fmt.Println(\"scan failed:\", err) continue } fmt.Printf(\"Id: %v Name: %v, Age: %v\\n\", u.Id, u.Name, u.Age) } } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sqlx.Connect(\"mysql\", dsn) if err != nil { return err } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed,\", err) return } fmt.Println(\"conncet database sucess!\") // testSqlxInsertUpdateDelte() NamedQueryDemo() } $ ./sqlx.exe conncet database sucess! Id: 1 Name: wang, Age: 666 3.6. 事务操作 sqlx包也可以通过db.Begin()和tx.Rollback tx.Commit()的方法进行事务操作，如下： func transactionDemo2()(err error) { tx, err := db.Beginx() // 开启事务 if err != nil { fmt.Printf(\"begin trans failed, err:%v\\n\", err) return err } defer func() { if p := recover(); p != nil { tx.Rollback() panic(p) // re-throw panic after Rollback } else if err != nil { fmt.Println(\"rollback\") tx.Rollback() // err is non-nil; don't change it } else { err = tx.Commit() // err is nil; if Commit returns error update err fmt.Println(\"commit\") } }() sqlStr1 := \"Update user set age=20 where id=?\" rs, err := tx.Exec(sqlStr1, 1) if err!= nil{ return err } n, err := rs.RowsAffected() if err != nil { return err } if n != 1 { return errors.New(\"exec sqlStr1 failed\") } sqlStr2 := \"Update user set age=50 where i=?\" rs, err = tx.Exec(sqlStr2, 5) if err!=nil{ return err } n, err = rs.RowsAffected() if err != nil { return err } if n != 1 { return errors.New(\"exec sqlStr1 failed\") } return err } 4. sqlx.In sql.In是sqlx提供的一个非常方便的函数； 4.1. sqlx.In的批量插入示例 1、创建一张数据表： MariaDB [sql_test]> CREATE TABLE `user` ( -> `id` BIGINT(20) NOT NULL AUTO_INCREMENT, -> `name` VARCHAR(20) DEFAULT '', -> `age` INT(11) DEFAULT '0', -> PRIMARY KEY(`id`) -> )ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; Query OK, 0 rows affected (0.00 sec) MariaDB [sql_test]> show tables; +--------------------+ | Tables_in_sql_test | +--------------------+ | user | +--------------------+ 1 row in set (0.00 sec) 2、定义一个结构体：字段中通过tag和数据表user的字段进行关联 type User struct { Name string `db:\"name\"` Age int `db:\"age\"` } bindvars绑定变量 查询占位符？在内部称为binvars，代码中应该使用使用它们向数据库传递值，因为这种方式可以防止sql注入，database/sql不尝试对查询文本进行任何验证；它与编码的参数一起按原样发送到服务器。除非驱动程序实现一个特殊的接口，否则在执行之前，查询是在服务器上准备的。因此bindvars是特定于数据库的: mysql中是？ pgsql中是$1 $2 sqlite中是$1 ?都支持 oracel中是:name的方式 binvars仅仅用于参数化，即不可以通过传递的binvars改变sql的结构，这样避免了sql注入问题，如下面通过binvars改变sql中表名或字段名将不起作用 db.Query(\"select * from ?\", \"table1\") db.Query(\"select ?,? from people\", \"name\", \"location\") 自行拼接语句实现批量插入： // BatchInsertUsers 自行构造批量插入的语句 func BatchInsertUsers(users []*User) error { // 存放 (?, ?) 的slice valueStrings := make([]string, 0, len(users)) // 存放values的slice valueArgs := make([]interface{}, 0, len(users) * 2) // 遍历users准备相关数据 for _, u := range users { // 此处占位符要与插入值的个数对应 valueStrings = append(valueStrings, \"(?, ?)\") valueArgs = append(valueArgs, u.Name) valueArgs = append(valueArgs, u.Age) } // 自行拼接要执行的具体语句 stmt := fmt.Sprintf(\"INSERT INTO user (name, age) VALUES %s\", strings.Join(valueStrings, \",\")) _, err := DB.Exec(stmt, valueArgs...) return err } 使用sqlx.In实现批量插入： 还可以使用NameExec实现批量插入： // BatchInsertUsers3 使用NamedExec实现批量插入 func BatchInsertUsers3(users []*User) error { _, err := DB.NamedExec(\"INSERT INTO user (name, age) VALUES (:name, :age)\", users) return err } 这里采用sqlx.In的方式的示例代码： package main import ( \"database/sql/driver\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"github.com/jmoiron/sqlx\" ) type User struct { Name string `db:\"name\"` Age int `db:\"age\"` } var db *sqlx.DB func (u User) Value() (driver.Value, error) { return []interface{}{u.Name, u.Age}, nil } // BatchInsertUsers2 使用sqlx.In帮我们拼接语句和参数, 注意传入的参数是[]interface{} func BatchInsertUsers2(users []interface{}) error { query, args, _ := sqlx.In( \"INSERT INTO user (name, age) VALUES (?), (?), (?)\", users..., // 如果arg实现了 driver.Valuer, sqlx.In 会通过调用 Value()来展开它 ) fmt.Println(query) // 查看生成的querystring fmt.Println(args) // 查看生成的args _, err := db.Exec(query, args...) return err } func initDB() (err error) { dsn := \"root:123456@tcp(192.168.80.100:3306)/sql_test?charset=utf8mb4&parseTime=True\" db, err = sqlx.Connect(\"mysql\", dsn) if err != nil { return err } db.SetMaxOpenConns(20) db.SetMaxIdleConns(10) return nil } func main() { err := initDB() if err != nil { fmt.Println(\"init db failed,\", err) return } fmt.Println(\"conncet database sucess!\") defer db.Close() u1 := User{Name: \"zhangsan\", Age: 18} u2 := User{Name: \"lisi\", Age: 28} u3 := User{Name: \"wangermazi\", Age: 38} // 方法2 users2 := []interface{}{u1, u2, u3} err = BatchInsertUsers2(users2) if err != nil { fmt.Printf(\"BatchInsertUsers2 failed, err:%v\\n\", err) } } 执行结果： $ ./sqlx.exe conncet database sucess! INSERT INTO user (name, age) VALUES (?, ?), (?, ?), (?, ?) [zhangsan 18 lisi 28 wangermazi 38] MariaDB [sql_test]> select * from user; Empty set (0.00 sec) MariaDB [sql_test]> select * from user; +----+------------+------+ | id | name | age | +----+------------+------+ | 1 | zhangsan | 18 | | 2 | lisi | 28 | | 3 | wangermazi | 38 | +----+------------+------+ 4.2. sqlx.In的查询示例 关于sqlx.In这里再补充一个用法，在sqlx查询语句中实现In查询和FIND_IN_SET函数。即实现SELECT * FROM user WHERE id in (3, 2, 1);和SELECT * FROM user WHERE id in (3, 2, 1) ORDER BY FIND_IN_SET(id, '3,2,1');。 in查询： 查询id，在给定id集合中的数据 // QueryByIDs 根据给定ID查询 func QueryByIDs(ids []int)(users []User, err error){ // 动态填充id query, args, err := sqlx.In(\"SELECT name, age FROM user WHERE id IN (?)\", ids) if err != nil { return } // sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它 query = DB.Rebind(query) err = DB.Select(&users, query, args...) return } in查询和FIND_IN_SET函数 查询id在给定id集合的数据，并维持给定id集合的顺序 // QueryAndOrderByIDs 按照指定id查询并维护顺序 func QueryAndOrderByIDs(ids []int)(users []User, err error){ // 动态填充id strIDs := make([]string, 0, len(ids)) for _, id := range ids { strIDs = append(strIDs, fmt.Sprintf(\"%d\", id)) } query, args, err := sqlx.In(\"SELECT name, age FROM user WHERE id IN (?) ORDER BY FIND_IN_SET(id, ?)\", ids, strings.Join(strIDs, \",\")) if err != nil { return } // sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它 query = DB.Rebind(query) err = DB.Select(&users, query, args...) return } latteplus            updated 2021-02-15 10:40:45 "},"2-go与数据库/3-go操作redis.html":{"url":"2-go与数据库/3-go操作redis.html","title":"3-go操作redis","keywords":"","body":"1. redis介绍1.1. 参考文档1.2. redis支持的数据结构1.3. redis应用场景1.4. redis搭建2. go-redis库2.1. 安装2.2. 连接2.2.1. v8版本的连接示例2.3. V8版本相关2.3.1. 连接redis哨兵模式2.3.2. 连接redis集群2.4. 基本使用2.4.1. set/get2.4.2. zset2.4.3. 根据前缀获取key2.4.4. 执行自定义命令2.4.5. 根据通配符删除key2.4.6. Pipline2.4.7. 事务2.4.8. Watch1. redis介绍 1.1. 参考文档 https://pkg.go.dev/github.com/go-redis/redis Redis是一个开源的内存数据库，Redis提供了多种不同类型的数据结构，很多业务场景下的问题都可以很自然地映射到这些数据结构上。除此之外，通过复制、持久化和客户端分片等特性，我们可以很方便地将Redis扩展成一个能够包含数百GB数据、每秒处理上百万次请求的系统。 1.2. redis支持的数据结构 redis支持的数据结构体有： strings字符串 hashes哈希值 lists列表 sets集合 sorted sets带范围查询的排序集合 bit maps位图 hyperloglogs geospatial indexes带半径查询和流的地理空间索引 1.3. redis应用场景 缓存系统：减轻数据库的压力，如mysql 计数场景，如微博、抖音的关注数 热门排行榜，如热搜，使用Zset 消息队里，利用list可以实现队列功能 1.4. redis搭建 安装 [root@host1 ~]# yum install -y redis [root@host1 ~]# systemctl enable redis [root@host1 ~]# systemctl start redis 修改配置，修改为对外监听，并添加访问密码 [root@host1 ~]# vim /etc/redis.conf 61 bind 127.0.0.1 192.168.80.100 480 requirepass 123456 [root@host1 ~]# systemctl restart redis [root@host1 ~]# ss -nlt|grep 6379 LISTEN 0 128 192.168.80.100:6379 *:* LISTEN 0 128 127.0.0.1:6379 *:* 连接测试 [root@host1 ~]# redis-cli -a 123456 -h 192.168.80.100 192.168.80.100:6379> 2. go-redis库 2.1. 安装 官方仓库地址，且go-redis支持哨兵和集群模式的redis集群，redigo也是个连接redis的go第三方库 这里采用的是go-redis库的v8版本；参考文档 1、利用go module方式管理，初始化一个module $ go mod init github.com/latteplus/redis-cli-goDemo go: creating new go.mod: module github.com/latteplus/redis-cli-goDemo 2、安装依赖包 go get github.com/go-redis/redis/v8 2.2. 连接 2.2.1. v8版本的连接示例 直接用官方的文档：https://github.com/go-redis/redis#quickstart package main import ( \"context\" \"fmt\" \"github.com/go-redis/redis/v8\" ) var ctx = context.Background() func ExampleClient() { rdb := redis.NewClient(&redis.Options{ Addr: \"192.168.80.100:6379\", Password: \"123456\", // redis password set DB: 1, // use DB 1 }) err := rdb.Set(ctx, \"key\", \"value\", 0).Err() if err != nil { panic(err) } val, err := rdb.Get(ctx, \"key\").Result() if err != nil { panic(err) } fmt.Println(\"key\", val) val2, err := rdb.Get(ctx, \"key2\").Result() if err == redis.Nil { fmt.Println(\"key2 does not exist\") } else if err != nil { panic(err) } else { fmt.Println(\"key2\", val2) } // Output: key value // key2 does not exist } func main() { ExampleClient() } 运行结果： $ ./redis-cli-goDemo.exe key value key2 does not exist 192.168.80.100:6379> select 1 OK 192.168.80.100:6379[1]> KEYS * (empty list or set) 192.168.80.100:6379[1]> KEYS * 1) \"key\" 192.168.80.100:6379[1]> get key \"value\" 2.3. V8版本相关 2.3.1. 连接redis哨兵模式 https://redis.uptrace.dev/sentinel/ func initClient()(err error){ rdb := redis.NewFailoverClient(&redis.FailoverOptions{ MasterName: \"master\", SentinelAddrs: []string{\"x.x.x.x:26379\", \"xx.xx.xx.xx:26379\", \"xxx.xxx.xxx.xxx:26379\"}, }) _, err = rdb.Ping().Result() if err != nil { return err } return nil } 2.3.2. 连接redis集群 https://redis.uptrace.dev/cluster/ func initClient()(err error){ rdb := redis.NewClusterClient(&redis.ClusterOptions{ Addrs: []string{\":7000\", \":7001\", \":7002\", \":7003\", \":7004\", \":7005\"}, }) _, err = rdb.Ping().Result() if err != nil { return err } return nil } 2.4. 基本使用 2.4.1. set/get package main import ( \"context\" \"fmt\" \"github.com/go-redis/redis/v8\" ) var ctx = context.Background() var rdb *redis.Client func initClient() { rdb = redis.NewClient(&redis.Options{ Addr: \"192.168.80.100:6379\", Password: \"123456\", // redis password set DB: 1, // use DB 1 }) } func redisDemo() { err := rdb.Set(ctx, \"score\", 100, 0).Err() if err != nil { fmt.Printf(\"set score failed, err:%v\\n\",err) return } val, err := rdb.Get(ctx,\"score\").Result() if err != nil { fmt.Printf(\"get socre failed ,err:%v\\n\",err) return } fmt.Println(\"score:\",val) val2, err := rdb.Get(ctx,\"name\").Result() if err == redis.Nil{ fmt.Println(\"name not exist\") }else if err != nil { fmt.Println(\"get name failed,\",err) return }else { fmt.Println(\"name\",val2) } } func main() { initClient() fmt.Println(\"init redis client success!\") redisDemo() } 执行结果： D:\\myCode\\Go\\src\\learngo\\database\\redis>redis-cli-goDemo.exe init redis client success! score: 100 name not exist 192.168.80.100:6379[1]> KEYS * 2) \"score\" 3) \"key\" 192.168.80.100:6379[1]> get score \"100\" 2.4.2. zset package main import ( \"context\" \"fmt\" \"github.com/go-redis/redis/v8\" ) var ctx = context.Background() var rdb *redis.Client func initClient() { rdb = redis.NewClient(&redis.Options{ Addr: \"192.168.80.100:6379\", Password: \"123456\", // redis password set DB: 1, // use DB 1 }) } func redisDemo() { // 构造zset中的键名，和其成员 zsetKey := \"language_rank\" languages := []*redis.Z{ &redis.Z{Score: 90.0, Member: \"Golang\"}, &redis.Z{Score: 98.0, Member: \"Java\"}, &redis.Z{Score: 95.0, Member: \"Python\"}, &redis.Z{Score: 97.0, Member: \"JavaScript\"}, &redis.Z{Score: 99.0, Member: \"C/C++\"}, } // Zadd num, err := rdb.ZAdd(ctx,zsetKey,languages...).Result() if err != nil { fmt.Printf(\"zadd failed, err : %v\\n\", err) return } fmt.Printf(\"zadd %d success!\", num) // 把Golang的分数加10 newScore, err := rdb.ZIncrBy(ctx, zsetKey, 10, \"Golang\").Result() if err != nil { fmt.Printf(\"zincrby failed, err :%v\\n\", err) return } fmt.Printf(\"Golang`s score is %f now.\", newScore) // 取分数最高的三个 ret, err := rdb.ZRevRangeWithScores(ctx, zsetKey, 0, 2).Result() if err != nil { fmt.Printf(\"zrevrange failed, err :%v\\n\", err) return } for _, z := range ret{ fmt.Println(z.Member, z.Score) } // 取95-100分的 op := redis.ZRangeBy{ Min: \"95\", Max: \"100\", } ret, err = rdb.ZRangeByScoreWithScores(ctx, zsetKey, &op).Result() if err != nil { fmt.Printf(\"zrangbyScore failed, err:%v\\n\", err) return } for _, z := range ret{ fmt.Println(z.Member, z.Score) } } func main() { initClient() fmt.Println(\"init redis client success!\") redisDemo() } 运行结果： D:\\myCode\\Go\\src\\learngo\\database\\redis>redis-cli-goDemo.exe init redis client success! zadd 5 success!Golang`s score is 100.000000 now.Golang 100 C/C++ 99 Java 98 Python 95 JavaScript 97 Java 98 C/C++ 99 Golang 100 遇到的问题： 35和69行处，需要传递的参数变为的指针类型，需要注意；redis-go的V8版本和之前版本的变动导致 D:\\myCode\\Go\\src\\learngo\\database\\redis>go build # github.com/latteplus/redis-cli-goDemo .\\main.go:35:22: cannot use languages (type []redis.Z) as type []*redis.Z in argument to rdb.cmdable.ZAdd .\\main.go:69:40: cannot use op (type redis.ZRangeBy) as type *redis.ZRangeBy in argument to rdb.cmdable.ZRangeByScoreWithScores 2.4.3. 根据前缀获取key vals, err := rdb.Keys(ctx, \"prefix*\").Result() 2.4.4. 执行自定义命令 res, err := rdb.Do(ctx, \"set\", \"key\", \"value\").Result() 2.4.5. 根据通配符删除key iter := rdb.Scan(ctx, 0, \"prefix*\", 0).Iterator() for iter.Next(ctx) { err := rdb.Del(ctx, iter.Val()).Err() if err != nil { panic(err) } } if err := iter.Err(); err != nil { panic(err) } 2.4.6. Pipline pipline可以用于优化网络传输时间，本质是将多条发往redis-server的命令，积攒在一次进行发送，节省了每个命令的rtt值 pipline基本示例 pipe := rdb.Pipeline() incr := pipe.Incr(ctx,\"pipline_counter\") pipe.Expire(ctx, \"pipline_counter\", time.Hour) _, err := pipe.Exec() fmt.Println(incr.Val(), err) 也可以使用piplined，基本示例 var incr *redis.IntCmd _, err := rdb.Pipelined(func(pipe redis.Pipeliner) error { incr = pipe.Incr(\"pipelined_counter\") pipe.Expire(\"pipelined_counter\", time.Hour) return nil }) fmt.Println(incr.Val(), err) 某些场景下，当有多条命令需要执行时，可以考虑用pipline来优化。 2.4.7. 事务 redis是单线程的，因此单个命令使用是原子的，但来自不同客户端的给定命令可以依次执行，利用在它们之间交替执行，但是Multi/exec可以确保在这2个语句之间执行的命令没有其他客户端正在执行命令； 在这种场景我们需要使用TxPipeline。TxPipeline总体上类似于上面的Pipeline，但是它内部会使用MULTI/EXEC包裹排队的命令。例如： pipe := rdb.TxPipeline() incr := pipe.Incr(\"tx_pipeline_counter\") pipe.Expire(\"tx_pipeline_counter\", time.Hour) _, err := pipe.Exec() fmt.Println(incr.Val(), err) 上面代码相当于在一个RTT下执行了下面的redis命令： MULTI INCR pipeline_counter EXPIRE pipeline_counts 3600 EXEC 还有一个与上文类似的TxPipelined方法，使用方法如下： var incr *redis.IntCmd _, err := rdb.TxPipelined(func(pipe redis.Pipeliner) error { incr = pipe.Incr(\"tx_pipelined_counter\") pipe.Expire(\"tx_pipelined_counter\", time.Hour) return nil }) fmt.Println(incr.Val(), err) 2.4.8. Watch 在某些场景下，我们除了要使用MULTI/EXEC命令外，还需要配合使用WATCH命令。在用户使用WATCH命令监视某个键之后，直到该用户执行EXEC命令的这段时间里，如果有其他用户抢先对被监视的键进行了替换、更新、删除等操作，那么当用户尝试执行EXEC的时候，事务将失败并返回一个错误，用户可以根据这个错误选择重试事务或者放弃事务。 Watch(fn func(*Tx) error, keys ...string) error Watch方法接收一个函数和一个或多个key字符串类型，作为参数；示例： // 监视watch_count的值，并在值不变的前提下将其值+1 key := \"watch_count\" err = client.Watch(func(tx *redis.Tx) error { n, err := tx.Get(key).Int() if err != nil && err != redis.Nil { return err } _, err = tx.Pipelined(func(pipe, redis.Pipeliner) error { pipe.Set(key, n+1, 0) return nil }) return err },key) v8版本中，官方文档示例：使用GET和SET命令以事务的方式递增Key值的示例，仅仅当Key的值不发生变化时提交一个事务 func transactionDemo() { var ( maxRetries = 1000 routineCount = 10 ) ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // Increment 使用GET和SET命令以事务方式递增Key的值 increment := func(key string) error { // 事务函数 txf := func(tx *redis.Tx) error { // 获得key的当前值或零值 n, err := tx.Get(ctx, key).Int() if err != nil && err != redis.Nil { return err } // 实际的操作代码（乐观锁定中的本地操作） n++ // 操作仅在 Watch 的 Key 没发生变化的情况下提交 _, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error { pipe.Set(ctx, key, n, 0) return nil }) return err } // 最多重试 maxRetries 次 for i := 0; i latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_1go标准库文件读写操作.html":{"url":"2-go常用标准库/2_1go标准库文件读写操作.html","title":"2_1go标准库文件读写操作","keywords":"","body":"1. 文件打开与关闭2. 读取文件2.1. file.Read()2.1.1. 基本使用2.1.2. 循环读取2.2. bufio读取文件2.3. ioutil读取整个文件3. 文件写入3.1. file.Write()和file.WriteString()3.2. bufio.NewWriter写入文件3.3. ioutil.WriteFile写入整个文件4. 练习题4.1. 实现copyFile4.2. 实现cat命令1. 文件打开与关闭 文件是存储在外部介质，通常是磁盘上的数据集合，文件分为文本文件，二进制文件； e.g. os.open（）函数可以打开给定的文件，返回一个*file 和一个err；返回的文件对象可以调用close（）方法关闭文件 package main import ( \"fmt\" \"os\" ) // os.Open()函数打开文件 func main() { // 打开当前目录下的main.go文件，当前目录即，编译为二进制程序后，和二进制程序在同一目录下的main.go文件 fileObj, err := os.Open(\"./masafdin.go\") // 先判断返回的err是否为nil，不为nil，证明，打开操作失败，直接返回不继续执行 if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return } fileObj.Close() } $ go build latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/13file (master) $ ./13file.exe open file failed, err:open ./masafdin.go: The system cannot find the file specified. 若指定一个当前目录，不存在的文件，则打开失败，打开main.go则不会 ps：执行关闭文件的操作，常定义在defer语句中，在函数返回时执行，防止文件忘记关闭；（加入defer语句 要考虑的一点：defer是放在err判断后，还是前 package main import ( \"fmt\" \"os\" ) // os.Open()函数打开文件 func main() { // 打开当前目录下的main.go文件，当前目录即，编译为二进制程序后，和二进制程序在同一目录下的main.go文件 fileObj, err := os.Open(\"./mainsdf.go\") // 先判断返回的err是否为nil，不为nil，证明，打开操作失败，直接返回不继续执行 if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return } defer fileObj.Close() /* defer 放在err判断后： 遇到错误直接return，defer不会被注册到 若没错误，会得到一个文件类型的指针，然后defer会被注册到，函数返回时，执行defer，关闭文件 defer 放在err判断前： 不管是否遇到错误，defer都可以注册到， 正常打开文件还好 但打开返回err有值时，fileObj是一个文件描述符吗？能调用Close（）方法吗？ 本次实验没发现问题，但是还是最好，defer放在判断err后面，打开失败也就不用继续执行了，也没必要用defer来关闭文件了 */ } 2. 读取文件 读取文件，常用的有3种方法：file.Read bufio ioutil，使用的简便程度上，依次增大 2.1. file.Read() 2.1.1. 基本使用 Read()方法定义如下： 其接收者是要给*File类型，os.Open打开文件时，获得的第一个值就是该类型，正好； 其接收是一个字节byte类型的切片 其返回是一个int代表本次读取的字节数，和error类型表示可能出现的错误（读取到文件末尾时，int返回0，error返回io.EOF func (f *File) Read(b []byte) (n int , err error) 一个例子： package main import ( \"fmt\" \"io\" \"os\" ) // os.Open()函数打开文件 ，然后用得到的文件对象的Read()方法，指定一次读多少字节 func main() { // 打开main.go文件 fileObj, err := os.Open(\"./test.txt\") // 判断打开是否出错 if err != nil { fmt.Printf(\"open main.go failed, err: %v\\n\", err) } defer fileObj.Close() // 定义一个切片，大小为128,128就是一次能读取的大小 var tmp = make([]byte, 128) n, err := fileObj.Read(tmp) // 先判断，本次读，是否读的是空，（即读的就是一个空文件，或者，循环读取的时候，上次已经读完文件，本次读取的是空 if err == io.EOF { fmt.Println(\"啥也没读到，读到文件末尾了\") return } // 判断是否读，出现了错误，有错直接返回 if err != nil { fmt.Println(\"读出错了\") return } // 又没读出错，又不是本次读空，根据Read返回的int值，就是本次读取的字节大小 fmt.Printf(\"读取了%d个字节\\n\", n) // 对tmp这个字节类型的切片，转换为string，然后打印 fmt.Println(string(tmp[:n])) } 运行结果： 》读取当前目录下的main.go文件时； latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/13file (master) $ go run main.go 读取了128个字节 package main import ( \"fmt\" \"io\" \"os\" ) // os.Open()函数打开文件 ，然后用得到的文件对象的Read() 》读取当前目录下的test.txt空文件时 latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/13file (master) $ go run main.go 啥也没读到，读到文件末尾了 2.1.2. 循环读取 使用read（）方法，一次只能在文件中，读取指定字节大小的数据，要想利用read（）方法完整的读取整个文件，将read（）方法写到循环中，循环读取，每次读取指定字节的数据，直到读到文件末尾，然后退出循环 package main import ( \"fmt\" \"io\" \"os\" ) // os.Open()函数打开文件 ，然后用得到的文件对象的Read() func main() { // 打开main.go文件 fileObj, err := os.Open(\"./main.go\") // 判断打开是否出错 if err != nil { fmt.Printf(\"open main.go failed, err: %v\\n\", err) } defer fileObj.Close() var tmp = make([]byte, 128) var allFileContent []byte for { n, err := fileObj.Read(tmp) if err == io.EOF { fmt.Println(\"文件已经读完\") break // 不能用return，用了之后，直接推出main含数，最后的打印就执行不到了 } if err != nil { fmt.Printf(\"读出错：err:%v\\n\", err) } allFileContent = append(allFileContent, tmp[:n]...) fmt.Printf(\"读了%d字节\\n\", n) } fmt.Printf(\"整个文件的内容是: %s\\n\", string(allFileContent)) } 运行结果： latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/13file (master) $ go run main.go 读了128字节 读了128字节 读了128字节 读了128字节 读了128字节 读了128字节 读了91字节 文件已经读完 整个文件的内容是: package main import ( \"fmt\" \"io\" \"os\" ) // os.Open()函数打开文件 ，然后用得到的文件对象的Read() func main() { // 打开main.go文件 fileObj, err := os.Open(\"./main.go\") // 判断打开是否出错 if err != nil { fmt.Printf(\"open main.go failed, err: %v\\n\", err) } defer fileObj.Close() var tmp = make([]byte, 128) var allFileContent []byte for { n, err := fileObj.Read(tmp) if err == io.EOF { fmt.Println(\"文件已经读完\") break // 不能用return，用了之后，直接推出main含数，最后的打印就执行不到了 } if err != nil { fmt.Printf(\"读出错：err:%v\\n\", err) } allFileContent = append(allFileContent, tmp[:n]...) fmt.Printf(\"读了%d字节\\n\", n) } fmt.Printf(\"整个文件的内容是: %s\\n\", string(allFileContent)) } 2.2. bufio读取文件 bufio是对file.Read（）的封装， package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) // os.Open()函数打开文件 // 用bufio读取文件 func main() { file, err := os.Open(\"./main.go\") if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) } defer file.Close() fmt.Printf(\"file的类型:%T\\n\", file) // 将获得的文件对象，传入NewReader，获得一个reader对象， reader := bufio.NewReader(file) for { // 循环中，利用reader对象的ReadString方法，返回的是一行的字符串，和有可能出现的err line, err := reader.ReadString('\\n') // \\n是传入的字符，以\\n为分隔符读取 // 判断是否读到文件末尾，是就跳出循环 if err == io.EOF { fmt.Println(\"读到文件末尾\") break } // 判断是否读出错，是就退出函数 if err != nil { fmt.Printf(\"读出错了:err:%v\\n\", err) return } // 既没有遇到错，也没读到文件末尾 ，就打印读的该行 if len(line) != 0 { fmt.Println(line) } } } 2.3. ioutil读取整个文件 ioutil是更高层的封装，根据传入的文件名，可以直接读取完整的文件内容 package main import ( \"fmt\" \"io/ioutil\" ) // os.Open()函数打开文件 // 用bufio读取文件 func main() { fileContent, err := ioutil.ReadFile(\"./main.go\") // 传入字符串类型的文件名，返回[]byte 字节类型的切片（即包含了整个文件的内容，再返回一个可能的err if err != nil { fmt.Printf(\"read file failed, err:%v\\n\", err) return } fmt.Println(string(fileContent)) } 不需要打开文件，因为ReadFile里已经封装了相应的代码 func ReadFile(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() // It's a good but not certain bet that FileInfo will tell us exactly how much to // read, so let's try it but be prepared for the answer to be wrong. var n int64 = bytes.MinRead if fi, err := f.Stat(); err == nil { // As initial capacity for readAll, use Size + a little extra in case Size // is zero, and to avoid another allocation after Read has filled the // buffer. The readAll call will read into its allocated internal buffer // cheaply. If the size was wrong, we'll either waste some space off the end // or reallocate as needed, but in the overwhelmingly common case we'll get // it just right. if size := fi.Size() + bytes.MinRead; size > n { n = size } } return readAll(f, n) } file.Read()到bufio.NewReader到ioutil.ReadFile，使用难度依次降低，因为封装程度依次加大 3. 文件写入 os.OpenFile()函数，可以打开给定的文件，然后还可以根据指定的方式，向文件中写入； 函数定义： func OpenFile(name string, flag int, perm FileMode) (*File, error) 其中： name是文件名 flag是int整型，但是一般用单词表示（单词本质是int数字，只是方便理解使用） perm是文件权限 返回：文件类型的指针 返回：error可能出现的error flag有以下几种： 模式 含义 os.O_WRONLY 只写 os.O_CREATE 创建文件 os.O_RDONLY 只读 os.O_RDWR 读写 os.O_TRUNC 清空 os.O_APPEND 追加 perm：用一个八进制数表示，用3个二进制位表示就是 r 读 o4 w 写 o2 x 执行 o1 3.1. file.Write()和file.WriteString() package main import ( \"fmt\" \"os\" ) func main() { fileObj, err := os.OpenFile(\"./1.txt\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) // 打开1.txt文件，没有就创建，之前有就清空，只写打开 // 权限，666,即属主属组其他人，都是4+2读写权限 if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return } defer fileObj.Close() // 写入字节切片数据 // Write接收字节切片 str := \"line1\\n\" fileObj.Write([]byte(str)) // WriteString接收一个字符串，写入字符串数据 fileObj.WriteString(\"line2\") } , 运行后生成的1.txt文件 line1 line2 3.2. bufio.NewWriter写入文件 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { fileObj, err := os.OpenFile(\"./2.txt\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Printf(\"open file failed, err:%v\\n\", err) return } defer fileObj.Close() fmt.Printf(\"type : %T\\n\", fileObj) // 传入fileObj，获得一个*Writer类型的实例writer writer := bufio.NewWriter(fileObj) for i := 0; i 运行后文件： hello world hello world hello world hello world hello world hello world hello world hello world hello world hello world 3.3. ioutil.WriteFile写入整个文件 package main import ( \"fmt\" \"io/ioutil\" ) func main() { str := \"shuai qi\" err := ioutil.WriteFile(\"3.txt\", []byte(str), 0666) if err != nil { fmt.Printf(\"open file failed err: %v\\n\", err) return } } 运行后文件： shuai qi 4. 练习题 4.1. 实现copyFile 借助io.Copy（）函数实现文件拷贝 package main import ( \"fmt\" \"io\" \"os\" ) /* main函数中调用自定义的拷贝函数，传递拷贝的源文件和目标文件名； 自定义拷贝函数 分别打开源文件和拷贝文件，获得文件类型指针 然后调用io.Copy，传递2个文件指针，即可实现文件拷贝 */ func copyFile(srcfile, dstfile string) (n int64, err error) { // 打开读文件 srcObj, err := os.Open(srcfile) if err != nil { fmt.Printf(\"open src file failed err:%v\\n\", err) } defer srcObj.Close() // 打开要写的文件 dstObj, err := os.OpenFile(dstfile, os.O_CREATE|os.O_WRONLY, 0644) if err != nil { fmt.Printf(\"open dst file failed err:%v\\n\", err) } defer dstObj.Close() // 调用io.Copy，进行文件拷贝 return io.Copy(dstObj, srcObj) } func main() { // 调用copyFile函数，传递，2个文件名 _, err := copyFile(\"2.txt\", \"copy.txt\") if err != nil { fmt.Printf(\"copy error : %v\\n\", err) } fmt.Println(\"copy done!\") // 根据返回的err判断是否出错，没错就打印拷贝完成 } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/13file (master) $ ./13file.exe copy done! 4.2. 实现cat命令 package main import ( \"bufio\" \"flag\" \"fmt\" \"io\" \"os\" ) /* 思路： 1，先利用内置函数，解析命令行传参 2，判断传参的个数 如果是0，就从os.Stdin实例化一个Reader，得到*Reader类型，即将标准输入当做读取来源 将获得的文件对象，传入cat函数处理，函数内部实现读取逻辑 如果是至少一个参数，就遍历每个文件名 对每个文件名都os.Open打开，获得文件对象 先判断打开文件是否有错，有错就提示， 没错就对文件对象，用NewReader，得到*Reader类型 传入cat函数处理， 3，cat函数的逻辑 接收一个bufio包的*Reader类型 for循环中，利用自带的ReadBytes方法，一行一行读取， 每读一行，用Fpfinf打印到终端，直到io.EOF，退出循环 */ // cat命令实现 func cat(r *bufio.Reader) { for { buf, err := r.ReadBytes('\\n') //注意是字符 if err == io.EOF { fmt.Fprintf(os.Stdout, \"%s\", buf) break } fmt.Fprintf(os.Stdout, \"%s\", buf) } } func main() { flag.Parse() // 解析命令行参数 if flag.NArg() == 0 { // 如果没有参数默认从标准输入读取内容 cat(bufio.NewReader(os.Stdin)) } // 依次读取每个指定文件的内容并打印到终端 for i := 0; i 传入一个文件名运行结果： latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/cat (master) $ ./cat.exe /d/myCode/Go/src/learngo/basic_grammar/13file/3.txt shuai qi asdfasdf sdf sadf sdf 不传入参数运行：直接捕获标准输入，然后再输出 latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/cat (master) $ ./cat.exe hello hello world world 注意一个问题： func cat(r *bufio.Reader) { for { buf, err := r.ReadBytes('\\n') if err == io.EOF { // 在一开始，if判断里没有这句打印，那么在文件的最后一行之后，没有敲回车的话，（最后一行内容是读不到的，因为直接break，最后有内容的一行会读不到，而文件最后一行，敲了回车，即最后一行是一个空行的情况下，读文件才能完整 // 为了解决这个问题，在break前先打印一下最后一行，这样即使文件的最后一行没有回车，也可读完整的文件内容， fmt.Fprintf(os.Stdout, \"%s\", buf) break } fmt.Fprintf(os.Stdout, \"%s\", buf) } } 3.txt的内容 shuai qi asdfasdf sdf sadf sdf latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_2go标准库time包.html":{"url":"2-go常用标准库/2_2go标准库time包.html","title":"2_2go标准库time包","keywords":"","body":"1. time包1.1. 时间类型1.2. 时间戳1.3. 时间间隔1.4. 时间操作1.4.1. Add1.4.2. Sub1.4.3. Equal1.4.4. Before1.4.5. After1.5. 定时器1.6. 时间格式化1.6.1. 解析字符串格式的时间2. 练习1. time包 go内置的time提供了时间相关的函数 1.1. 时间类型 time.Time类型表示时间， 通过time.Now()获得当前时间的时间对象，然后利用该对象的各种方法，获取年月日等信息 e.g. package main import ( \"fmt\" \"time\" ) func main() { // 获得当前的时间对象 nowTimeObj := time.Now() // 利用对象的各种方法，获得年月日等信息 year := nowTimeObj.Year() month := nowTimeObj.Month() day := nowTimeObj.Day() hour := nowTimeObj.Hour() min := nowTimeObj.Minute() sec := nowTimeObj.Second() fmt.Printf(\"%d-%02d-%02d %02d:%02d:%02d\\n\", year, month, day, hour, min, sec) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/14time (master) $ go run main.go 2021-01-22 17:23:12 1.2. 时间戳 时间戳是1970年，1月1至今的秒数，又叫做unixTimestamp 1、时间格式转为时间戳 package main import ( \"fmt\" \"time\" ) func main() { // 获得当前的时间对象 nowTimeObj := time.Now() // 时间戳获得 timeStamp1 := nowTimeObj.Unix() timeStamp2 := nowTimeObj.UnixNano() // 精确到纳秒 fmt.Println(timeStamp1) fmt.Println(timeStamp2) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/14time (master) $ go run main.go 1611307814 1611307814421148300 2、时间戳转为时间格式 package main import ( \"fmt\" \"time\" ) func main() { // time.Unix将时间戳转为时间对象 time1 := time.Unix(1611307814, 0) // 获取时间对象的年和月 year := time1.Year() month := time1.Month() fmt.Printf(\"%d-%02d\\n\", year, month) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/14time (master) $ go run main.go 2021-01 1.3. 时间间隔 time包中的Duration类型代表时间间隔，表示2个时间点之间的时间间隔，单位是纳秒 定义： type Duration int64 // 本质就是基于int64定义的自定义类型，存储形式还是int64的整型 const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) 一个Duration就是1纳秒，time.Duration就是1纳秒；time.Second就是1s，time.Hour就是1小时 1.4. 时间操作 1.4.1. Add 语法： func (t Time) Add(d Duration) Time 求一个小时后的时间 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() fmt.Println(now) // add later := now.Add(time.Hour) fmt.Println(later) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/14time (master) $ go run main.go 2021-01-25 15:04:55.9893984 +0800 CST m=+0.002014401 2021-01-25 16:04:55.9893984 +0800 CST m=+3600.002014401 1.4.2. Sub 语法：求2个时间点之间的间隔 func (t Time) Sub(u Time) Duration // 调用某个时间对象的Sub方法，再传入一个时间类型，返回的Duration，就是这2个时间点的时间间隔 // 若要获取t-d这个时间点，用t.Add(-d)就行 1.4.3. Equal 语法： func (t Time) Equal(u Time) bool // 可以判断t和传入的u，2个时间点是否相等，是则返回true，（且会考虑事时区的因素 1.4.4. Before 语法： func (t Time) Before(u Time) bool // t若在u时间点之前，则返回true 1.4.5. After 语法： func (t Time) After(u Time) bool // t在u时间点之后，返回true 1.5. 定时器 使用time.Tick时间间隔可以设置定时器，定时器本质是一个通道(channel) package main import ( \"fmt\" \"time\" ) func main() { ticker := time.Tick(time.Second) // 设置一个间隔一秒的定时器，效果是每秒都会执行打印任务 for i := range ticker { fmt.Println(i) } } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/14time (master) $ go run main.go 2021-01-25 15:24:15.9191352 +0800 CST m=+1.002174601 2021-01-25 15:24:16.9195181 +0800 CST m=+2.002557501 2021-01-25 15:24:17.9198929 +0800 CST m=+3.002932301 2021-01-25 15:24:18.9194266 +0800 CST m=+4.002466001 2021-01-25 15:24:19.920871 +0800 CST m=+5.003910401 1.6. 时间格式化 go中时间格式化的格式表示，不是用Y-m-d 这些，而是用go的诞生时间2006年的1月2号15时04分，是周一，（记忆口诀为2006 1 2 3（下午三点） 4 例子： package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() // now这个时间对象，按照Format中传入的时间格式，打印 // 秒后面的000，表示，将当前时间的毫秒数也打印 fmt.Println(now.Format(\"2006-01-02 15:04:00.000 Mon Jan\")) // 按照12小时制输出 fmt.Println(now.Format(\"2006 01 02 03:04:00.000 PM Mon Jan\")) fmt.Println(now.Format(\"2006 01 02\")) fmt.Println(now.Format(\"15:04:00 2006:01:02\")) } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/14time (master) $ go run main.go 2021-01-25 15:35:00.982 Mon Jan 2021 01 25 03:35:00.982 PM Mon Jan 2021 01 25 15:35:00 2021:01:25 1.6.1. 解析字符串格式的时间 时间对象之间做操作时，比如取间隔，要考虑到时区的因素，可以用time.LoadLocation加载需要的时区 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() fmt.Println(now) // 加载时区为上海，之前操作的时间字符串，都可以传入该loc，将其当作亚洲东八区来处理 loc, err := time.LoadLocation(\"Asia/Shanghai\") if err != nil { fmt.Println(err) return } // 将中间的时间字符串，按照第一个参数格式解析，按照第三个参数时区处理 tommorrowTimeObj, err := time.ParseInLocation(\"2006/01/02 15:04:00\", \"2021/01/26 15:45:00\", loc) if err != nil { fmt.Println(err) return } fmt.Println(tommorrowTimeObj) fmt.Println(tommorrowTimeObj.Sub(now)) } 2. 练习 1、获取当前时间，格式化输出为2017/06/19 20:30:05`格式。 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() fmt.Println(now) fmt.Println(now.Format(\"2006/01/02 15:04:00\")) } 2、编写程序统计一段代码的执行耗时时间，单位精确到微秒。 package main import ( \"fmt\" \"time\" ) func main() { begin := time.Now() fmt.Println(begin) sum := 0 for i := 0; i latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_3go标准库log包.html":{"url":"2-go常用标准库/2_3go标准库log包.html","title":"2_3go标准库log包","keywords":"","body":"1. log1.1. 使用logger1.2. 配置logger1.2.1. 标准logger的配置1.2.2. flag选项1.2.3. 配置日志前缀1.2.4. 配置日志输出位置1.3. 创建logger1.4. 总结1. log 软件开发时的调试阶段，和软件上线后的运行阶段，都需要记录相应日志 1.1. 使用logger log包定义了logger类型，该类型提供了格式化输出的方法，也提供预定义的“标准”logger，通过调用函数print系列(print|printf|printfln)，fatal系列(fatal|fatalf|fataln)和panic系列(panic|panicf|panicln)使用 示例： fatal系列的打印，会将日志输出后，调用os.Exit(1)，而panic系列的打印会在写入日志后panic package main import \"log\" func main() { log.Println(\"这是一条普通日志\") v := \"普通日志\" log.Printf(\"一条普通日志,\\n\", v) log.Fatalln(\"fatal日志\") // 执行不到下面的panic日志，遇到fatal就退出了os.Exit(1) log.Panicln(\"panic日志\") } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/15log (master) $ go run main.go 2021/01/25 16:21:57 这是一条普通日志 2021/01/25 16:21:57 一条普通日志, %!(EXTRA string=普通日志) 2021/01/25 16:21:57 fatal日志 exit status 1 panic日志： package main import \"log\" func main() { log.Println(\"这是一条普通日志\") v := \"普通日志\" log.Printf(\"一条普通日志,\\n\", v) // log.Fatalln(\"fatal日志\") // 执行不到下面的panic日志，遇到fatal就退出了os.Exit(1) log.Panicln(\"panic日志\") } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/15log (master) $ go run main.go 2021/01/25 16:24:35 这是一条普通日志 2021/01/25 16:24:35 一条普通日志, %!(EXTRA string=普通日志) 2021/01/25 16:24:35 panic日志 panic: panic日志 goroutine 1 [running]: log.Panicln(0xc00010ff68, 0x1, 0x1) D:/mySoftware/Go/src/log/log.go:365 +0xb3 main.main() D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:12 +0x114 exit status 2 1.2. 配置logger 1.2.1. 标准logger的配置 默认情况下，logger只提供日志的时间信息，而若要记录该日志的文件名和行号等信息，log标准库提供了定制这些设置的方法； log标准库中的flags函数会返回标准logger的输出配置，而SetFlags函数设置标准logger的输出配置 func Flags() int func SetFlags(flag int) 1.2.2. flag选项 log标准库提供了如下的flag选项，是一系列定义好的常量，（用于控制要输出哪些日志信息，而不控制它们的顺序和格式） const ( Ldate = 1 示例： package main import \"log\" func main() { // 先设置日志格式 log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) // 再打印日志 log.Println(\"一条普通日志，\") } // 输出的日志带有日期和完整的文件路径名 latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/15log (master) $ go run main.go 2021/01/25 16:40:56.503568 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:10: 一条普通日志， 1.2.3. 配置日志前缀 log标准库还提供了关于日志信息前缀的2个方法： func Prefix() string // 查看标准logger的输出前缀 func SetPrefix() (prefix string) // 设置logger的输出前缀 示例： package main import ( \"fmt\" \"log\" ) func main() { // 先设置日志格式 log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) // 再打印日志 fmt.Println(log.Prefix()) log.Println(\"一条普通日志\") // 设置日志前缀 log.SetPrefix(\"[一个前缀]\") fmt.Println(log.Prefix()) // 查看日志前缀 log.Println(\"还是一个普通日志\") } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/15log (master) $ go run main.go 2021/01/25 16:47:34.646835 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:15: 一条普通日志 [一个前缀] [一个前缀]2021/01/25 16:47:34.657805 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:19: 还是一个普通日志 1.2.4. 配置日志输出位置 配置日志输出位置的函数，默认是标准错误输出 func SetOuptut(w io.Writer) 下例将日志输出到同目录下的test.log中 package main import ( \"fmt\" \"log\" \"os\" ) func main() { outputFile, err := os.OpenFile(\"./test.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Println(err) return } // 设置日志输出位置、日志前缀、日志flag控制输出哪些额外信息 log.SetOutput(outputFile) log.SetPrefix(\"[test log]\") log.SetFlags(log.Llongfile | log.Ldate) log.Println(\"一行日志\") log.Println(\"一行日志\") log.Println(\"一行日志\") } 输出到test.log内容如下： [test log]2021/01/25 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:19: 一行日志 [test log]2021/01/25 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:20: 一行日志 [test log]2021/01/25 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:21: 一行日志 [test log]2021/01/25 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:19: 一行日志 [test log]2021/01/25 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:20: 一行日志 [test log]2021/01/25 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:21: 一行日志 写到init（）函数中 可以将上述步骤写到init()函数中 package main import ( \"fmt\" \"log\" \"os\" ) func init() { outputFile, err := os.OpenFile(\"./test.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Println(err) return } log.SetOutput(outputFile) log.SetPrefix(\"[test log]\") log.SetFlags(log.Llongfile | log.Ldate) } func main() { log.Println(\"一行日志\") log.Println(\"一行日志\") log.Println(\"一行日志\") } 1.3. 创建logger log标准库提供了构造函数New，可以创建一个新的logger对象，定义如下： func New(out io.Writer, prefix string, flag int) *Logger { return &Logger{out: out, prefix: prefix, flag: flag} } e.g. package main import ( \"log\" \"os\" ) func main() { alogger := log.New(os.Stdout, \"\", log.Ldate|log.Llongfile) alogger.Println(\"一条新日志\") } latteplus@LAPTOP-00EFC09V MINGW64 /d/myCode/Go/src/learngo/basic_grammar/15log (master) $ go run main.go 2021/01/25 D:/myCode/Go/src/learngo/basic_grammar/15log/main.go:11: 一条新日志 1.4. 总结 go内置log库功能有限，实际项目中常需要用第三方日志库如 logrus、zap等 latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_4go标准库strconv.html":{"url":"2-go常用标准库/2_4go标准库strconv.html","title":"2_4go标准库strconv","keywords":"","body":"1. strconv包1.1. string和int类型转换1.1.1. Atoi()1.1.2. Itoa()1.1.3. a的由来1.2. Parse系列函数1.2.1. ParseBool()1.2.2. ParseInt()1.2.3. ParseUnit()1.2.4. ParseFloat()1.2.5. 代码示例1.3. Format系列函数1.3.1. FormatBool()1.3.2. FormatInt()1.3.3. FormatUint()1.3.4. FormatFloat()1.3.5. 代码示例1.4. 其他1.4.1. isPrint()1.4.2. CanBackquote()1.4.3. 其他1. strconv包 strconv包的作用：实现了基本数据类型和其字符串表示的相互转换的方法 如“100”转为int 的100（从文件中读取的100往往就是字符串类型，存储到变量时，应该先转为int类型 官方文档 1.1. string和int类型转换 1.1.1. Atoi() 将字符串类型的整数转为int类型，函数定义如下： func Atoi(s string) (i int, err error) 若传入的字符串参数无法转为int类型，就会返回错误 s1 := \"100\" i1, err := strconv.Atoi(s1) if err != nil { fmt.Println(\"can`t convert to int\") } else { fmt.Printf(\"type: %T value: %#v \\n\", i1, i1) // type:int value:100 } 1.1.2. Itoa() 将int类型数据转为对应的字符串表示，函数定义如下： func Itoa(i int) string e.g. i2 := 200 s2 := strconv.Itoa(i2) fmt.Printf(\"type:%T value:%#v\\n\", s2 ,s2) // type:string value :\"200\" 1.1.3. a的由来 a在c语言中表示字符数据array，而c中没有字符串，只有字符数组，而go又很像c，因此Itoa，a就是代表字符串的意思 1.2. Parse系列函数 Parse系列函数用于将字符串转为给定类型的值；有： ParseBool() ParseFloat() ParesInt() ParseUint() 1.2.1. ParseBool() 函数定义 func ParseBool (str string) (value bool ,err error) 返回的value是传入的str所代表的bool值，可以接收的str有 1、 0、 t、 f、 T、 F、 true、false、True、False、TRUR、FALSE 1.2.2. ParseInt() func ParseInt(s string, base int, bitSize int) (i int64 , err error) 返回的i为字符串所代表的整数值，接受正负号 base指定进制2到36，若base是0，则从字符串的前缀判断，“ox”是16进制、“o”是八进制、否则是10进制 bitSiez指定结果必须能无溢出赋值的整数类型，0 8 16 32 64 分别 int、in8 、int16、 int32、int64 返回的err是*NumErr类型，若语法有误，err.Error=ErrSynat，如果结果超出类型范围，err.Error = ErrRange 1.2.3. ParseUnit() func ParseUint (s string, base int, bitSize int ) (n uint64, err error) ParseUint类似ParseInt，但不接收正负号，用于无符号整型 1.2.4. ParseFloat() func ParseFloat(s string, bitSize int) (f float64 , err error) 解析一个表示浮点数的字符串，并返回其值 若s合乎语法规则，函数会返回最为接近s表示值的一个浮点数 bitSize指定了期望的接收类型，32代表float32,64代表float64 返回值err是*NumErr类型，语法有误，err.Error = ErrSyntax，结果超出表示范围的，返回值为正负Inf，err.Error = ErrRange 1.2.5. 代码示例 b, err := strconv.ParseBool(\"true\") f, err := strconv.ParseFloat(\"3.1415\", 64) i, err := strconv.ParseInt(\"-2\", 10, 64) u, err := strconv.ParseUint(\"2\", 10, 64) 这些函数都有2个返回值，第一个是转换后的值，第二个是转化失败的化的提示信息 1.3. Format系列函数 Format系列函数，实现了将给定类型数据格式化为string类型数据的功能 1.3.1. FormatBool() func FormatBool(b bool) string 根据b的值，返回“true”或“false” 1.3.2. FormatInt() func FormatInt(i int64 , base int) string 返回i的base进制的字符串表示，base必须在2到36之间，结果中会使用小写字母“a”到“z”表示大于10 的数字 1.3.3. FormatUint() func FormatUint( i uint64, base int) string FormatInt()的无符号整数版本 1.3.4. FormatFloat() func FormatFloat(f float64, fmt byte ,prec, bitSize int) string 函数将浮点数表示为字符串并返回 bitSize表示f的类型，32对应float32,64对应float64 fmt表示格式， prec控制精度 参考官方解释：https://golang.org/pkg/strconv/#FormatFloat 1.3.5. 代码示例 s1 := strconv.FormatBool(true) s2 := strconv.FormatFloat(3.1415, 'E', -1, 64) s3 := strconv.FormatInt(-2, 16) s4 := strconv.FormatUint(2, 16) 1.4. 其他 1.4.1. isPrint() func IsPrint(r rune) bool 返回一个字符是否是可以打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ascll空格 1.4.2. CanBackquote() func CanBackquote(s string) bool 返回字符串s是否可以不被修改的表示一个单行的、没有空格和tab之外控制字符的反引号字符串 1.4.3. 其他 除了以上函数外，strconv包，还有Appen系列，Quote系列等，参见官方的标准库介绍 latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_5go标准库net下的http包.html":{"url":"2-go常用标准库/2_5go标准库net下的http包.html","title":"2_5go标准库net下的http包","keywords":"","body":"1. net/http介绍1.1. http协议2. http客户端2.1. http/https请求2.2. GET请求示例2.3. 带参数的GET请求2.4. POST请求示例2.5. 自定义Client2.6. 自定义Transport3. 服务端3.1. 简单的server示例3.2. 默认的server3.3. 自定义server1. net/http介绍 go内置的net/http包提供了http客户端和服务端的实现 1.1. http协议 http超文本传输协议，提供了发送和接收html页面的方法 2. http客户端 2.1. http/https请求 http包内置了实现GET POST HEAD...这些方法的方法，分别对应http.Get http.Post http.PostForm e.g. resp, err := http.Get(\"http://example.com/\") ... resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &buf) ... resp, err := http.PostForm(\"http://example.com/form\", url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}) 得到的resp对象，在使用完毕后，必须关闭 resp, err ;= http.Get(\"http://www.example.com/\") if err != nil { // handle error } // 注册一个关闭语句 defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... 2.2. GET请求示例 利用net/http包实现一个简单的发送http请求的客户端，如下： package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { // 得到一个resp对象，是*Response resp, err := http.Get(\"https://boogie96.gitee.io\") if err != nil { fmt.Println(\"get failed,\", err) return } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf(\"read from resp.Body failed, err :%v\\n\", err) return } fmt.Println(string(body)) } 上述代码，可以获取boogie96.gitee.io的网站首页文件，并以纯文本方式打印到终端，浏览器其实也是http协议客户端，收发http数据，并把收到的文本文件，按照css，html，的规则渲染出来 2.3. 带参数的GET请求 1、server端 package main import ( \"fmt\" \"net/http\" ) // handleGet 接收一个w写回复类型，接收一个r请求类型 func handleGet(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() // 先注册一个请求的body关闭语句 // Values map[string][]string 通过URL.Query()方法，得到客户端发来的参数，是个map[string][]string类型， // 然后用get取出各个参数值，再返回客户端一个回复 data := r.URL.Query() fmt.Println(data.Get(\"name\")) fmt.Println(data.Get(\"age\")) answer := \"recv ok\" w.Write([]byte(answer)) } func main() { // 把url处理函数写在注册监听之前；对于/get url，调用handleGet处理， http.HandleFunc(\"/get/\", handleGet) http.ListenAndServe(\"127.0.0.1:9000\", nil) // 像下面这样，先监听，后调用url处理函数，就会出现，如下图失败案例所示：访问时出现404 page not found的情况，（一定要先把所有的url处理函数写在监听之前 // http.ListenAndServe(\"127.0.0.1:9000\", nil) // http.HandleFunc(\"/get/\", handleGet) } 2、client端 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"net/url\" ) func main() { apiUrl := \"http://127.0.0.1:9000/get\" data := url.Values{} data.Set(\"name\", \"wang\") data.Set(\"age\", \"24\") // 对要访问的apiUrl进行编码处理 u, err := url.ParseRequestURI(apiUrl) if err != nil { fmt.Println(\"parse url failed\", err) } // 对要传入的参数进行编码，然后添加到编码后的apiUrl中 u.RawQuery = data.Encode() fmt.Println(u.String()) // 发起访问 resp, err := http.Get(u.String()) if err != nil { fmt.Println(\"request failed\", err) return } defer resp.Body.Close() // 读取服务端的响应 b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"get resp failed\", err) return } fmt.Println(string(b)) } 成功访问： 失败示例： 2.4. POST请求示例 1、服务端 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func postHandler(w http.ResponseWriter, r *http.Request) { /* 1 先defer注册一个r的Body的关闭操作 2 然后根据传入的http请求，contenttype的类别选择不同的处理逻辑，并从中取出post传入的数据 3 然后返回客户端响应数据 */ defer r.Body.Close() // 请求类型是application/x-www-form-urlencodeed时，解析数据 // 解析在编码进url的参数数据并打印 r.ParseForm() // fmt.Println(r.PostForm) // fmt.Println(r.PostForm.Get(\"name\"), r.PostForm.Get(\"age\"), \"haha\") // 请求类型是application/json时，从r.Body读数据 b, err := ioutil.ReadAll(r.Body) if err != nil { fmt.Println(\"read request from client failed, \", err) return } fmt.Println(string(b)) // 返回响应数据给客户端 answer := \"recv your data ,status is ok\" w.Write([]byte(answer)) } func main() { http.HandleFunc(\"/post\", postHandler) http.ListenAndServe(\"127.0.0.1:8080\", nil) } 2、客户端 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"strings\" ) func main() { /* 先定义要访问的url 然后定义要传入的post参数 然后将编码后的url和参数，传入http.Get 获得响应，判断是否有错误，没有就打印成功，并接收客户端的响应 其中编码post要传入的参数时，有2种方式 1，把参数和Url编码到一起 2，把参数编码到请求体的body中 */ apiURL := \"http://127.0.0.1:8080/post\" // 表单数据 // contentType 是 application/x-wwww-form-urlencoded // contentType := \"application/x-www-form-urlencodeed\" // data := `{\"name\":\"wang\", \"age\":24}` // json传参 contentType := \"application/json\" data := `{\"name\":\"wang\", \"age\":24}` resp, err := http.Post(apiURL, contentType, strings.NewReader(data)) if err != nil { fmt.Println(\"post failed,\", err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"recv from server failed,\", err) return } fmt.Println(string(b)) // json类型 } 3、运行截图 2.5. 自定义Client 可以通过自定义client，管理http客户端的头部、重定向策略和其他设置 client := &http.Client{ CheckRedirect :redirectPolicyFunc, } resp, err := client.Get(\"http://example.com\") req, err := http.NewRequest(\"GET\", \"http://example.com\", nil) req.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`) resp, err := client.Do(req) 2.6. 自定义Transport 可以通过自定义Transport，管理代理、tls配置、keep-alive，压缩等配置 tr := &http.Transport { TLSClientConfig ； &tls.Config{RootCAs: pool} DisableCompression :true, } client := &http.Client{Transport: tr} resp ,err := client.Get(\"https://example.com\") Client和Transport类型都可以安全的被多个goroutine同时使用，考虑效率，应该一次建立，尽量复用 3. 服务端 3.1. 简单的server示例 服务端代码，在本地监听了127.0.0.1的9000端口，并实现了一个url的处理函数，f1，负责处理访问/get这个url的逻辑，通过建立连接后获取的responseWrite对象，的Write方法向客户端写一个字符串 package main import ( \"net/http\" ) func f1(w http.ResponseWriter, r *http.Request) { str := \"this is test html\" w.Write([]byte(str)) } func main() { http.HandleFunc(\"/test/\", f1) http.ListenAndServe(\"127.0.0.1:9000\", nil) } 然后启动编译后的server.exe，然后在浏览器访问本地的127.0.0.1:9000/test/ 3.2. 默认的server ListenAndServe使用指定的监听地址和处理器启动一个http服务端。处理器参数通常是nil，表示用包变量DefaultServeMux作为处理器 Handle和HandleFunc函数可以向DefaultServeMux添加处理器 http.Handle(\"/foo\", fooHandler) http.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request){ fmt.Fprintf(w, \"hello, %q\", html.EscapeString(r.URL.Path)) }) log.Fatal(http.ListenAndServe(\":8080\", nil)) 3.3. 自定义server 要管理服务端的行为，可以创建一个自定义的server s := &http.Server{ Addr : \":8080\", Handler: myHandler, ReadTimeout: 10*time.Second WriteTimeout: 10 * time.Second MaxHeaderBytes: 1 latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_6go标准库之flag.html":{"url":"2-go常用标准库/2_6go标准库之flag.html","title":"2_6go标准库之flag","keywords":"","body":"1. os.Args1.1. 导入flag包1.2. flag参数类型1.3. 定义命令行flag参数1.3.1. flag.Type()1.3.2. flag.TypeVar()1.4. flag.Parse()1.5. flag其他函数1.6. 完整示例1.6.1. 定义1.6.2. 使用1. os.Args go内置的flag包实现了命令行参数的解析，flag包使得开发命令行工具更为简单 使用示例： os.Args返回的是一个字符串类型的切片，其第一个元素为二进制执行文件的名称；然后就是在命令行中传入的各个参数 package main import ( \"fmt\" \"os\" ) func main() { // os.Args是一个[]string if len(os.Args) > 0 { for index, arg := range os.Args { fmt.Printf(\"参数%d, 参数值 %s\\n\", index, arg) } } } 运行测试： $ ./24flag.exe a b c haha 参数0, 参数值 C:\\myworkstation\\mygocode\\src\\learngo\\basic_grammar\\24flag\\24flag.exe 参数1, 参数值 a 参数2, 参数值 b 参数3, 参数值 c 参数4, 参数值 haha 1.1. 导入flag包 import \"flag\" 1.2. flag参数类型 flag包支持的命令行参数类型有：bool int int64 uint uint64 float float64 string duration 1.3. 定义命令行flag参数 定义命令行参数有如下方法 1.3.1. flag.Type() 基本格式如下： flag.Type(flag名,默认值，帮助信息) *Type name := flag.String(\"name\", \"lisi\" , \"姓名\") age := flag.Int(\"age\", 18, \"年龄\") married := flag.Bool(\"married\", false, \"婚否\") delay :=flag.Duratiom(\"d\", 0, \"时间间隔\") 此时，name age married delay ，均为对应类型的指针 1.3.2. flag.TypeVar() 基本格式如下： flag.TypeVar(Type指针， flag名， 默认值，帮助信息) var name string var age int var married bool flag.StringVar(&name, \"name\", \"lisi\", \"姓名\") flag.IntVar(&age, \"age\", 18, \"年龄\") flag.BoolVar(&married, \"married\", false, \"婚否\") 1.4. flag.Parse() 通过以上2中方式定义好flag参数后，通过调用flag.Parse()来对命令行参数进行解析 支持的命令行参数格式有下面几种： -flag xxx -- flag xxx -flag=xxx --flag=xxx 其中bool类型的参数必须以等号方式指定 flag解析在第一个非flag参数之前停止，或者在终止符号- 之后停止 1.5. flag其他函数 flag.Args() 返回命令行参数后的其他参数，以[]string类型 flag.Narg() 返回命令行参数后的其他参数个数 flag.NFlag()返回使用的命令行参数个数 1.6. 完整示例 1.6.1. 定义 package main import ( \"flag\" \"fmt\" \"time\" ) // flag demo func main() { // 定义四个变量，用于存储4个flag参数 var name string var age int var married bool var delay time.Duration // 四个参数分别为，要存放到哪个变量的指针，flag字段名（即传参时--后的字符串），默认值，以及打印--help时,该字段的解释信息 flag.StringVar(&name, \"personName\", \"老王\", \"输入的人员姓名\") flag.IntVar(&age, \"personAge\", 18, \"人的年龄\") flag.BoolVar(&married, \"isMarried\", false, \"结婚状态\") flag.DurationVar(&delay, \"howlong\", 3600000000000, \"结婚多久的时间\") // 解析命令行参数 flag.Parse() // 打印解析后的flag的值 fmt.Println(name, age, married, delay) // 打印命令行参数后的其他参数 fmt.Println(flag.Args()) // 打印命令行参数后的其他参数个数 fmt.Println(flag.NArg()) // 打印命令行参数的个数 fmt.Println(flag.NFlag()) } 1.6.2. 使用 打印提示信息，输出了4个flag字段的字段名，类型，字段说明，和默认值 $ ./24flag.exe --help Usage of C:\\myworkstation\\mygocode\\src\\learngo\\basic_grammar\\24flag\\24flag.exe: -howlong duration 结婚多久的时间 (default 1h0m0s) -isMarried 结婚状态 -personAge int 人的年龄 (default 18) -personName string 输入的人员姓名 (default \"老王\") 填入四个flag参数，看到对应的输出，四个flag参数后没有参数，所以flag.Narg()个数是0，flag.Args()字符串切片是空 $ ./24flag.exe -howlong=24h -isMarried=true -personAge=24 -personName=shuaibi shuaibi 24 true 24h0m0s [] 0 4 四个flag参数后加了3个参数，所以flag.Narg()个数是3flag.Args()字符串切片是这三个字符串， a b c ten@DESKTOP-7ICOPRG MINGW64 /c/myworkstation/mygocode/src/learngo/basic_grammar/24flag (master) $ ./24flag.exe -howlong=24h -isMarried=true -personAge=24 -personName=shuaibi a b c shuaibi 24 true 24h0m0s [a b c] 3 4 latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_7go标准库之fmt.html":{"url":"2-go常用标准库/2_7go标准库之fmt.html","title":"2_7go标准库之fmt","keywords":"","body":"1. fmt1.1. 向外输出1.1.1. Print1.1.2. Fprint1.1.3. Sprint1.1.4. Errorf1.2. 格式化占位符1.2.1. 通用占位符1.2.2. 布尔型1.2.3. 整型1.2.4. 浮点数与复数1.2.5. 字符串和[]byte1.2.6. 指针1.2.7. 宽度标识符1.2.8. 其他flag1.3. 获取输入1.3.1. fmt.Scan1.3.2. fmt.Scanf1.3.3. fmt.Scanln1.3.4. bufio.NewReader1.3.5. Fscan系列1.3.6. Sscan系列1. fmt fmt包，实现了类似c语言中printf和scanf的格式化IO，分为向外输出内容，和获取输入内容2大块 1.1. 向外输出 1.1.1. Print Print系列函数，会把内容输出到系统的标准输出，区别是： Print函数直接输出内容； Printf函数支持格式输出字符串； Println函数会在输出内容末尾加一个换行符 三个函数签名如下： func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) e.g. package main import \"fmt\" // /Print 系列函数demo func main() { fmt.Print(\"哈哈\") name := \"嘻嘻\" fmt.Printf(\"名字是 %s\\n\", name) fmt.Println(\"嘿嘿\") } $ go run main.go 哈哈名字是 嘻嘻 嘿嘿 1.1.2. Fprint Fprint系列函数，相比于Print，会多传一个io.Writer类型的参数w，表示向w代表的位置写入信息，如文件、标准输出等，只要是io.Writer类型的变量都可以写入 函数签名如下： func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) e.g. package main import ( \"fmt\" \"os\" ) // Fprint demo func main() { // 写到标准输入 fmt.Fprintln(os.Stdout, \"哈哈\") fileObj, err := os.OpenFile(\"./1.txt\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) if err != nil { fmt.Println(\"打开文件出错了\", err) return } name := \"xixi\" fmt.Fprintf(fileObj, \"向文件中写入信息： %s\", name) } $ go run main.go 哈哈 1.1.3. Sprint Sprint系列会把传入的数据生成一个字符串，并返回 函数签名 func Sprint(a ...interface{}) string func Sprintf(format string, a ...interface{}) string func Sprintln(a ...interface{}) string e.g. package main import ( \"fmt\" ) // Sprint demo func main() { s1 := fmt.Sprint(\"哈哈哈\") name := \"wang\" age := 24 s2 := fmt.Sprintf(\"name :%s, age :%d\\n\", name, age) s3 := fmt.Sprintln(\"嘻嘻嘻\") fmt.Println(s1, s2, s3) } $ go run main.go 哈哈哈 name :wang, age :24 嘻嘻嘻 1.1.4. Errorf Errorf函数根据format参数生成格式化字符串，并返回一个包含该字符串的错误 函数签名： func Errorf(format string, a ...interface{}) error 通常使用该方式，定义了一个自定义错误类型，如下 err := fmt.Errorf(\"一个自定义的错误\") go 1.13版本为fmt.Errof函数新加一个%w占位符，用来生成一个可以包裹Error的Wrapping Error e := errors.New(\"内置错误\") w := fmt.Errorf(\"自定义错误里Wrap了一个内置错误%w\",e) e.g. package main import ( \"errors\" \"fmt\" ) // Errorf demo func main() { e := errors.New(\"内置错误\") err := fmt.Errorf(\"自定义包含了一个内置错误 %w\\n\", e) fmt.Println(e) fmt.Println(err) } $ go run main.go 内置错误 自定义包含了一个内置错误 内置错误 1.2. 格式化占位符 *printf系列函数都支持format格式化参数，这里按照占位符将被替换的变量类型划分 1.2.1. 通用占位符 占位符 说明 %v 值的默认格式输出 %+v 相比%v，输出时结构体时会多个字段名 %#v 值的go语法表示 %T 打印值的类型 %% 百分号 e.g. package main import \"fmt\" // Errorf demo func main() { fmt.Printf(\"%v\\n\", 100) fmt.Printf(\"%v\\n\", false) o := struct{ name string }{\"hahaha\"} fmt.Printf(\"%v\\n\", o) fmt.Printf(\"%#v\\n\", o) fmt.Printf(\"%T\\n\", o) fmt.Printf(\"100%%\\n\") } $ go run main.go 100 false {hahaha} struct { name string }{name:\"hahaha\"} struct { name string } 100% 1.2.2. 布尔型 %t 是true或false的占位符 1.2.3. 整型 占位符 说明 %b 表示二进制 %c 该值对应的unicode编码 %d 十进制 %o 二进制 %x 十六进制 a-f用小写 %X 十六进制，A-F用大写 %U 表示为Unicode格式：U+1234，等价于”U+%04X” %q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 e.g. package main import \"fmt\" func main() { n := 65 fmt.Printf(\"%b\\n\", n) fmt.Printf(\"%d\\n\", n) fmt.Printf(\"%o\\n\", n) fmt.Printf(\"%x\\n\", n) fmt.Printf(\"%X\\n\", n) fmt.Printf(\"%o\\n\", n) fmt.Printf(\"%c\\n\", n) fmt.Printf(\"%U\\n\", n) fmt.Printf(\"%q\\n\", n) } $ go run main.go 1000001 65 101 41 41 101 A U+0041 'A' 1.2.4. 浮点数与复数 占位符 说明 %b 无小说部分，二进制指数表示的科学计数法，如-123456p-78 %e 科学计数法，如-1234.456e+78 %E 科学计数法，如-1234.456E+78 %f 有小数部分但无指数部分，如123.456 %F 等价于%f %g 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） e.g. package main import \"fmt\" func main() { f := 12.34 fmt.Printf(\"%e\\n\", f) fmt.Printf(\"%E\\n\", f) fmt.Printf(\"%b\\n\", f) fmt.Printf(\"%f\\n\", f) fmt.Printf(\"%F\\n\", f) fmt.Printf(\"%g\\n\", f) fmt.Printf(\"%G\\n\", f) } $ go run main.go 1.234000e+01 1.234000E+01 6946802425218990p-49 12.340000 12.340000 12.34 12.34 1.2.5. 字符串和[]byte 占位符 说明 %s 直接输出字符串或者[]byte %q 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示（使用a-f %X 每个字节用两字符十六进制数表示（使用A-F） package main import \"fmt\" func main() { s := \"小王\" fmt.Printf(\"%s\\n\", s) fmt.Printf(\"%q\\n\", s) fmt.Printf(\"%x\\n\", s) fmt.Printf(\"%X\\n\", s) } $ go run main.go 小王 \"小王\" e5b08fe78e8b E5B08FE78E8B 1.2.6. 指针 占位符 说明 %p 表示为十六进制，并加上前导的0x e.g. package main import \"fmt\" func main() { a := 10 fmt.Printf(\"%p\\n\", &a) fmt.Printf(\"%#p\\n\", &a) } $ go run main.go 0xc0000120c0 c0000120c0 1.2.7. 宽度标识符 输出的宽度由跟在百分号后的一个十进制数表示，（可选：宽度后加. 点号之后再加一个十进制数表示精度） 若没有给定宽度标识位或没有精度标识位，则表示采用默认的值，如下： 占位符 说明 %f 默认宽度，默认精度 %9f 宽度9，默认精度 %.2f 默认宽度，精度2 %9.2f 宽度9，精度2 %9.f 宽度9，精度0 package main import \"fmt\" func main() { n := 12.34 fmt.Printf(\"%f\\n\", n) fmt.Printf(\"%9f\\n\", n) fmt.Printf(\"%.2f\\n\", n) fmt.Printf(\"%9.2f\\n\", n) fmt.Printf(\"%9.f\\n\", n) } $ go run main.go 12.340000 12.340000 12.34 12.34 12 1.2.8. 其他flag 占位符 说明 ’+’ 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； ’ ‘ 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格 ’-’ 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； ’#’ 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值； ‘0’ 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； s := \"小王子\" fmt.Printf(\"%s\\n\", s) fmt.Printf(\"%5s\\n\", s) fmt.Printf(\"%-5s\\n\", s) fmt.Printf(\"%5.7s\\n\", s) fmt.Printf(\"%-5.7s\\n\", s) fmt.Printf(\"%5.2s\\n\", s) fmt.Printf(\"%05s\\n\", s) 小王子 小王子 小王子 小王子 小王子 小王 00小王子 1.3. 获取输入 fmt包中：有fmt.Scan fmt.Scanf fmt.Scanln三个函数，可以在程序运行中从标准输入获取用户输入 1.3.1. fmt.Scan 函数签名 func Scan(a ...interface{}) (n int, err error) Scan从标准输入扫描文本，读取由空白符分隔的值，保存到传递给本函数的参数中，换行符视为空白符 返回成功扫描的数据个数，和遇到的错误， e.g. package main import \"fmt\" func main() { var ( name string age int married bool ) fmt.Scan(&name, &age, &married) fmt.Printf(\"扫描结果： name: %s age : %d married: %t \\n\", name, age, married) } $ ./25fmt.exe xiaowang 24 false 扫描结果： name: xiaowang age : 24 married: false $ ./25fmt.exe haha 25 true 扫描结果： name: haha age : 25 married: true 中间有换行符不影响， 1.3.2. fmt.Scanf 函数签名： func Scanf(format string, a ...interface{}) ( n int, err error) 从标准输入扫描文件，根据format的格式，去读取由空白符分隔的值，保存到传递给本函数的参数中 e.g. 可以看到，必须按照format中的格式，把除去占位符的部分也输入，才可以正常获取到值 package main import \"fmt\" func main() { var ( name string age int married bool ) fmt.Scanf(\"1:%s 2:%d 3:%t\", &name, &age, &married) fmt.Printf(\"name : %s age :%d married :%t\\n\", name, age, married) } $ ./25fmt.exe haha 18 true name : age :0 married :false $ ./25fmt.exe 1: wang 2:18 3:false name : wang age :18 married :false 1.3.3. fmt.Scanln 函数签名 func Scanln(a ...interface{}) (n int, err error) Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。 e.g. package main import \"fmt\" func main() { var ( name string age int married bool ) fmt.Scanln(&name, &age, &married) fmt.Printf(\"name : %s age :%d married :%t\\n\", name, age, married) } 遇到回车符就结束，没有输入的对应值，为默认的零值 $ ./25fmt.exe wang name : wang age :0 married :false $ ./25fmt.exe wang 18 false name : wang age :18 married :false 1.3.4. bufio.NewReader 若想要输入的内容中，包含空格，此时用Scanln就非常不便，此时可以用bufio包实现 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { // 从标准输入获取一个读对象reader reader := bufio.NewReader(os.Stdin) fmt.Print(\"请输入内容\") // 利用读对象的ReadString方法，按行读取 content, _ := reader.ReadString('\\n') fmt.Printf(\"%#v\\n\", content) } $ ./25fmt.exe 请输入内容xixi haha shuaiqi lueluelue \"xixi haha shuaiqi lueluelue\\r\\n\" 1.3.5. Fscan系列 该系列函数类似于Scan系列，但不是从标准输入中读取，而是从io.Reader类型的对象中读取 func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) 1.3.6. Sscan系列 该系列函数类似于Scan系列，但不是从标准输入，而是从指定字符串中读取数据 func Sscan(str string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) latteplus            updated 2021-02-15 10:40:45 "},"2-go常用标准库/2_8go标准库之context.html":{"url":"2-go常用标准库/2_8go标准库之context.html","title":"2_8go标准库之context","keywords":"","body":"1. 为什么需要Context1.1. 基本示例1.2. 全局变量方式1.3. 通道方式1.4. 官方的Context2. Context简介3. Context接口3.1. Background()和TODO()4. With系列函数4.1. WithCancel4.2. WithDeadline4.3. WithTimeout4.4. WithValue5. Context注意事项6. 客户端超时取消示例6.1. server端6.2. client端6.3. 运行效果：1. 为什么需要Context 场景举例： go http包的server中，每个请求都有一个goroutine启动一个请求处理函数去处理，而请求处理函数通常会再启动额外的goroutine去访问后端服务，例如连接缓冲、连接数据库等等 （因此一个请求的多个阶段，一般对应多个goroutine在处理，而针对同一个请求，这些处理不同阶段的goroutine通常需要一些公用的信息，比如用户的账户密码信息、验证的token、请求的截至时间等），当一个请求被取消或超时时，处理该请求各个阶段的goroutine都应该一并迅速退出，然后系统释放goroutine所占用的资源 1.1. 基本示例 下例中，worker函数会一直运行，如何在调用它的main函数中，通知它何时退出呢？ package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func worker() { defer wg.Done() for { fmt.Println(\"worker processing...\") time.Sleep(time.Second) } } func main() { wg.Add(1) go worker() wg.Wait() fmt.Println(\"over\") } $ ./26context.exe worker processing... worker processing... worker processing... worker processing... 1.2. 全局变量方式 通过定义一个全局变量，为是否退出goroutine的标志位，在子goroutine中判断全局变量是否为true，如果为true就退出，在main函数中就可以通过通知全局变量在控制子goroutine退出的时机 如下： package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup var isOut bool // 默认是false func worker() { defer wg.Done() for { if isOut { break } fmt.Println(\"worker processing...\") time.Sleep(time.Second) } } func main() { wg.Add(1) go worker() time.Sleep(time.Second * 5) isOut = true wg.Wait() fmt.Println(\"over\") } $ ./26context.exe worker processing... worker processing... worker processing... worker processing... worker processing... over 存在的问题 跨包调用时变量名不统一，各个开发者的习惯不同 且多层goroutine嵌套时，控制逻辑很复杂 1.3. 通道方式 通过定义一个消息通知的通道，在子goroutine的运行中，利用一个select中的case分支，每次判断该通道是否发来了消息，如果有消息就退出。main函数可以通过向该通道中传值，来控制子goroutine的是否退出； package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func worker(exitChan chan bool) { defer wg.Done() LOOP: for { select { case 问题： 跨包调用需要维护一个公用的channel，不容易规范 1.4. 官方的Context 利用官方的Context实现控制goroutine的退出； 1、一层goroutine package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func worker(ctx context.Context) { defer wg.Done() TAG: for { select { // 类似通道方式，ctx的Done方法得到的也是一个通道，具体类型： 2、二层goroutine ctx可以一直传递，传递多层子goroutine package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func worker(ctx context.Context) { defer wg.Done() // 再开启一层goroutine go worker2(ctx) TAG: for { select { // 类似通道方式，ctx的Done方法得到的也是一个通道，具体类型： 2. Context简介 go1.7加入了一个新标准库context，它定义了Context类型，专用于简化处理单个请求的多个goroutine之间与请求域的数据、取消信号，截止时间等操作，这些操作可以涉及多个api调用； 对传入服务器的请求应该创建上下文，而对服务器的传出调用应该接收上下文，之间的函数链调用必须传递上下文，或可以使用WithCancel WithDeadline WithTimeout WithValue创建的派生上下文，当一个上下文取消时，其派生的上下文也该被取消； 3. Context接口 context.Context是一个接口，该接口定义了四个需要实现的方法，如下： type Context interface { Deadline() (deadline time.Time, ok bool) Done() Deadline（）方法返回当前Context被取消的时间，即完成工作的截止时间 Done()方法许返回一个Channel，该Channel会在当前工作完成或上下文被取消后关闭， Err（）方法返回当前Context结束的原因 若当前Context被取消返回Canceled错误 若当前Context超时就返回DeadlineExceed错误 Value（）方法会从Context中返回键对应的值， 3.1. Background()和TODO() go内置2个函数，Background（）和TODO（），这2个函数分别返回一个实现了Context接口的background和todo，代码中最开始以这2个内置的上下文对象作为最顶层的partent context，衍生出更多的子上下文对象 Background（）主要用于main函数，初始化以及测试代码中，作为context这个树结构的最顶层的Context，也是根Context TODO（），目前不知道具体场景， background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context 4. With系列函数 context包中包含了2个with系列函数 4.1. WithCancel WithCancel返回带有新Done通道的父节点的副本，当调用cancel函数时，将关闭返回上下文的Done通道， 函数签名： func WithCancel(parent Context) (ctx Context, cacel CancelFunc) e.g. package main import ( \"context\" \"fmt\" ) func gen(ctx context.Context) 4.2. WithDeadline 函数签名： func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) 返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。 package main import ( \"context\" \"fmt\" \"time\" ) func main() { // 定义一个50毫秒后过期的上下文，得到ctx上下文，和其对应的取消函数 d := time.Now().Add(50 * time.Millisecond) ctx, cancel := context.WithDeadline(context.Background(), d) // 尽管这个ctx只有50毫秒就会过期，任何情况下，明确调用它的cancel（）函数都是好的实践 // 若不这样做，可能会使得其上下文及其父类存活的时间超过必要的时间 defer cancel() select { case 程序会阻塞在select中，因为50毫秒先到，所以会阻塞到先执行第二个case，50毫秒后，ctx过期，ctx.Done()收到内容，然后打印ctx的Err信息； 4.3. WithTimeout package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func worker(ctx context.Context) { LOOP: for { fmt.Println(\"db connecting...\") time.Sleep(time.Millisecond * 10) select { // 这里会因为50毫秒的过期时间到而退出，而不是因为调用了cancel函数，因为这个函数在5s后才会被调用 case 4.4. WithValue 没看明白？ 函数签名： func WithValue(parent Context, key, val interface{}) Context e.g. package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) // context.WithValue type TraceCode string var wg sync.WaitGroup func worker(ctx context.Context) { key := TraceCode(\"TRACE_CODE\") traceCode, ok := ctx.Value(key).(string) // 在子goroutine中获取trace code if !ok { fmt.Println(\"invalid trace code\") } LOOP: for { fmt.Printf(\"worker, trace code:%s\\n\", traceCode) time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case 5. Context注意事项 推荐以参数的方式显式传递Context 以Context作为参数的函数方法，应该将Context作为第一个参数 给一个函数传递Context时，不要传递nil，若不知道传递什么，传递context.TODO() Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数 Context是线程安全的，可以放心的在多个goroutine中传递 6. 客户端超时取消示例 调用服务端的api时，如何在客户端实现超时控制； 6.1. server端 正常的编写一个httpHandler函数 在其中加入一个随机数，制造随机的响应延迟，模拟服务端的响应延迟 代码： package main import ( \"fmt\" \"math/rand\" \"net/http\" \"time\" ) func indexHandler(w http.ResponseWriter, r *http.Request) { // 生成一个随机数 number := rand.Intn(2) if number == 0 { time.Sleep(time.Second * 5) fmt.Fprintf(w, \"slow response\") return } fmt.Fprintf(w, \"normal response\") } func main() { http.HandleFunc(\"/\", indexHandler) err := http.ListenAndServe(\":8080\", nil) if err != nil { fmt.Println(\"listen failed \", err) return } } 6.2. client端 先定义一个全局的结构体，respData用于存储要收到的响应，包含2个字段 resp *http.Response类型 err 可能的error类型 在main函数中，定义一个100毫秒的超时，获得对应生命周期的ctx和其cancel（）函数 注册一个defer，显式的调用cancel（） 调用客户端请求函数，子函数中 定义一个通道rChan，类型是*respData类型， http.Client函数，构造一个client对象 http.NewRequest函数，构造一个req对象 利用req的WithContext方法传入ctx上下文，得到，有超时时长的新req 然后开启 一个goroutine，利用client.Do(req)去发起请求 若正常请求到了，没超时，把得到resp和err组成一个*respData类型，丢到rChan中，下面的select会收到并执行对应的正常分支 若没请求到，超时了，无法得到resp和err，也就无法构造*respData类型，丢不到rChan中，此时一旦过了50毫秒的时间，ctx过期，下面的select ctx.Done()分支会收到，并执行对于的超时分支 程序继续向下走，在select中定义2个分支， 要么ctx.Done()中得到值，表示请求超时了，超时的提示超时信息 要么resp的通道中得到值，表示正常未超时，没超时的把响应正常打印 package main import ( \"context\" \"fmt\" \"net/http\" \"time\" ) // 定义一个类型，用于存放响应数据 type respData struct { resp *http.Response err error } func doReq(ctx context.Context) { // 定义个chan，用于传递响应数据 var rChan = make(chan *respData, 1) // 构造client,是短链接类型 transport := &http.Transport{ DisableKeepAlives: true, } client := &http.Client{ Transport: transport, } // 构造请求Request,其类型是*http.Request req, err := http.NewRequest(\"GET\", \"http://127.0.0.1:8080\", nil) if err != nil { fmt.Println(\"new request failed,\", err) return } // 利用*http.Request类型的WithContext方法，将得到的req，变成一个带有ctx的50毫秒超时时长的新req对象 req = req.WithContext(ctx) // 开启goroutine执行向服务端发起请求 go func() { resp, err := client.Do(req) if err != nil { fmt.Println(\"request to server failed,\") return } // 如果正常请求，构造得到的resp和err respData1 := &respData{ resp: resp, err: err, } rChan client优化： 利用WaitGroup对goroutine进行同步 得到的resp，应该调用其Body.Close()方法进行关闭 package main import ( \"context\" \"fmt\" \"io/ioutil\" \"net/http\" \"sync\" \"time\" ) // 定义一个类型，用于存放响应数据 type respData struct { resp *http.Response err error } func doReq(ctx context.Context) { // 定义个chan，用于传递响应数据 var rChan = make(chan *respData, 1) // 构造client,是短链接类型 transport := &http.Transport{ DisableKeepAlives: true, } client := &http.Client{ Transport: transport, } // 构造请求Request,其类型是*http.Request req, err := http.NewRequest(\"GET\", \"http://127.0.0.1:8080\", nil) if err != nil { fmt.Println(\"new request failed,\", err) return } // 利用*http.Request类型的WithContext方法，将得到的req，变成一个带有ctx的50毫秒超时时长的新req对象 req = req.WithContext(ctx) // 开启goroutine执行向服务端发起请求 var wg sync.WaitGroup wg.Add(1) defer wg.Wait() go func() { defer wg.Done() resp, err := client.Do(req) if err != nil { fmt.Println(\"request to server failed,\") return } // 如果正常请求，构造得到的resp和err respData1 := &respData{ resp: resp, err: err, } rChan 6.3. 运行效果： 优化后效果： latteplus            updated 2021-02-15 10:40:45 "},"4-go与Web开发/1-ginDemo项目.html":{"url":"4-go与Web开发/1-ginDemo项目.html","title":"1-ginDemo项目","keywords":"","body":"1. goWeb示例1.1. net/http包实现简单web1.1.1. 直接响应特定字符串1.1.2. 响应从文件中读取的内容2. gin框架项目2.1. gin简介2.2. gin示例2.3. gin的restfulApi示例2.4. template模版与渲染2.4.1. go原生模版渲染示例1. goWeb示例 1.1. net/http包实现简单web 读取简单的html文件并返回； 1.1.1. 直接响应特定字符串 1、利用内置的net/http包实现一个简单的web server package main import ( \"fmt\" \"net/http\" ) func sayHello(w http.ResponseWriter, r *http.Request) { _, _ = fmt.Fprint(w, \" hello Golang good good coding \") } func main() { http.HandleFunc(\"/hello\", sayHello) err := http.ListenAndServe(\":9090\", nil) if err != nil { fmt.Printf(\"http server started failed : %v\\n\", err) return } } 2、启动后访问 先启动： D:\\myCode\\Go\\src\\ginDemo>ginDemo.exe 1.1.2. 响应从文件中读取的内容 1、新建一个html文件 this is hello.html hello Golang coding is cool 点击切换图片 document.getElementById(\"b1\").onclick=function () { document.getElementById('img1').src='http://n.sinaimg.cn/sinakd20210215ac/716/w877h1439/20210215/ddc0-kkciesq5349785.jpg' } 2、将sayHello函数改为从html文件中读取内容后，然后响应给前端 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func sayHello(w http.ResponseWriter, r *http.Request) { // 从二进制所在目录找到hello.html文件，读取后得到[]byte类型 respStr, err := ioutil.ReadFile(\"./hello.html\") // 对可能的错误进行处理 if err != nil { fmt.Println(\"read from ./hello.html failed, please check the file.\") return } // 将读取的内容，写到w中，从而可以被客户端接收到，一般是浏览器，（一定要转为string类型，否则无法正常展示页面） _, _ = fmt.Fprint(w, string(respStr)) } func main() { http.HandleFunc(\"/hello\", sayHello) err := http.ListenAndServe(\":9090\", nil) if err != nil { fmt.Printf(\"http server started failed : %v\\n\", err) return } } 3、再次访问，就得到了hello.html解析后的界面 点击按钮，通过js注册的按钮动作，可以实现更换图片 2. gin框架项目 2.1. gin简介 https://www.liwenzhou.com/posts/Go/Gin_framework/ 2.2. gin示例 2.3. gin的restfulApi示例 2.4. template模版与渲染 https://www.liwenzhou.com/posts/Go/go_template/ 2.4.1. go原生模版渲染示例 latteplus            updated 2021-02-15 10:40:45 "}}